## PostgreSQL Oracle 兼容性之 - 全局临时表 global temp table       
                                                                     
### 作者                                                                     
digoal                                                                     
                                                                     
### 日期                                                                     
2018-07-15                                                                  
                                                                     
### 标签                                                                     
PostgreSQL , 临时表 , 全局临时表 , unlogged table , advisory lock      
                                                                     
----                                                                     
                                                                     
## 背景      
PostgreSQL 暂时不支持类似Oracle风格的临时表。  
  
PostgreSQL 临时表结构是会话级别的，而在Oracle中，临时表的结构是全局有效的，只是数据会话之间独立。      
    
Oracle 全局临时表可以指定SCHEMA，而PostgreSQL的临时表不能指定SCHEMA，自动在temp临时SCHEMA中创建。    
  
细节差异详见：  
      
https://www.codeproject.com/Articles/1176045/Oracle-style-global-temporary-tables-for-PostgreSQL    
    
为了让PostgreSQL临时表的使用与Oracle兼容，除了内核层面兼容之外，目前只能在使用时注意。      
  
```  
CREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } | UNLOGGED ] TABLE [ IF NOT EXISTS ] table_name ( [  
  { column_name data_type [ COLLATE collation ] [ column_constraint [ ... ] ]  
    | table_constraint  
    | LIKE source_table [ like_option ... ] }  
    [, ... ]  
] )  
...........  
[ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]    
  
-- 提交后，保留记录        PRESERVE ROWS  
-- 提交后，清空临时表记录  DELETE ROWS  
-- 提交后，删除临时表      DROP  
```  
      
用户可以使用以下方式来使用临时表：     
  
## 1、使用 trigger + inherit 代替临时表 (用户使用形态与ORACLE一致)  
思想来自如下，与之不一样的地方是，直接使用的表触发器+继承功能来实现的。  
  
https://www.codeproject.com/Articles/1176045/Oracle-style-global-temporary-tables-for-PostgreSQL  
  
以上这个链接的方法不支持truncate, copy。使用函数返回所有记录，会有一些性能问题，索引使用也比较麻烦。      
  
下面的方法没有以上问题（除了不支持直接TRUNCATE），但是INSERT和COPY的性能会比较差（每秒约写入3万条，普通表的写入速度约50万行/s）。     
  
例子  
  
创建一个临时表 stage.abc。     
  
1、创建一个schema，放临时表  
  
```  
create schema IF NOT EXISTS stage;  
```  
    
2、创建表stage.abc     
  
```  
drop table if exists stage.abc;  
  
create table if not exists stage.abc (id int primary key, info text, crt_time timestamp);   
```  
    
3、创建这个"stage.abc表"的触发器，自动基于它创建临时表，并加入它的继承关系      
  
自定义insert触发器    
  
```  
create or replace function public.abc_tg1() returns trigger as $$  
declare  
begin  
  -- 判断当前会话是否已经创建了临时表  
  perform 1 from pg_class where relpersistence='t' and relname=TG_TABLE_NAME and pg_table_is_visible(oid);    
  
  if not found then  
    -- 根据临时表的业务需要使用on commit PRESERVE|DELETE rows     
    execute format('create temp table if not exists %I (like %I.%I including all) inherits (%I.%I) on commit PRESERVE ROWS',     
      TG_TABLE_NAME, TG_TABLE_SCHEMA, TG_TABLE_NAME, TG_TABLE_SCHEMA, TG_TABLE_NAME);  
      
    -- 如果临时表的定义修改，修改这个触发器的内容，即表名abc，使用你的实际名字替换  
    -- 注意这里不要加schema.，否则就写入非临时表了。  
    insert into abc values (new.*);     
  else  
    -- 如果临时表的定义修改，修改这个触发器的内容，即表名abc，使用你的实际名字替换  
    -- 注意这里不要加schema.，否则就写入非临时表了。  
    insert into abc values (new.*);    
  end if;  
  return null;   
end;  
$$ language plpgsql strict set client_min_messages = error;  
```  
  
4、新建stage.abc的insert before触发器   
  
```  
create trigger tg1 before insert on stage.abc for each row execute function public.abc_tg1();   
```  
  
5、测试，完全OK  
  
```  
insert into stage.abc values (1,'test',now());  
insert into stage.abc values (2,'test',now());  
  
select tableoid, * from stage.abc;  
```  
  
delete, update, copy 均使用正常。    
  
每个会话使用完全独立。  
  
### 一些使用限制  
  
1、truncate无法使用，请使用delete代替    
  
```  
postgres=# truncate stage.abc;  
ERROR:  0A000: cannot truncate temporary tables of other sessions  
LOCATION:  truncate_check_rel, tablecmds.c:1743  
Time: 0.626 ms  
  
  
-- delete正常  
delete from stage.abc;  
```  
  
2、copy to 不支持 (copy from 正常)  
  
原因：copy时，不读取INHERIT表的内容。  
  
```  
postgres=# copy stage.abc to '/tmp/abc';  
COPY 0  
```  
  
所以，直接使用临时表名可以COPY TO  
  
```  
postgres=# copy abc to '/tmp/abc';  
COPY 1000  
  
  
postgres=# copy stage.abc from '/tmp/abc';  
COPY 0  
postgres=# select count(*) from stage.abc;  
 count   
-------  
  1000  
(1 row)  
```  
  
3、由于使用了insert触发器，INSERT时，数据都写入了继承的临时表，所以returning语法无法获得返回行数，记录。  
  
```  
postgres=# insert into stage.abc values (-1) returning *;  
 id | info | crt_time   
----+------+----------  
(0 rows)  
  
INSERT 0 0  
```  
  
## 2、用临时表时提前创建      
1、创建临时表模板（一次性创建）    
    
```  
-- 临时表模板  
create table tmp1_template(xxxx);    
```  
    
2、以后每次使用某临时表之前，使用这个模板表创建临时表。     
      
```      
create temp table if not exists tmp_xxx (like tmp1_template including all) ON COMMIT DELETE ROWS;      
```     
  
3、以后要修改临时表的结果，直接修改模板表  
  
```  
alter table tmp_xxx add column c1 int;  
```  
    
例子    
    
```  
-- 创建临时表模板表  
create table tmp1_template (id int8 primary key, info text, crt_time timestamp);    
  
-- 每次使用临时表前，先使用模板创建    
create temp table if not exists tbl_tmp (like tmp1_template including all) ON COMMIT DELETE ROWS;     
  
-- 以后要修改临时表的结果，直接修改模板表  
alter table tmp1_template add column c1 int;  
```  
      
## 3、plpgsql中，可以使用方法1，也可以使用ARRAY代替临时表        
      
创建普通表（默认会创建对应的复合类型），      
      
使用复合类型数组代替临时表      
      
      
例子      
      
```      
do language plpgsql $$      
declare      
  res tbl[]; x tbl;      
begin      
  select array_agg(t::tbl) into res from (select id, random()::text, clock_timestamp() from generate_series(1,10) t(id)) t;      
  raise notice 'res: %', res;       
  foreach x in array res loop       
    raise notice 'x: %', x;       
  end loop;        
end;      
$$;      
NOTICE:  res: {"(1,0.0940282950177789,\"2018-07-15 23:14:44.060389\")","(2,0.922331794165075,\"2018-07-15 23:14:44.060404\")","(3,0.857550186105072,\"2018-07-15 23:14:44.060406\")","(4,0.373486907221377,\"2018-07-15 23:14:44.060408\")","(5,0.973780393600464,\"2018-07-15 23:14:44.060409\")","(6,0.502839601133019,\"2018-07-15 23:14:44.060411\")","(7,0.217925263568759,\"2018-07-15 23:14:44.060412\")","(8,0.733274032827467,\"2018-07-15 23:14:44.060413\")","(9,0.62150136847049,\"2018-07-15 23:14:44.060416\")","(10,0.241393140517175,\"2018-07-15 23:14:44.060418\")"}      
NOTICE:  x: (1,0.0940282950177789,"2018-07-15 23:14:44.060389")      
NOTICE:  x: (2,0.922331794165075,"2018-07-15 23:14:44.060404")      
NOTICE:  x: (3,0.857550186105072,"2018-07-15 23:14:44.060406")      
NOTICE:  x: (4,0.373486907221377,"2018-07-15 23:14:44.060408")      
NOTICE:  x: (5,0.973780393600464,"2018-07-15 23:14:44.060409")      
NOTICE:  x: (6,0.502839601133019,"2018-07-15 23:14:44.060411")      
NOTICE:  x: (7,0.217925263568759,"2018-07-15 23:14:44.060412")      
NOTICE:  x: (8,0.733274032827467,"2018-07-15 23:14:44.060413")      
NOTICE:  x: (9,0.62150136847049,"2018-07-15 23:14:44.060416")      
NOTICE:  x: (10,0.241393140517175,"2018-07-15 23:14:44.060418")      
DO      
```     
  
  
      
## 4、预创建表结构，使用起来比较复杂，不推荐      
      
创建父表      
      
预创建一些继承表      
      
使用时，使用advisory lock保护，挑选其中一个继承表使用      
      
例子      
      
```      
-- 创建父表      
      
create table tmp1(id int, info text, crt_time timestamp);      
      
-- 创建100个子表      
      
do language plpgsql $$      
declare      
begin      
  for i in 1..100 loop      
    execute format('create unlogged table tmp1_%s (like tmp1 including all) inherits (tmp1)', i);      
  end loop;      
end;      
$$;      
```      
      
创建加锁函数，返回值即后缀      
      
```      
create or replace function get_lock() returns int as $$      
declare      
begin      
  for i in 1..100 loop      
    if pg_try_advisory_lock(i) then      
      return i;      
    end if;      
  end loop;      
  return '-1';      
end;      
$$ language plpgsql strict;      
```      
      
加锁，返回1则使用后缀为1的临时表      
      
```      
postgres=# select get_lock();      
 get_lock       
----------      
        1      
(1 row)      
```      
      
使用临时表      
      
```      
truncate tmp1_1;      
      
... 使用 tmp1_1      
```      
      
      
释放锁      
      
```      
postgres=# select pg_advisory_unlock(1);      
 pg_advisory_unlock       
--------------------      
 t      
(1 row)      
```      
      
### 可以精细化      
      
1、维护1张表，后缀ID为PK，这样的话advisory lock id在全局都不会冲突      
      
```      
create table catalog_tmp (      
  tmp_tbl name,      
  prefix name,      
  suffix int primary key      
);      
      
create index idx_catalog_tmp_1 on catalog_tmp(tmp_tbl);      
```      
      
```      
insert into catalog_tmp select 'tmp1','tmp1',generate_series(1,100);      
```      
      
2、申请临时表锁时，使用一个函数，从前面的表中获取前后缀，直接返回表名。      
      
```      
create or replace function get_tmp(name) returns text as $$      
declare      
  i int;      
  v name;      
begin      
  for i,v in select suffix,prefix from catalog_tmp where tmp_tbl=$1       
  loop      
    if pg_try_advisory_lock(i) then      
      return v||'_'||i;      
    end if;      
  end loop;      
end;      
$$ language plpgsql strict;      
```      
      
3、申请临时表，返回的就是当前会话可以使用的临时表名      
      
```      
postgres=# select get_tmp('tmp1');      
 get_tmp       
---------      
 tmp1_1      
(1 row)      
```      
      
4、释放临时表的函数。     
      
```      
create or replace function release_tmp(name) returns void as $$    
declare    
begin    
  loop    
    if not pg_advisory_unlock(substring($1,'_(\d*)$')::int) then    
      return;    
    end if;    
  end loop;    
end;    
$$ language plpgsql strict;    
```      
    
释放临时表(注意，不释放的话，其他会话就不可用使用这个临时表)      
    
```    
select release_tmp('tmp1_1');    
```    
    
        
## 5、其他，内核层面支持临时表     
      
https://postgrespro.com/roadmap/56516      
      
## 参考      
https://postgrespro.com/roadmap/56516        
      
https://www.codeproject.com/Articles/1176045/Oracle-style-global-temporary-tables-for-PostgreSQL    
    
<a rel="nofollow" href="http://info.flagcounter.com/h9V1"  ><img src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"  alt="Flag Counter"  border="0"  ></a>    
    
    
    
    
    
    
## [digoal's 大量PostgreSQL文章入口](https://github.com/digoal/blog/blob/master/README.md "22709685feb7cab07d30f30387f0a9ae")  
    
    
## [免费领取阿里云RDS PostgreSQL实例、ECS虚拟机](https://free.aliyun.com/ "57258f76c37864c6e6d23383d05714ea")  
    
