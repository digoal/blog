## PostgreSQL 复杂SQL优化器优化建议 - pg_plan_advsr  
        
### 作者        
digoal        
        
### 日期        
2019-03-18        
        
### 标签        
PostgreSQL , 优化建议 , 复杂SQL , geqo    
        
----        
        
## 背景    
对于JOIN表特别多的SQL，优化器不一定能给出最佳的执行方法。  
  
1、由于表太多，穷举法需要耗费很长的PLAN时间。  
  
2、同时，多层JOIN后，估算会不准确。导致执行计划不准。  
  
优化方法：  
  
1、人肉固定JOIN顺序，不适合动态条件。  
  
2、使用动态规划优化器。目前的优化器是静态的，即生成执行树后，EXECUTOR就按计划执行，执行过程中不会改变执行顺序。由于JOIN层次很深，第一步估算可能是准确的，但是层次越深，选择性估算就越不准确，所以总体计划会不好。  
  
动态规划是指在执行过程中，根据执行结果进行规划，从而每一步都可以很准。  
  
适合复杂SQL。  
  
pg_plan_advsr这个插件是PG的一个复杂SQL优化插件。将最佳执行计划进行存储，实际上使用了hint插件来改写执行计划。  
  
https://github.com/ossc-db/pg_plan_advsr/blob/master/README.md  
  
## 例子，取自readme  
There are two types of usage.  
  
### For auto plan tuning  
  
select pg_plan_advsr_enable_feedback(); Execute EXPLAIN ANALYZE command (which is your query) repeateadly until row estimation errors had vanished.  
  
See shell script file as an example: JOB/auto_tune_31c.sh  
  
Note:  
  
A plan may temporarily worse than an initial plan during auto tuning phase.  
Use stable data for auto plan tuning. This extension doesn't get converged plan (the ideal plan for the data) if it was updating concurrently.  
### For only getting hints to reproduce a plan on other databases  
  
select pg_plan_advsr_disable_feedback(); Execute EXPLAIN ANALYZE command (which is your query). You can get hints by using the below queries:  
  
```  
select pgsp_queryid, pgsp_planid, execution_time, scan_hint, join_hint, lead_hint from plan_repo.plan_history order by id;  
```  
  
e.g.  
  
```  
 pgsp_queryid | pgsp_planid | execution_time |                scan_hint                |     join_hint      |        lead_hint  
--------------+-------------+----------------+-----------------------------------------+--------------------+-------------------------  
   4173287301 |  3707748199 |        265.179 | SEQSCAN(t2) SEQSCAN(x) INDEXSCAN(t1)    | HASHJOIN(t2 t1 x) +| LEADING( (t2 (x t1 )) )  
              |             |                |                                         | NESTLOOP(t1 x)     |  
   4173287301 |  1101439786 |          2.149 | SEQSCAN(x) INDEXSCAN(t1) INDEXSCAN(t2)  | NESTLOOP(t2 t1 x) +| LEADING( ((x t1 )t2 ) )  
              |             |                |                                         | NESTLOOP(t1 x)     |  
  
# \a  
Output format is unaligned.  
# \t  
Tuples only is on.  
    
select plan_repo.get_hint(1101439786);  
    
/*+  
LEADING( ((x t1 )t2 ) )  
NESTLOOP(t2 t1 x)  
NESTLOOP(t1 x)  
SEQSCAN(x) INDEXSCAN(t1) INDEXSCAN(t2)  
*/  
--1101439786  
```  
  
## 参考    
https://github.com/ossc-db/pg_plan_advsr  
    
https://github.com/ossc-db  
     
    
<a rel="nofollow" href="http://info.flagcounter.com/h9V1"  ><img src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"  alt="Flag Counter"  border="0"  ></a>        
        
        
## [digoal's 大量PostgreSQL文章入口](https://github.com/digoal/blog/blob/master/README.md "22709685feb7cab07d30f30387f0a9ae")        
        
        
## [免费领取阿里云RDS PostgreSQL实例、ECS虚拟机](https://free.aliyun.com/ "57258f76c37864c6e6d23383d05714ea")        
     
