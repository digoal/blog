## PostgreSQL 12 preview - pgbench 压测工具编程能力增强 - gset 支持SQL结果返回并存入变量使用  
                                                              
### 作者                                                              
digoal                                                              
                                                              
### 日期                                                              
2019-03-31                                                              
                                                              
### 标签                                                              
PostgreSQL , pgbench , gset , 返回 , 变量 , 再使用    
                                                              
----                                                              
                                                              
## 背景             
pgbench是PG的内置压测工具，内置TPC-B压测，同时支持非常强大的编程能力，可以支持压测各种用户模型。  
  
PG 12 pgbench支持gset功能，将一条SQL的结果（单条结果）返回并存入pgbench的变量中。这个变量可以被pgbench后面的SQL引用。  
  
https://git.postgresql.org/gitweb/?p=postgresql.git;a=commit;h=6260cc550b0e  
  
```  
pgbench: add \cset and \gset commands  
  
These commands allow assignment of values produced by queries to pgbench  
variables, where they can be used by further commands.  \gset terminates  
a command sequence (just like a bare semicolon); \cset separates  
multiple queries in a compound command, like an escaped semicolon (\;).  
A prefix can be provided to the \-command and is prepended to the name  
of each output column to produce the final variable name.  
  
This feature allows pgbench scripts to react meaningfully to the actual  
database contents, allowing more powerful benchmarks to be written.  
  
Authors: Fabien Coelho, Álvaro Herrera  
Reviewed-by: Amit Langote <Langote_Amit_f8@lab.ntt.co.jp>  
Reviewed-by: Stephen Frost <sfrost@snowman.net>  
Reviewed-by: Pavel Stehule <pavel.stehule@gmail.com>  
Reviewed-by: Tom Lane <tgl@sss.pgh.pa.us>  
Reviewed-by: Tatsuo Ishii <ishii@sraoss.co.jp>  
Reviewed-by: Rafia Sabih <rafia.sabih@enterprisedb.com>  
Discussion: https://postgr.es/m/alpine.DEB.2.20.1607091005330.3412@sto  
```  
  
## gset 用法介绍  
```  
\gset 代替分号，作为语句结束。 使用\gset时，查询结果存入PGBENCH变量，并且\gset结尾的SQL语句被期望返回一行记录。  
  
变量名为SQL alias.  
  
\gset prefix  ， prefix作为变量的前缀。  
  
\get 语句的下一行加一个分号，表示上面这条gset的结束 - 可能PG 12正式RELEASE后，不会这么麻烦  
```  
  
例子  
  
```  
UPDATE pgbench_accounts  
  SET abalance = abalance + :delta  
  WHERE aid = :aid  
  RETURNING abalance \gset  
  
后面的pgbench可以使用:abalance变量。  
  
SELECT 2 AS two, 3 AS three \gset p_  
  
后面的pgbench脚本中，可以使用p_two, p_three这两个变量。  
```  
  
用法：  
  
```  
\gset [prefix]  
  
This command may be used to end SQL queries, taking the place of the terminating semicolon (;).  
  
When this command is used, the preceding SQL query is expected to return one row,   
the columns of which are stored into variables named after column names,   
and prefixed with prefix if provided.  
  
The following example puts the final account balance from the first query into variable abalance,   
and fills variables p_two and p_three with integers from the third query.   
The result of the second query is discarded.  
  
UPDATE pgbench_accounts  
  SET abalance = abalance + :delta  
  WHERE aid = :aid  
  RETURNING abalance \gset  
-- compound of two queries  
SELECT 1 \;  
SELECT 2 AS two, 3 AS three \gset p_  
```  
  
## 例子  
1、例如a表，存储用户的关系。b表，存储用户的信息。  
  
写入1000万用户数据，每个用户10个相关的用户。  
  
```  
create unlogged table a (id int primary key , refid int[]);  
  
create unlogged table b (id int primary key , info text, crt_time timestamp);  
  
create or replace function gen_rand_arr () returns int[] as $$  
  select array(select (random()*1000000)::int from generate_series(1,10));  
$$ language sql strict;  
  
insert into a select generate_series(1,10000000) , gen_rand_arr();  
  
insert into b select id, md5(random()::Text), now() from generate_series(1,10000000) t(id);  
```  
  
2、压测，随机查询某个用户，查询到的这个用户相关的用户，refid结果作为下一条SQL的输入，将这些相关用户的内容也查出来。  
  
```  
vi test.sql  
  
\set id random(1,10000000)  
select refid from a where id=:id \gset p_  
;  
select * from b where id = any (:p_refid);  
```  
  
```  
/home/digoal/pg12/bin/pgbench -M prepared -n -r -P 1 -f ./test.sql -c 58 -j 58 -T 120 -h /tmp -p 3335 -U postgres postgres  
  
  
transaction type: ./test.sql  
scaling factor: 1  
query mode: prepared  
number of clients: 58  
number of threads: 58  
duration: 120 s  
number of transactions actually processed: 20725532  
latency average = 0.335 ms  
latency stddev = 0.115 ms  
tps = 172703.674649 (including connections establishing)  
tps = 172712.149229 (excluding connections establishing)  
statement latencies in milliseconds:  
         0.001  \set id random(1,10000000)  
         0.056  select refid from a where id=:id   
         0.023  ;  
         0.257  select * from b where id = any (:p_refid);  
```  
  
另一个例子  
  
```  
vi test.sql  
\set id random(1,1000000000)  
insert into p values (:id,md5(random()::text),now()) on conflict(id) do nothing returning id \gset res_  
;  
insert into p values (:res_id-1000000000,'test',now()) on conflict(id) do nothing;  
```  
  
更多用法请参考pgbench帮助文件。  
  
https://www.postgresql.org/docs/devel/pgbench.html  
     
## 参考  
https://git.postgresql.org/gitweb/?p=postgresql.git;a=commit;h=6260cc550b0e  
  
https://www.postgresql.org/docs/devel/pgbench.html  
    
  
<a rel="nofollow" href="http://info.flagcounter.com/h9V1"  ><img src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"  alt="Flag Counter"  border="0"  ></a>  
  
  
## [digoal's 大量PostgreSQL文章入口](https://github.com/digoal/blog/blob/master/README.md "22709685feb7cab07d30f30387f0a9ae")
  
  
## [免费领取阿里云RDS PostgreSQL实例、ECS虚拟机](https://free.aliyun.com/ "57258f76c37864c6e6d23383d05714ea")
  
