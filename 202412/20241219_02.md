## 穷鬼玩PolarDB RAC一写多读集群系列 | 时间点恢复(PITR)      
        
### 作者      
digoal      
      
### 日期        
2024-12-19      
      
### 标签       
PostgreSQL , PolarDB , DuckDB , docker , 时间点恢复 , PITR    
         
----        
       
## 背景            
           
穷鬼玩PolarDB RAC一写多读集群系列已经写了几篇:           
- [《在Docker容器中用loop设备模拟共享存储》](../202412/20241216_03.md)           
- [《如何搭建PolarDB容灾(standby)节点》](../202412/20241218_01.md)          
- [《共享存储在线扩容》](../202412/20241218_02.md)           
- [《计算节点 Switchover》](../202412/20241218_03.md)          
- [《在线备份》](../202412/20241218_04.md)       
- [《在线归档》](../202412/20241218_05.md)       
- [《实时归档》](../202412/20241219_01.md)       
            
本篇文章介绍一下如何进行实时归档?  实验环境依赖 [《在Docker容器中用loop设备模拟共享存储》](../202412/20241216_03.md) , 如果没有环境, 请自行参考以上文章搭建环境.               
     
还需要参考如下文档:        
- https://www.postgresql.org/docs/current/continuous-archiving.html  
    
   
## DEMO    
在实时归档机pb4容器演示PITR.     
  
1、首先, 假设你已经按下文开启了实时归档. 确保未来的全量备份有足够的WAL可以用于时间点恢复.    
- [《实时归档》](../202412/20241219_01.md)       
  
2、其次, 在开启实时归档后, 假设你已经按下文做了一次全量备份.   
- [《在线备份》](../202412/20241218_04.md)       
  
得到:    
- 本地数据目录: `/data/backup/primary`  
- 共享数据目录: `/data/backup/shared_data`  
  
3、在pb1 primary节点生成一些数据.   
```  
postgres=# create table tbl_digoal (id int, info text, ts timestamp);  
CREATE TABLE  
postgres=# insert into tbl_digoal select generate_series(1,1000), md5(random()::text), clock_timestamp();  
INSERT 0 1000  
postgres=# select * from tbl_digoal limit 5;  
 id |               info               |             ts               
----+----------------------------------+----------------------------  
  1 | 45085479f931ea4bb0c39ec73522cdb4 | 2024-12-19 16:27:37.748317  
  2 | afc44037b7fac9feaa8d3567f331d0db | 2024-12-19 16:27:37.750813  
  3 | 37bcea4e172f13590c5bce35fc965880 | 2024-12-19 16:27:37.750821  
  4 | 0a09b7c73a8994d5023b796cb7aa7e13 | 2024-12-19 16:27:37.750824  
  5 | 37b98e2e52ddd1c6287ceb8624d7bf0a | 2024-12-19 16:27:37.750826  
(5 rows)  
  
postgres=# select sum(hashtext(t::text)) from tbl_digoal t;  
     sum        
--------------  
 -71405674348  
(1 row)  
```  
  
4、创建一个恢复点. 记住这个名字, 后面用来恢复.    
```  
postgres=# select now();  
              now                
-------------------------------  
 2024-12-19 16:28:27.517757+08  
(1 row)  
  
postgres=# select pg_create_restore_point('2024-12-19 16:28:27.517757+08');  
 pg_create_restore_point   
-------------------------  
 2/8003E6C0  
(1 row)  
```  
  
5、在pb1 primary节点修改以上生成的数据.  
```  
postgres=# delete from tbl_digoal where id=10;  
DELETE 1  
postgres=# update tbl_digoal set info='new' where id=1;  
UPDATE 1  
postgres=# select sum(hashtext(t::text)) from tbl_digoal t;  
     sum        
--------------  
 -70843053399  
(1 row)  
```  
  
6、使用备份和归档日志, 将PolarDB恢复到数据被修改之前.     
  
先确保wal日志都已经被实时归档`pg_current_wal_lsn`与`flush_lsn`  
```  
postgres=# select pg_current_wal_lsn(),* from pg_stat_replication where application_name='pg_receivewal';  
-[ RECORD 1 ]------+------------------------------  
pg_current_wal_lsn | 2/8003E9A0  
pid                | 5255  
usesysid           | 10  
usename            | postgres  
application_name   | pg_receivewal  
client_addr        | 172.17.0.5  
client_hostname    |   
client_port        | 58302  
backend_start      | 2024-12-19 16:32:26.754692+08  
backend_xmin       |   
state              | streaming  
sent_lsn           | 2/8003E9A0  
write_lsn          | 2/8003E9A0  
flush_lsn          | 2/8003E9A0  
replay_lsn         |   
write_lag          | 00:00:00.002957  
flush_lag          | 00:00:00.002957  
replay_lag         | 00:00:00.002957  
sync_priority      | 0  
sync_state         | async  
reply_time         | 2024-12-19 16:32:26.762024+08  
```  
  
把以下备份拷贝到临时恢复目录中, 当然你也可以直接在备份上进行恢复, 只是这样就把备份文件破坏了. (这也是为什么我非常推崇zfs, 因为zfs 可以基于快照克隆(瞬间完成), 这样不会破坏原有的数据.)      
- 本地数据目录: `/data/backup/primary`  
- 共享数据目录: `/data/backup/shared_data`  
  
```  
mkdir /data/recovery  
cp -r /data/backup/primary /data/recovery/  
cp -r /data/backup/shared_data /data/recovery/  
```  
  
修改`postgresql.conf`配置文件  
```  
cd /data/recovery/primary    
  
vi postgresql.conf    
    
# 修改和注释如下      
polar_disk_name='home'      
polar_datadir='file-dio:///data/recovery/shared_data'      
polar_vfs.localfs_mode=true    
# polar_storage_cluster_name='disk'     
  
# 增加如下, 恢复目标, 拷贝wal的命令     
restore_command = 'cp /data/polardb_wal_archive/%f %p || cp /data/polardb_wal_archive/%f.partial %p'  
recovery_target_timeline = latest   
recovery_target_name = '2024-12-19 16:28:27.517757+08'  
recovery_target_action = 'pause'   
  
# 其他配置保持不变即可    
huge_pages=off   
port=5432    
polar_hostid=1    
polar_enable_shared_storage_mode=on    
shared_preload_libraries='$libdir/polar_vfs,$libdir/polar_worker'    
logging_collector=on    
log_line_prefix='%p\t%r\t%u\t%m\t'    
log_directory='pg_log'    
listen_addresses='0.0.0.0'    
max_connections=200   
```  
  
删除standby标记文件, 添加recovery标记文件  
```  
rm /data/recovery/primary/standby.signal   
rm /data/recovery/shared_data/standby.signal   
  
touch /data/recovery/primary/recovery.signal  
touch /data/recovery/shared_data/recovery.signal  
```  
  
启动数据库  
```  
pg_ctl start -D /data/recovery/primary  
```  
  
查看数据库日志, 可以看到已经恢复到了目标`recovery_target_name = '2024-12-19 16:28:27.517757+08'`  
```  
cd /data/recovery/primary/pg_log  
  
less postgresql-2024-12-19_165344_error.log  
  
4279                    2024-12-19 16:53:47.757 CST     LOG:  recovery stopping at restore point "2024-12-19 16:28:27.517757+08", time 2024-12-19 16:28:34.938012+08  
4279                    2024-12-19 16:53:47.757 CST     LOG:  pausing at the end of recovery  
4279                    2024-12-19 16:53:47.757 CST     HINT:  Execute pg_wal_replay_resume() to promote.  
```  
  
最后, 检查一下数据, 确实已经恢复到目标, 数据是更新之前的样子:  
```  
$ psql  
psql (PostgreSQL 15.10 (PolarDB 15.10.2.0 build d4f5477d debug) on aarch64-linux-gnu)  
Type "help" for help.  
  
postgres=# select count(*) from tbl_digoal ;  
 count   
-------  
  1000  
(1 row)  
  
postgres=# select sum(hashtext(t::text)) from tbl_digoal t;  
     sum        
--------------  
 -71405674348  
(1 row)  
```  
  
    
    
## 参考            
[《穷鬼玩PolarDB RAC一写多读集群系列 | 在Docker容器中用loop设备模拟共享存储》](../202412/20241216_03.md)                   
               
[《穷鬼玩PolarDB RAC一写多读集群系列 | 如何搭建PolarDB容灾(standby)节点》](../202412/20241218_01.md)             
          
[《穷鬼玩PolarDB RAC一写多读集群系列 | 共享存储在线扩容》](../202412/20241218_02.md)             
           
[《穷鬼玩PolarDB RAC一写多读集群系列 | 计算节点 Switchover》](../202412/20241218_03.md)             
      
[《穷鬼玩PolarDB RAC一写多读集群系列 | 在线备份》](../202412/20241218_04.md)        
    
[《穷鬼玩PolarDB RAC一写多读集群系列 | 在线归档》](../202412/20241218_05.md)        
  
[《穷鬼玩PolarDB RAC一写多读集群系列 | 实时归档》](../202412/20241219_01.md)      
    
https://www.postgresql.org/docs/current/continuous-archiving.html  
  
https://www.postgresql.org/docs/current/runtime-config-wal.html  
  
[《PostgreSQL PITR THREE recovery target MODE: name,xid,time USE CASE - 2》](../201302/20130205_01.md)    
  
[《PostgreSQL PITR THREE recovery target MODE: name,xid,time USE CASE - 1》](../201302/20130204_01.md)    
  
[《PostgreSQL recovery target introduce》](../201301/20130130_01.md)    
  
[《PostgreSQL 时间点恢复(PITR)时查找wal record的顺序 - loop(pg_wal, restore_command, stream)》](201805/20180516_04.md)    
  
[《PostgreSQL 增量备份集的有效恢复位点》](../201708/20170823_03.md)    
  
[《PostgreSQL如何支持可选择性表空间(Selectivity Tablespace)备份和时间点(PITR)恢复?》](../202401/20240107_01.md)    
  
  
