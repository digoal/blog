## AI论文解读 | Towards a Shared-storage-based Serverless Database Achieving Seamless Scale-up and Read Scale-out
        
### 作者        
digoal        
        
### 日期        
2025-07-19       
        
### 标签        
PostgreSQL , PolarDB , DuckDB , AI , 论文解读        
        
----        
        
## 背景  
      
http://cighao.com/papers/polardb_serverless.pdf        
  
      
提示:        
```        
读懂《Towards a Shared-storage-based Serverless Database Achieving Seamless Scale-up and Read Scale-out》这篇论文需要提前掌握哪些基础知识, 请使用中文给我讲一下这些基础知识, 尽量通熟易懂, 可以使用markdown支持的图形增加解释性.        
        
使用中文通熟易懂的解读《Towards a Shared-storage-based Serverless Database Achieving Seamless Scale-up and Read Scale-out》这篇论文, 关键内容请深入讲解, 可以使用markdown支持的图形增加解释性.        
        
使用中文提取《Towards a Shared-storage-based Serverless Database Achieving Seamless Scale-up and Read Scale-out》论文中一些重要的术语并详细解释, 可以使用markdown支持的图形示增加解释性.        
```        
        
## 1 前置知识 
  
好的，为了完全理解《Towards a Shared-storage-based Serverless Database Achieving Seamless Scale-up and Read Scale-out》这篇论文，你需要了解一些数据库和云计算领域的基础知识。我会用尽量通俗易懂的语言，并配合一些简单的图示来解释。

-----

### 核心知识地图

阅读这篇论文，你需要掌握以下几个核心领域的知识：

1.  **数据库系统架构 (Database Architecture)**：数据库是如何组织计算和存储的。
2.  **“无服务器”计算 (Serverless Computing)**：一种现代的云服务模型。
3.  **数据库的扩展性 (Scalability)**：数据库如何应对增长的负载。
4.  **数据一致性 (Data Consistency)**：在多用户环境下，如何保证读取的数据是“正确”的。
5.  **数据库事务与日志 (Transactions & Logs)**：数据库保证操作可靠性的内部机制。
6.  **高性能网络技术 (RDMA)**：论文中提到的加速技术。

下面我们来逐一讲解。

-----

### 1\. 数据库系统架构：共享存储 vs. 共享无关联

论文标题就点明了这是**基于共享存储 (Shared-storage)** 的数据库。你需要理解它和另一种主流架构——**共享无关联 (Shared-nothing)** 的区别。

#### 共享存储架构 (Shared-storage)

  * **通俗比喻**：想象一个中央图书馆（共享存储），所有图书管理员（计算节点）都可以访问馆里的任何一本书。管理员有分工，比如一个“主管理员”（Primary Node）负责登记新书和修改书籍信息（处理读写请求），而其他“副管理员”（Secondary Nodes）主要负责帮人查阅书籍（处理只读请求）。

  * **核心特点**：

      * 计算和存储是分离的。
      * 所有计算节点共享同一份数据。
      * 增加或减少管理员（计算节点）很方便，因为他们不需要自带书籍（数据）。

  * **简单图示**:

    ```markdown
        +---------------+   +---------------+
        |  计算节点 A    |   |  计算节点 B     |  <-- 主节点、备节点
        | (Primary)     |   | (Secondary)   |
        +-------+-------+   +-------+-------+
                |                   |
                +---------+---------+
                          |
                  +------------------+
                  |      共享存储     |  <-- 所有数据都在这里
                  | (Shared Storage) |
                  +------------------+
    ```

  * **与论文的关系**：这篇论文研究的就是这种架构。它的优点是扩展计算能力时，不需要移动大量数据，速度快。但论文也指出了它的挑战：主节点压力过大，以及节点迁移时可能导致服务中断。

#### 共享无关联架构 (Shared-nothing)

  * **通俗比喻**：想象一个大型连锁快餐店，每个分店（计算节点）都有自己的厨房、食材和员工（独立的存储和计算）。它们各自为政，服务自己片区的顾客。如果一个订单需要跨店协作（分布式事务），流程就会变得很复杂。

  * **核心特点**：

      * 每个节点都有自己独立的CPU、内存和硬盘。
      * 数据被分散存储在各个节点上。
      * 扩展时需要增加新的、完整的节点，并重新分配数据（数据重平衡），这个过程可能很慢。

  * **与论文的关系**：论文提到这种架构不适合需要快速、秒级弹性的无服务器场景，因为它扩展时的数据迁移成本太高。

-----

### 2\. “无服务器”计算 (Serverless)

  * **通俗比喻**：把它想象成“按需用水”而不是自己建水库。你不用关心水厂（服务器）在哪里、有多大、如何维护。你只需要在需要用水（运行代码/处理请求）的时候打开水龙头，水就会自动流过来，你只需要为你实际使用的水量付费。

  * **核心特点**：

      * **自动弹性 (Auto-scaling)**：根据负载自动增加或缩减资源。
      * **按需付费 (Pay-as-you-go)**：只为实际消耗的资源付费，没有负载时费用极低。
      * **无需管理服务器**：开发者专注于业务逻辑，不用关心底层硬件。

  * **与论文的关系**：这篇论文的目标就是构建一个**无服务器数据库**。这意味着数据库要能根据应用负载自动、快速地调整规模，同时做到成本效益最大化。论文指出现有产品在“自动弹性”方面做得不够好，尤其是在规模调整时会中断服务。

-----

### 3\. 数据库的扩展性：纵向扩展 vs. 横向扩展

这是数据库应对负载增加的两种主要方式。

  * **纵向扩展 (Scale-up)**：给一台机器增强配置。就像把你的笔记本电脑的CPU换成更强的i9，内存从16GB加到64GB。机器还是那一台，但变得更强了。

  * **横向扩展 (Scale-out)**：增加更多机器来分担任务。就像一个收银台忙不过来，就再开几个新的收银台。

  * **与论文的关系**：论文标题中的 **Scale-up** 和 **Read Scale-out** 就是这两个概念。

      * **Seamless Scale-up (无缝纵向扩展)**：当主节点负载过高，需要给它更多CPU和内存时，如果当前物理机资源不足，就需要把它“搬”到一台更强大的物理机上。这个“搬家”过程要做到**无缝**，即不中断应用服务。这是论文要解决的第一个核心问题。
      * **Read Scale-out (读横向扩展)**：当应用的读取请求非常多时，通过增加更多的“副管理员”（Secondary Nodes）来共同分担读取压力。这是论文要解决的第二个核心问题。

-----

### 4\. 数据一致性 (Data Consistency)

在有主备节点的数据库中，这是一个至关重要的问题。

  * **通俗比喻**：你在社交媒体上发了一张新照片（写操作），然后马上刷新页面去看（读操作）。

      * **强一致性 (Strong Consistency)**：你一刷新，保证能看到刚刚发布的新照片。这是最符合直觉的。
      * **最终一致性 (Eventual Consistency)**：你刷新后，可能看到的还是旧的个人主页，过几秒再刷新才能看到新照片。系统只保证“最终”数据会同步过去。

  * **与论文的关系**：传统共享存储数据库中，只有主节点（Primary）能保证**强一致性**。备用节点（Secondary）因为需要从主节点同步数据日志，存在微小的延迟，所以通常只能提供**最终一致性**。这就导致一个严重问题：如果应用需要强一致性的读取（比如查询刚支付完的订单状态），所有请求都只能发往主节点，无法利用备用节点进行**读扩展 (Read Scale-out)**。PolarDB Serverless 的一个关键创新就是让备用节点也能提供强一致性读，从而真正实现了读能力的横向扩展。

-----

### 5\. 数据库事务与日志 (Transactions & Logs)

这是理解论文中“无缝迁移”技术细节的基础。

  * **事务 (Transaction)**：一系列数据库操作的集合，这些操作要么全部成功，要么全部失败。最经典的例子是银行转账，必须同时完成“账户A扣款”和“账户B收款”，不能只完成一半。

  * **日志 (Logs)**：数据库的“日记本”，用来保证事务的可靠性（即使发生断电、崩溃）。

      * **Redo Log (重做日志)**：记录了数据的“新值”。如果事务提交后数据库崩溃了，重启时可以通过Redo Log恢复数据到最新状态。
      * **Undo Log (撤销日志)**：记录了数据的“旧值”。如果一个事务执行到一半失败了，可以用Undo Log把已经修改的数据恢复到事务开始前的样子。
      * **Binlog (二进制日志)**：MySQL特有的，记录了所有修改数据库的逻辑操作。主要用于数据同步和审计。

  * **与论文的关系**：要实现**无缝迁移**，当一个正在进行中的事务从旧实例“搬”到新实例时，新实例必须知道这个事务已经做了哪些修改。这就要依赖于把旧实例内存中的 **Redo/Undo/Binlog** 等日志信息快速同步到新实例，从而在新实例上“重建”事务的上下文，让事务可以继续执行，对应用程序完全透明。

-----

### 6\. 高性能网络技术 (RDMA)

  * **通俗比喻**：可以理解为两台计算机内存之间的“专线快递”或“传送门”。普通的网络传输需要CPU打包数据，再由网卡发送，接收方CPU再解包，过程繁琐。而RDMA允许一台服务器的网卡直接读写另一台服务器的内存，几乎不需要CPU介入，延迟极低，速度极快。

  * **与论文的关系**：为了让实例迁移过程中的日志同步足够快（达到毫秒级甚至亚毫秒级），PolarDB Serverless 使用 RDMA 技术来传输内存中的日志数据。这是实现“快速无缝迁移”的一个关键工程优化。

-----

### 总结

掌握了以上这些知识点后，你再来阅读这篇论文就会豁然开朗：

> 这篇论文针对**共享存储架构**的**无服务器数据库**，解决了两个业界难题：
>
> 1.  利用**事务日志迁移**和 **RDMA** 等技术，实现了**纵向扩展 (Scale-up)** 时的实例迁移，做到了**无缝**，应用不会中断。
> 2.  通过在备用节点上实现**强一致性**，使得数据库可以在读取压力大时，通过增加备用节点来**横向扩展 (Read Scale-out)**，突破了单主节点的性能瓶颈。
>
> 最终，打造出一个既能按需付费、节约成本，又能提供极致弹性和不中断服务的现代云数据库。
  
## 2 解读论文 
  
好的，这篇论文《Towards a Shared-storage-based Serverless Database Achieving Seamless Scale-up and Read Scale-out》是数据库领域的一项重要研究，它精准地指出了当前主流“无服务器数据库”的痛点，并提出了名为`PolarDB Serverless`的解决方案。

下面我将为您深入解读这篇论文的核心思想与技术细节。

### 论文概述：解决了什么问题？

简单来说，这篇论文解决的是云时代“无服务器数据库”(Serverless Database)面临的两个核心难题：

1.   **“不无缝”的扩容**：当数据库因为负载增加需要更多资源（例如更多CPU或内存）时，如果当前物理机资源不够，就需要“搬家”到一台更强的机器上。这个“搬家”（即实例迁移）过程通常会导致服务中断，让应用程序出错  。
2.   **“无法扩展”的读取**：在数据库中，读取数据需要保证是最新写入的（即“强一致性”）。很多数据库架构中，只有主节点能保证这一点，备用节点的数据有延迟   。这导致所有需要最新数据的读取请求都挤在主节点上，无法通过增加备用节点来分担压力  。

 `PolarDB Serverless` 通过创新的设计，成为了业界第一个同时支持**无缝纵向扩容 (Seamless Scale-up)** 和 **强一致性读横向扩展 (Read Scale-out)** 的共享存储架构无服务器数据库  。

-----

### 核心挑战：当前无服务器数据库的两大“阿喀琉斯之踵”

论文首先深入分析了现有共享存储无服务器数据库（如AWS Aurora Serverless）的两大关键局限。

#### 1\. 扩容时的“中断之痛”：迁移=服务不可用

 无服务器数据库的承诺是根据负载自动伸缩。当负载飙升，数据库需要更多CPU/内存（即Scale-up）时，可能会遇到当前物理机资源耗尽的情况，此时必须将数据库实例迁移到另一台有足够资源的物理机上  。

  * **问题所在**：传统的迁移方式是“先停后启”——停止旧实例，在新机器上启动新实例，然后让应用重新连接。这个过程会造成服务中断   。中断时间可能长达十几秒甚至更久，尤其是在业务高峰期，这会导致大量交易失败，是用户无法接受的  。

  * **论文中的例证**：论文通过模拟迁移测试了某主流商业无服务器数据库。如下图所示，在第30秒触发迁移后，系统吞吐量直接归零，并持续了约15秒才恢复。在此期间，所有应用连接都被断开，交易失败  。

    ```markdown
             ^ 吞吐量 (Throughput)
             |
       40K --|--------------\
             |              |
       30K --|              |
             |              |
       20K --|              |
             |              |-------> 不可用(Unavailable) <-------|
       10K --|              |                                    /------------
             |              |                                   /
         0 --+--------------+----------------------------------+------------> 时间(Time)
                            |  30s                             |  45s
                          迁移开始                            迁移完成
    ```

    *图1: 传统迁移导致的服务中断示意图*

  * **现有规避方式的弊端**：为了避免这种痛苦的迁移，云厂商往往会在一台物理机上预留大量资源，或者限制单个实例的最大规格   。但这违背了Serverless“按需付费”的初衷，导致资源严重浪费，成本最终还是会转嫁给用户或云厂商自己  。

#### 2\. 读能力的“天花板”：备用节点帮不上忙

 云数据库通常采用一主多备的架构，主节点负责读写，备用节点负责分担读请求  。

  *  **问题所在**：由于主节点的数据需要通过日志异步同步给备用节点，备用节点的数据会存在微小延迟   。这意味着备用节点无法保证读取到的是最新数据（即不满足“强一致性”）   。因此，对于银行、电商等需要精确数据的场景，所有读请求都必须发送到唯一的主节点  。
  *  **带来的瓶颈**：当读取压力巨大时，系统无法通过增加备用节点来分担压力（无法Read Scale-out），只能不断给主节点增加资源（Scale-up）  。一旦主节点资源达到物理或产品上限，数据库性能就到达了天花板，无法再提升  。

-----

### 核心方案：PolarDB Serverless如何实现“无缝”与“扩展”

为了解决以上两大痛点，PolarDB Serverless 提出了两项关键创新。

#### 1\. 无缝迁移 (Seamless Migration)：让数据库“瞬间转移”

这是论文最核心的技术贡献。它将原本需要中断服务的迁移过程，变成了一个对应用完全透明、仅有短暂延迟的“无缝”操作。这套机制由**连接保持**和**实时事务迁移**两部分组成。

##### a) 连接保持 (Connection Maintenance)

  *  **核心思想**：在数据库和应用程序之间增加一个智能的**代理层(Proxy)**   。应用程序连接的是Proxy，而不是后端的数据库实例  。

  * **工作流程**：

    1.  **迁移前**：Proxy维持着与应用的连接，并将请求转发给旧的数据库实例。
    2.   **迁移中**：当后端数据库实例开始迁移时，Proxy会“稳住”应用的连接，让它保持“在线”状态，并将收到的新请求暂时缓存起来  。
    3.   **迁移后**：Proxy迅速与新的数据库实例建立连接，然后将缓存的请求和后续新请求无缝地转发到新实例上  。

  * **用户感受**：从应用的角度看，连接从未断开，只是在迁移的瞬间（约半秒）内，某条SQL查询的响应时间变长了而已，不会收到任何错误  。

    ```markdown
                                +------------------+
                                |   应用程序(App)   |
                                +---------+--------+
                                          | (连接始终保持)
                                +---------v--------+
                                |    代理 (Proxy)   |
                                +---------+--------+
                               /           \
                 (迁移中连接断开并切换)    (迁移后建立新连接)
                 /                               \
        +----------------+                +----------------+
        |  旧数据库实例    | --(数据迁移)--> |  新数据库实例    |
        +----------------+                +----------------+
    ```

    *图2: Proxy如何保持连接*

##### b) 实时事务迁移 (Live Transaction Migration)

 这是实现“无缝”的关键，它保证了正在执行中的交易（事务）不会因为迁移而失败  。

  *  **核心思想**：在切换到新实例之前，把旧实例内存中与“未完成事务”相关的所有状态信息，实时、快速地同步到新实例中  。
  * **关键同步内容**：
      *  **Redo/Undo日志**：这些日志记录了事务的所有数据修改。将它们内存中的部分同步到新实例，新实例就能恢复出迁移前的所有数据状态  。
      *  **Binlog缓存**：对于开启了Binlog的用户，内存中的Binlog也需要同步  。
      *  **事务元数据**：如事务ID、锁信息等也需要迁移，以保证事务在新实例上能正确地处理并发和锁定  。
  *  **如何做到“快速”**：这些内存数据的同步是通过**RDMA (Remote Direct Memory Access)** 网络完成的   。RDMA允许服务器之间直接读写内存，绕过了CPU，延迟极低，使得海量内存状态的同步可以在亚秒级内完成  。
  *  **如何做到“精确恢复”**：最巧妙的设计在于，它只需要**回滚并重试最后一个正在执行的查询**   。Proxy会缓存每个连接上最新发送的SQL查询   。迁移完成后，新实例只需根据Proxy提供的信息，精确地撤销（回滚）这个“被打断”的查询所做的修改，然后重新执行一遍即可   。之前已经成功返回结果的查询则不受任何影响  。

#### 2\. 强一致性读扩展 (Read Scale-out)

  *  **核心思想**：这项能力继承自阿里巴巴成熟的PolarDB产品。PolarDB通过创新的日志同步和时间戳管理机制，使得**备用节点也能提供强一致性读**  。
  * **带来的好处**：
      *  **统一访问入口**：PolarDB Serverless可以为用户提供一个统一的数据库地址。无论是读还是写请求，都发到这个地址  。
      *  **智能读写分离**：Proxy会自动将写请求发往主节点，将读请求分发到包括主节点和所有备用节点在内的整个集群，实现负载均衡  。
      *  **真正的读扩展**：当读取压力增大时，系统不再是给主节点扩容，而是**自动增加新的备用节点**来处理读请求   。这极大地提升了系统的读取性能上限，并降低了主节点因为压力过大而需要迁移的概率  。

-----

### 评估结果：效果如何？

论文通过与业界标杆产品的对比，证明了其方案的优越性。

  *  **迁移性能**：在模拟迁移场景下，PolarDB Serverless的迁移仅用了**半秒 (0.5s)**，期间业务吞吐量仅有瞬间抖动，且**没有任何事务失败**   。相比之下，作为基线的Aurora Serverless中断了长达**15秒**，且所有进行中的**16个事务全部被中止**  。

  *  **读扩展能力**：在读取密集型高压测试中，Aurora Serverless的性能在达到其主节点规格上限（128个ACU）后便无法增长，吞吐量稳定在约20万QPS   。而PolarDB Serverless则通过不断横向扩展备用节点，吞吐量飙升至**130万QPS**，是其32核常规版本的2.5倍，充分展示了读扩展的威力  。

  *  **资源动态调整**：测试也表明，PolarDB Serverless能够根据客户端压力的变化，动态、细粒度地分配和回收资源（以PCU为单位），实现了真正的按需使用  。

### 结论

这篇论文不仅仅是介绍了一个名为`PolarDB Serverless`的新产品，更重要的是，它为下一代云原生数据库的设计指明了方向。通过创新的**无缝迁移**和**强一致性读扩展**技术，它解决了现有Serverless数据库在弹性伸缩过程中的核心痛点，使得数据库服务在面对动态、不可预测的负载时，既能保证业务的连续性和稳定性，又能实现资源的极致利用和成本效益，是云原生数据库领域一个重要的里程碑。
  
## 3 术语  
  
我将从论文中提取并解释以下关键术语：

1.  **Serverless Database (无服务器数据库)**
2.  **Shared-storage architecture (共享存储架构)**
3.  **Seamless Migration (无缝迁移)**
4.  **Read Scale-out (读扩展)**
5.  **Primary Node (主节点)**
6.  **Secondary Node (从节点)**
7.  **Strong Consistency (强一致性)**
8.  **Eventual Consistency (最终一致性)**
9.  **Proxy Node (代理节点)**
10. **Redo Log (重做日志)**
11. **Undo Log (撤销日志)**
12. **Binlog (二进制日志)**
13. **PolarDB Serverless (PolarDB 无服务器版)**
14. **PolarDB Capacity Units (PCUs) (PolarDB 容量单位)**

在解释每个术语时，我将结合论文中给出的定义和上下文，力求准确和全面。对于需要图示辅助理解的术语，我将尝试描述或暗示可以使用的图形类型。

现在开始整理这些术语及其解释。以下是论文《Towards a Shared-storage-based Serverless Database Achieving Seamless Scale-up and Read Scale-out》中一些重要的术语及其详细解释：

* **Serverless Database (无服务器数据库)**
     无服务器数据库是一种无需用户管理服务器基础设施的数据库服务模型。它具有高弹性、按需付费（"pay-as-you-go"）的特点，可以根据应用程序不断变化的需求自动细粒度地增长，并管理无法预测或调度的工作负载。用户只需为实际消耗的资源付费，从而显著节省成本  。

* **Shared-storage architecture (共享存储架构)**
     共享存储架构是云原生数据库中常用的一种架构，其特点是计算节点（主节点和从节点）共享一个解耦的云存储层。这种设计保证了数据的容错性和一致性，并且在增加更多从节点时无需额外的存储开销，也无需在迁移数据库实例时进行数据迁移  。
    *图示建议：一个中央共享存储层，上方连接主节点和多个从节点，表示计算和存储分离。*

* **Seamless Migration (无缝迁移)**
     无缝迁移是指在数据库实例扩容（scale-up）时，当当前物理主机资源不足以容纳扩容的数据库实例时，能够将数据库实例无中断地迁移到另一个物理主机上的能力   。PolarDB Serverless通过连接维护和事务迁移策略实现无缝迁移，确保应用程序在迁移过程中连接保持活跃，事务无缝地从旧实例迁移到新实例，对应用程序完全透明，避免了停机时间  。

* **Read Scale-out (读扩展)**
     读扩展是指通过增加辅助节点来处理读取请求，从而提高数据库处理高并发读取工作负载的能力   。在许多共享存储数据库中，从节点由于异步日志传输和日志应用过程可能返回陈旧数据，导致需要强一致性的读取请求必须发送到主节点，限制了从节点的读扩展能力。PolarDB Serverless 通过继承 PolarDB 的强一致性特性，使得从节点能够处理强一致性读取请求，从而支持有效的读扩展  。

* **Primary Node (主节点)**
     在共享存储架构的数据库中，主节点是负责处理所有读写请求的数据库实例。如果当前主节点发生故障，一个从节点可以被提升为新的主节点  。

* **Secondary Node (从节点)**
     在共享存储架构的数据库中，从节点是专门用于处理读取请求的数据库实例。传统上，从节点可能返回陈旧数据，因此只能处理最终一致性的读取请求   。PolarDB Serverless 的从节点支持强一致性读取  。

* **Strong Consistency (强一致性)**
     强一致性是指当一个事务完成更新操作后，后续的任何读取操作都能立即看到这个最新的更新结果。在分布式数据库中，实现强一致性通常对性能有更高的要求   。PolarDB Serverless 实现了从节点上的强一致性读取，这对于支持读扩展至关重要  。

* **Eventual Consistency (最终一致性)**
     最终一致性是指在没有新的更新操作的情况下，最终所有副本的数据都会达到一致状态，但在此之前，读取操作可能会返回旧数据   。许多传统共享存储数据库的从节点只提供最终一致性  。

* **Proxy Node (代理节点)**
     代理节点部署在主节点和从节点之上，用于实现负载均衡、故障转移管理、连接管理、读写分离、访问控制以及查询语句缓存等功能   。在无缝迁移过程中，代理节点负责维护应用程序的连接，并将其重新映射到新的数据库实例，从而使迁移过程对应用程序透明  。
    *图示建议：一个位于应用程序和数据库节点之间的代理层，显示连接和请求流向。*

* **Redo Log (重做日志)**
     重做日志记录了数据库中所有物理数据修改的信息。在 ARIES 风格的日志技术中，每次更新都会生成相应的重做日志。重做日志在数据库崩溃恢复时用于恢复所有未刷新到存储的修改数据，以确保已提交事务的数据能够被恢复  。

* **Undo Log (撤销日志)**
     撤销日志记录了数据修改前的旧值。它主要用于在崩溃恢复后回滚未提交的事务，将数据库恢复到一致状态   。在事务迁移时，撤销日志对于回滚新实例上未完成查询的更改是必需的  。

* **Binlog (二进制日志)**
     二进制日志（binlog）是 MySQL 中的一个重要特性，记录了数据库的所有修改。它用于崩溃恢复和副本同步等多种工作负载。与重做日志和撤销日志不同，binlog 是独立存储的，不依赖于 WAL（Write-Ahead Logging）机制。在现代云原生 MySQL 变体数据库中，尽管 binlog 不再是数据库恢复或从节点同步的必需品，但仍用于数据捕获、审计和分析等功能  。

* **PolarDB Serverless (PolarDB 无服务器版)**
     PolarDB Serverless 是一个基于共享存储的无服务器数据库，旨在实现无缝扩容和读扩展。它是首个同时支持无缝跨机器扩容和读扩展的共享存储无服务器数据库，并且已在阿里云上商用。它通过继承 PolarDB 的强一致性特性，支持从节点处理强一致性读取，并通过连接维护和事务迁移策略实现无缝迁移  。

* **PolarDB Capacity Units (PCUs) (PolarDB 容量单位)**
     PCU 是 PolarDB Serverless 管理资源的单位，一个 PCU 代表 1 vCPU、2GB 内存以及相应的网络和 I/O 硬件资源。PolarDB Serverless 以半个 PCU 的粒度为实例分配和回收资源  。
  
## 参考        
         
http://cighao.com/papers/polardb_serverless.pdf  
        
        
<b> 以上内容基于DeepSeek、Qwen、Gemini及诸多AI生成, 轻微人工调整, 感谢杭州深度求索人工智能、阿里云、Google等公司. </b>        
        
<b> AI 生成的内容请自行辨别正确性, 当然也多了些许踩坑的乐趣, 毕竟冒险是每个男人的天性.  </b>        
    
  
  
  
#### [期望 PostgreSQL|开源PolarDB 增加什么功能?](https://github.com/digoal/blog/issues/76 "269ac3d1c492e938c0191101c7238216")
  
  
#### [PolarDB 开源数据库](https://openpolardb.com/home "57258f76c37864c6e6d23383d05714ea")
  
  
#### [PolarDB 学习图谱](https://www.aliyun.com/database/openpolardb/activity "8642f60e04ed0c814bf9cb9677976bd4")
  
  
#### [PostgreSQL 解决方案集合](../201706/20170601_02.md "40cff096e9ed7122c512b35d8561d9c8")
  
  
#### [德哥 / digoal's Github - 公益是一辈子的事.](https://github.com/digoal/blog/blob/master/README.md "22709685feb7cab07d30f30387f0a9ae")
  
  
#### [About 德哥](https://github.com/digoal/blog/blob/master/me/readme.md "a37735981e7704886ffd590565582dd0")
  
  
![digoal's wechat](../pic/digoal_weixin.jpg "f7ad92eeba24523fd47a6e1a0e691b59")
  
