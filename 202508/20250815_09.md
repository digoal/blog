## Docker 有哪些挂载volume的driver选项, 哪种性能最好?
                                                    
### 作者                                                    
digoal                                                    
                                                    
### 日期                                                    
2025-08-15                                                    
                                                    
### 标签                                                    
PostgreSQL , PolarDB , DuckDB , Docker , 宿主机 , 目录 , 写一致性            
                                                    
----                                                    
                                                    
## 背景   

---

# 一、Docker 有哪些挂载volume的driver选项, 哪种性能最好, 并支持在宿主机内调用DirectIO, 且DirectIO会透传给宿主机执行

你的问题很棒，因为它深入探讨了 Docker 存储的高级性能调优。要找到一个能够满足你所有需求的方案，我们需要分开讨论两个不同的概念： **卷驱动（Volume Drivers）** 和 **存储驱动（Storage Drivers）**。

### 1\. 卷驱动 (Volume Drivers)

`docker volume create` 命令使用的驱动是**卷驱动**。它决定了卷数据在哪里存储。默认且最常用的驱动是 `local`。

  * **`local`**：默认的卷驱动。它将卷数据存储在 Docker 宿主机的文件系统上，通常是在 `/var/lib/docker/volumes/` 目录下。
  * **`local` with options**：你可以通过 `--opt` 选项来定制 `local` 驱动的行为。
      * **`--opt type=none,o=bind,device=/path/to/host`**: 这个组合可以将卷的数据绑定到宿主机上的一个指定目录。这在功能上类似于绑定挂载（bind mount），但管理上更像卷。
  * **第三方驱动**：除了 `local`，还有许多第三方卷驱动，例如用于集群存储的 `NFS`、`GlusterFS`、`Flocker` 等。这些驱动将数据存储在共享网络存储中，以便多个 Docker 主机上的容器都能访问。

### 2\. 存储驱动 (Storage Drivers)

**存储驱动**是 Docker 引擎用来管理镜像和容器**可写层**（writable layer）的机制。它通常由 Docker 在首次启动时自动选择，取决于你宿主机的操作系统和文件系统。常见的存储驱动有 `overlay2` (推荐)、`aufs`、`btrfs`、`zfs` 等。

### Direct I/O 与性能

现在我们来回答你的核心问题：什么选项性能最好，并支持 `directio` 透传？

**在 Linux 宿主机上，`o=directio` 选项是最直接且性能最高的解决方案**。

当你使用以下命令时，你是在告诉 Docker 和底层 Linux 内核：

1.  **挂载类型**：这是一个绑定挂载（`type=bind`）。
2.  **源目录**：宿主机的 `$PWD`。
3.  **目标目录**：容器内的 `/polardb_data`。
4.  **`o=directio`**：这个选项是关键。它强制所有对这个挂载点的 I/O 操作都以 `direct I/O` 模式进行。它会绕过宿主机的文件系统缓存，将数据直接写入物理磁盘。这使得数据在写入后能几乎立即对其他容器可见。

  

```bash
docker run -d -it --mount type=bind,source=$PWD,target=/polardb_data,o=directio ...
```

**性能最好**的方案通常是：**在 Linux 宿主机上使用 `overlay2` 存储驱动，并为需要高性能 I/O 的特定目录使用绑定挂载，并加上 `o=directio` 选项。**

`overlay2` 存储驱动本身在镜像和容器层管理上非常高效，但它与 `directio` 没有直接关系。**`directio` 的性能优势体现在绕过缓存，减少了 I/O 延迟**。对于数据库、大数据或高性能计算等对数据同步和 I/O 延迟有严格要求的应用来说，`directio` 是一个非常重要的优化选项。

**总结**

| 方案类型 | 命令示例 | 优点 | 缺点 |
| :--- | :--- | :--- | :--- |
| **绑定挂载 + `directio`** | `--mount type=bind,source=$PWD,target=...,o=directio` | **性能最好**，确保数据立即透传，适用于 Linux 宿主机 | 不兼容 macOS/Windows，可能增加 CPU 负载和磁盘磨损 |
| **具名卷 + `local` 驱动** | `docker volume create my_vol`，然后 `-v my_vol:/data` | Docker 官方推荐，易于管理和备份，平台无关 | 无法直接启用 `directio`，不保证数据即时同步 |
| **具名卷 + `local` + `bind`** | `docker volume create --opt type=none...` | 结合了绑定挂载和卷的优点，数据存储路径可控 | 语法复杂，在非 Linux 平台上无法透传 `directio` 等高级选项 |

请注意，`o=directio` 选项只在 Linux 宿主机上有效。在 macOS 和 Windows 上，由于 Docker 是在一个轻量级 Linux 虚拟机中运行的，这个选项将无法工作，就像你在问题中遇到的错误一样。
   
---

# 二、为什么volume比直接映射目录给容器性能好?

这个错误提示 `$ docker run` 命令中的 `--mount` 标志无法识别 `o=directio` 选项。这通常发生在 **Docker for Mac/Windows** 环境下。

## 原因分析
这个错误不是语法问题，而是 Docker 在 macOS 或 Windows 上运行时，**不完全支持 Linux 文件系统的所有挂载选项**。

Docker for Mac/Windows 内部是通过一个**Linux 虚拟机**来运行容器的。当你使用 `--mount type=bind,source=...,target=...` 挂载宿主机目录时，Docker 并不是直接在 Linux 容器中执行 `mount` 命令，而是通过一个**文件共享层**（如 VirtioFS 或 gRPC-FUSE）来将 macOS/Windows 文件系统映射到 Linux 虚拟机中。

`o=directio` 是一个特定于 **Linux 文件系统** 的挂载选项，用于控制内核的 I/O 行为。这个选项无法被 Docker 的文件共享层直接透传给底层的 macOS 或 Windows 文件系统。因此，Docker 引擎在解析 `--mount` 标志时，会发现这个选项是“不被预期的”（`unexpected key 'o' in 'o=directio'`），从而导致命令执行失败。

## 解决方案
### 1. **在 Linux 宿主机上运行**
如果你需要 `directio` 这样的高级挂载选项来确保 I/O 性能和数据一致性，最可靠的方法是**在原生的 Linux 宿主机上运行 Docker**。在 Linux 上，`docker run` 命令能够正确地将 `--mount` 选项中的 `o=directio` 传递给内核，从而启用 Direct I/O。

### 2. **使用 Docker Compose**
对于复杂的服务部署，使用 **Docker Compose** 是更好的选择。你可以在 `docker-compose.yml` 文件中定义卷和挂载，但同样需要注意，`directio` 选项在非 Linux 环境下依然不被支持。

### 3. **如果必须在 macOS 上运行**
如果你无法切换到 Linux 环境，并且需要解决 I/O 性能问题，可以尝试以下方法：
* **使用更高效的文件共享技术**：确保你的 Docker for Mac 使用了最新的文件共享后端，如 **VirtioFS**。它通常比旧的 gRPC-FUSE 性能更好。你可以在 Docker Desktop 的设置中进行检查和配置。
* **数据持久化到容器内部**：将需要高性能 I/O 的数据存储在 Docker 卷（`docker volume create`）中，而不是直接挂载宿主机的目录。Docker 卷通常具有更好的 I/O 性能，因为它是在 Linux 虚拟机内部创建的。
* **应用层面的优化**：在 PostgreSQL 或 PolarDB-PG 的配置中，调整缓冲区大小 (`shared_buffers`) 或其他 I/O 相关的参数，来优化性能。


---

# 三、docker volume create 例子

好的，这里是一些 `docker volume create` 命令的例子，以及如何在容器中使用这些卷。

-----

### 1\. 创建一个具名卷（Named Volume）

这是最常见的创建卷的方式，Docker 会在宿主机上自动创建一个目录来存储数据，并为其分配一个唯一的名字。

```bash
docker volume create my_app_data
```

**如何使用**

在运行容器时，使用 `-v` 或 `--mount` 标志将这个具名卷挂载到容器中。

```bash
docker run -d \
  --name my_container \
  -v my_app_data:/data \
  nginx
```

  * `my_app_data`: 你在第一步创建的卷名。
  * `/data`: 容器内部的挂载点。

-----

### 2\. 创建一个带标签的具名卷

你可以给卷添加标签（Labels），这在组织和管理大量卷时非常有用。

```bash
docker volume create \
  --label env=production \
  --label service=database \
  prod_db_data
```

**如何使用**

使用方法和普通具名卷一样。

```bash
docker run -d \
  --name my_db \
  -v prod_db_data:/var/lib/postgresql/data \
  postgres
```

-----

### 3\. 创建一个使用特定驱动的卷

Docker 支持使用不同的卷驱动来创建卷，比如 NFS 或 GlusterFS，以便在集群中共享数据。

首先，你需要安装一个卷驱动，比如 `local-persist`：

```bash
docker plugin install --grant-all-permissions cpuguy83/docker-volume-local-persist
```

然后，你可以使用该驱动创建一个卷：

```bash
docker volume create \
  --driver local-persist \
  -o mountpoint=/var/lib/docker/volumes/my-local-persist-volume \
  my_local_volume
```

  * `--driver local-persist`: 指定卷驱动为 `local-persist`。
  * `-o mountpoint`: 指定卷数据在宿主机上实际存放的位置。

**如何使用**

同样使用 `-v` 标志将它挂载到容器中。

```bash
docker run -d \
  --name my_app \
  -v my_local_volume:/app/data \
  my_image
```

-----

### 4\. 检查和管理卷

一旦卷被创建，你可以使用以下命令来管理它们：

  * **查看所有卷**：

    ```bash
    docker volume ls
    ```

  * **查看卷的详细信息**：

    ```bash
    docker volume inspect my_app_data
    ```

  * **删除卷**：

    ```bash
    docker volume rm my_app_data
    ```

  * **删除所有未使用的卷**：

    ```bash
    docker volume prune
    ```

---

# 四、如何将volumn创建到指定目录中?

虽然 **`docker volume create`** 命令本身没有直接的选项来指定卷的存储路径，但你可以通过使用 **`local` 驱动**的特定选项来实现这个目的。

Docker 默认将卷创建在 `/var/lib/docker/volumes/` 目录下，并以卷名作为子目录。要改变这个行为，你需要使用 `--opt` 标志来传递额外的参数给 `local` 卷驱动。

-----

### 使用 `local` 驱动和 `bind` 选项

这个方法允许你创建一个具名卷，但它的实际数据会绑定到宿主机上的一个指定目录。这在功能上类似于绑定挂载（bind mount），但它仍然被 Docker 视为一个卷，你可以像管理其他卷一样管理它。

下面是这个命令的语法：

```bash
docker volume create <volume-name> \
  --driver local \
  --opt type=none \
  --opt o=bind \
  --opt device=<path-to-your-directory>
```

**命令解释**

  * `docker volume create <volume-name>`：创建一个名为 `<volume-name>` 的卷。
  * `--driver local`：明确指定使用 `local` 驱动，这是 Docker 的默认卷驱动。
  * `--opt type=none`：这是一个必需的选项，用于告诉 `local` 驱动不要创建任何文件系统。
  * `--opt o=bind`：告诉 `local` 驱动使用 **绑定挂载**（bind mount）的语义。
  * `--opt device=<path-to-your-directory>`：这是最关键的选项，它指定了卷数据在宿主机上实际存放的目录路径。

**重要提示**：在执行这个命令之前，请确保 `<path-to-your-directory>` 目录已经存在。

-----

### 例子

假设你想创建一个名为 `my-app-data` 的卷，并让它的数据存放在宿主机上的 `/home/user/my_docker_volumes/app_data` 目录。

1.  **首先，在宿主机上创建目录**：

    ```bash
    mkdir -p /home/user/my_docker_volumes/app_data
    ```

2.  **然后，创建卷**：

    ```bash
    docker volume create my-app-data \
      --driver local \
      --opt type=none \
      --opt o=bind \
      --opt device=/home/user/my_docker_volumes/app_data
    ```

3.  **使用卷**：
    现在，你可以在 `docker run` 命令中像使用任何其他具名卷一样使用它。

    ```bash
    docker run -d \
      --name my_app \
      -v my-app-data:/data \
      nginx
    ```

### 总结

这种方法提供了一个混合了卷和绑定挂载优点的解决方案：

  * 它使用了一个具名卷，这使得在 Docker CLI 和 Compose 文件中更易于管理。
  * 它将数据存储在你指定的宿主机路径，这方便了数据备份和外部访问。
    
#### [期望 PostgreSQL|开源PolarDB 增加什么功能?](https://github.com/digoal/blog/issues/76 "269ac3d1c492e938c0191101c7238216")
  
  
#### [PolarDB 开源数据库](https://openpolardb.com/home "57258f76c37864c6e6d23383d05714ea")
  
  
#### [PolarDB 学习图谱](https://www.aliyun.com/database/openpolardb/activity "8642f60e04ed0c814bf9cb9677976bd4")
  
  
#### [PostgreSQL 解决方案集合](../201706/20170601_02.md "40cff096e9ed7122c512b35d8561d9c8")
  
  
#### [德哥 / digoal's Github - 公益是一辈子的事.](https://github.com/digoal/blog/blob/master/README.md "22709685feb7cab07d30f30387f0a9ae")
  
  
#### [About 德哥](https://github.com/digoal/blog/blob/master/me/readme.md "a37735981e7704886ffd590565582dd0")
  
  
![digoal's wechat](../pic/digoal_weixin.jpg "f7ad92eeba24523fd47a6e1a0e691b59")
  
