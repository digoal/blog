  
## PostgreSQL 19 preview - pg_buffercache 插件优化, 增加中断信号处理逻辑  
                                              
### 作者                                              
digoal                                              
                                              
### 日期                                              
2025-08-25                                              
                                              
### 标签                                              
PostgreSQL , PolarDB , DuckDB , pg_buffercache , 长时间执行代码 , 中断信号处理逻辑 , CHECK_FOR_INTERRUPTS   
                                              
----                                              
                                              
## 背景       
不知道你有没有遇到过这样的情况?  
  
有些PG数据库会话在执行长时间任务, 出于某种原因你想杀掉它, 但是怎么杀也杀不掉! 不管你是pg_cancel_backend 还是 pg_terminate_backend !   
  
原因是进程不响应用户中断信号, 详细的分析见下列文章.  
  
[《PostgreSQL 无法kill(`pg_terminate_backend`, `pg_cancel_backend`)的情况分析 - 进程hang strace,pstack》](../201807/20180720_02.md)    
  
[《每天5分钟,PG聊通透 - 系列1 - 热门问题 - 链接、驱动、SQL - 第7期 - 为什么有的SQL使用`pg_cancel_backend, pg_terminate_backend`都杀不掉?》](../202112/20211220_07.md)    
  
[《PostgreSQL 哪些状态不可中断 - 杀不掉的QUERY和会话》](../201803/20180311_03.md)    
  
在 pg_buffercache 插件代码中可能也存在一些长时间执行的代码, 以往这些代码内不含检测或处理用户中断的逻辑, 可能会带来如上同样的问题.  
  
PostgreSQL 19 在 pg_buffercache 插件相应代码中加入了处理用户中断的逻辑.  
  
该 commit（ https://github.com/postgres/postgres/commit/eab9e4e27c0c433dbfe09914e69c875dda2af63f ）由 Masahiko Sawada 合并，主要内容为：在 contrib/pg_buffercache 扩展的多个函数中向遍历共享缓冲区的循环中添加了 CHECK_FOR_INTERRUPTS 宏。这样做的目的是让这些长时间运行的操作在执行过程中能够被中断（例如被取消查询或终止进程），提升了可控性和用户体验。该更改被回溯支持到所有受支持的 PostgreSQL 版本，并在 16 及以上版本的 `pg_buffercache_summary()`、`pg_buffercache_usage_counts()` 也做了相应补充。  
  
CHECK_FOR_INTERRUPTS 在 PostgreSQL 代码中的作用：  
  
1. 宏定义与作用  
- CHECK_FOR_INTERRUPTS() 是一个宏（定义在 src/include/miscadmin.h），其作用是在执行期间的安全位置检查是否有中断信号（如 QueryCancel/SIGINT 或 ProcDie/SIGTERM）到达。  
- 其实现是：如果检测到有中断信号挂起，则调用 ProcessInterrupts() 处理这些信号，可能会导致当前事务被中断并抛出异常终止当前查询。  
  
2. 典型用法与设计  
- PostgreSQL 在长循环、批量处理、I/O 等可能耗时很久、用户可能希望中断的地方，都会定期插入 CHECK_FOR_INTERRUPTS()。  
- 这样可以避免后台任务、查询或管理命令“卡死”在无法中断的状态，提升数据库的响应性和健壮性。  
- 某些情况下，子函数也会调用 CHECK_FOR_INTERRUPTS()，但如果当前上下文不允许中断（如关键区段、持有锁时），则可用 HOLD_INTERRUPTS()/RESUME_INTERRUPTS() 暂时屏蔽中断。  
  
3. 案例分析  
- 例如，排序（qsort_interruptible.c）、索引构建、统计信息收集、并发写入等场景下，大多会插入 CHECK_FOR_INTERRUPTS()，以便及时响应用户的取消请求。  
- 在本次 commit 涉及的 pg_buffercache 相关函数中，主要是遍历共享缓冲池，若数据量大耗时长，定期插入 CHECK_FOR_INTERRUPTS() 能显著提升可管理性。  
  
4. 相关代码（miscadmin.h 摘要）：  
```c  
#define CHECK_FOR_INTERRUPTS() \  
do { \  
	if (INTERRUPTS_PENDING_CONDITION()) \  
		ProcessInterrupts(); \  
} while(0)  
```  
信号到达后会设置标志位，CHECK_FOR_INTERRUPTS() 负责在合适位置检测并处理。  
  
总结：CHECK_FOR_INTERRUPTS 是 PostgreSQL 响应用户中断请求的核心机制之一，广泛用于长时间运行的循环和操作中，确保数据库能在合适时机安全地响应取消或终止命令。此次 commit 使 pg_buffercache 的相关函数也具备了这种可中断能力。  
  
    
#### [期望 PostgreSQL|开源PolarDB 增加什么功能?](https://github.com/digoal/blog/issues/76 "269ac3d1c492e938c0191101c7238216")
  
  
#### [PolarDB 开源数据库](https://openpolardb.com/home "57258f76c37864c6e6d23383d05714ea")
  
  
#### [PolarDB 学习图谱](https://www.aliyun.com/database/openpolardb/activity "8642f60e04ed0c814bf9cb9677976bd4")
  
  
#### [PostgreSQL 解决方案集合](../201706/20170601_02.md "40cff096e9ed7122c512b35d8561d9c8")
  
  
#### [德哥 / digoal's Github - 公益是一辈子的事.](https://github.com/digoal/blog/blob/master/README.md "22709685feb7cab07d30f30387f0a9ae")
  
  
#### [About 德哥](https://github.com/digoal/blog/blob/master/me/readme.md "a37735981e7704886ffd590565582dd0")
  
  
![digoal's wechat](../pic/digoal_weixin.jpg "f7ad92eeba24523fd47a6e1a0e691b59")
  
