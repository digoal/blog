## PostgreSQL 19 preview - 优化OOM处理逻辑(libpq 在 OOM 时的行为改动)  
                                                
### 作者                                                
digoal                                                
                                                
### 日期                                                
2025-08-25                                                
                                                
### 标签                                                
PostgreSQL , PolarDB , DuckDB , libpq , OOM , 异常捕获 , 原因定位 , 显化问题      
                                                
----                                                
                                                
## 背景       
  
1) Patch 概述（高层）  
- 目标组件：libpq（PostgreSQL 客户端库）。  
- 目的：在发生内存分配失败（OOM）时改进处理策略 — 对一些特殊消息处理路径（那些不属于某个具体 query 的消息）不再尝试“继续工作/沉默忽略/返回 EOF 让调用方卡住”，而选择断开连接（terminate the connection）并以更清晰的错误信息暴露问题。此外，精简并改进了输入缓冲区扩展失败时的错误信息（移除多余的 “lost synchronization” 报告）。  
- 回溯支持：该改动回补（backpatch）到 v18 系列。  
  
2) Patch 之前：libpq 在 OOM 时的行为（关键点）  
- 对于与特定查询相关的内存分配失败：常规做法是把错误信息附在连接对象上（connection），在后续的 PQgetResult()（或等价接口）被调用时上报错误——也就是说错误“延迟”报告给调用查询结果的地方。  
- 对于“非 query 关联”的消息（几个典型情形）处理不一致且不良：  
  - async notification（NOTIFY/监听相关消息，getNotify() 处理）：  
    - 遇到内存分配失败时，代码有时返回 EOF（让处理循环以为连接暂时没有更多数据），导致进一步数据处理停滞；如果后续永远没有更多数据到来（比如应用只是阻塞等待通知，或 ReadyForQuery 已经在 buffer 中但后续处理卡住），会导致“挂起/死等”。  
    - 也有情况是“静默丢弃”该通知（即丢掉通知，不告知应用），造成通知丢失，行为是隐蔽的并且难以排查。  
  - BackendKeyData 消息（新在 v18 引入的场景）：OOM 时 getBackendKeyData() 返回 EOF，同样会出现卡住问题。  
  - ParameterStatus 消息：OOM 时跳过保存该参数状态（不保存到连接结构），导致应用层调用 PQparameterStatus() 得到 NULL——看起来像服务器没发送该参数，但实际上发送了，只是被 libpq 跳过了。  
- 输入缓冲扩展失败时的错误信息：会报出 “cannot allocate memory for input buffer” 之后又输出 “lost synchronization with server: got message type ...”，后者在多数情况下多余且误导。  
  
总体问题：当 libpq 在处理这些非查询消息时遇 OOM，会导致两类糟糕后果——  
- （A）静默丢失数据（通知/参数），导致难以察觉的逻辑错误；  
- （B）返回 EOF/停止处理，导致应用可能“卡住”或死等（尤其是等待通知的长连接场景）。  
  
3) Patch 之后：libpq 在 OOM 时的行为改动（具体差异）  
- 在上述那些非 query 关联的消息处理路径（getNotify、getBackendKeyData、保存 ParameterStatus 等）遇到内存分配失败时，不再尝试返回 EOF 或静默跳过，而是选择终止连接（terminate the connection）。  
  - 终止连接意味着：连接会被认为已失效，应用层会通过 libpq 的错误/状态（或后续的读写失败）观察到连接已断开，能够触发重连或错误处理逻辑。  
- 对输入缓冲扩展失败的错误报告做了调整：删除了“lost synchronization with server”那条多余的消息，改为单一、清晰的 “cannot allocate memory for input buffer” 报错。理由是“lost synchronization”在大多数场景并不成立，输出它容易误导排查方向。  
- 这样做的结果是：对于 OOM，libpq 更倾向于 fail-fast（直接失败并让上层知道），而不是继续在不确定/不完整的状态下运行或沉默丢弃。  
  
4) 为什么这样改（设计动机）  
- 应用通常能更好地处理连接丢失（连接失败、重连、告警、回滚等），而难以检测并安全处理“偷偷丢掉的通知”或“静默不返回的参数状态”这类隐蔽错误。  
- 返回 EOF 并导致处理卡住（例如等待通知的阻塞）比明确断开更糟糕：卡住可能永远无法恢复，需要人工干预；断开会让上层有机会重连或报错并采取补救措施。  
- 精简错误信息可以减少误导，帮助开发者/运维更快定位真正原因（内存分配失败），而不是不必要地怀疑 protocol sync 问题。  
  
5) Patch 带来的好处（总结）  
- 更可观测的失败：出现 OOM 时会尽快把错误暴露为连接错误，而不是悄悄丢失消息或让处理停滞。  
- 更易于调试和恢复：应用可以依赖标准的连接错误处理路径（重连、告警），从而更确定地采取恢复措施。  
- 减少潜在的隐蔽数据损失：NOTIFY 或 ParameterStatus 的“静默丢弃”会导致难以察觉的逻辑错误，此改动避免了这种隐蔽丢失（以牺牲连接可用性为代价，但这是更安全的选择）。  
- 更清晰的错误信息：输入缓冲扩展失败时只报告真实原因，避免误导性的“lost synchronization”提示。  
  
6) 可能的副作用与注意事项  
- 应用层需要对“连接突然中断”做好处理（通常这是必须的最佳实践：网络/数据库连接都应有重试策略和幂等处理），因为 OOM 情况下客户端连接将被中断，而不是保持半正常状态。  
- 在极端内存紧张环境下，频繁短时间断开/重连可能造成更高的负载。应用应该采用指数退避等重连策略。  
- 对于那些设计上期望长期“等待通知”且没有实现断线重连的简陋客户端，这次改动可能暴露为行为变化（以前可能会“卡着”，现在会收到断开并需重连）。  
  
7) 实际影响场景举例  
- 场景 A：长连接仅用于 LISTEN/NOTIFY。  
    - 旧行为：如果 libpq 在处理到来的通知时 OOM，有可能返回 EOF 并停滞，客户端会永远阻塞等待（看似仍然连接，但不处理后续消息）。  
    - 新行为：连接会断开，客户端会收到错误并可重连来恢复监听，从而不会陷入不可恢复的停滞。  
- 场景 B：客户端依赖 PQparameterStatus() 获得服务器参数（比如 server_version、client_encoding 等）。  
    - 旧行为：如果在接收时跳过该状态，后续查询 PQparameterStatus() 返回 NULL，导致客户端以为服务器没有发送该信息。  
    - 新行为：连接会断开，客户端可以察觉异常并避免基于不完整参数继续运行。  
- 场景 C：收到了 BackendKeyData（用于取消等操作），若 OOM 被跳过或返回 EOF，后续取消请求可能无法正确处理。新行为：通过断开连接使问题显式化。  
  
8) 推荐的应用/运维层应对措施  
- 保证客户端库（libpq）调用路径具备连接错误重试和幂等性处理。大部分成熟驱动（libpq wrapper）已经有重连/错误传递策略，但仍需确认行为符合预期。  
- 对关键长期监听进程，添加断线重连和告警：如果连接断开，记录并重连（带退避），同时 alert 运维团队。  
- 在资源受限环境（容器、内存限制严格）中监控客户端进程内存使用，避免频繁 OOM。  
- 日志策略：当看到 “cannot allocate memory for input buffer” 或类似 OOM 报错时，把它当作真正需要关注的问题，而不是网络协议错乱。  
  
       
#### [期望 PostgreSQL|开源PolarDB 增加什么功能?](https://github.com/digoal/blog/issues/76 "269ac3d1c492e938c0191101c7238216")
  
  
#### [PolarDB 开源数据库](https://openpolardb.com/home "57258f76c37864c6e6d23383d05714ea")
  
  
#### [PolarDB 学习图谱](https://www.aliyun.com/database/openpolardb/activity "8642f60e04ed0c814bf9cb9677976bd4")
  
  
#### [PostgreSQL 解决方案集合](../201706/20170601_02.md "40cff096e9ed7122c512b35d8561d9c8")
  
  
#### [德哥 / digoal's Github - 公益是一辈子的事.](https://github.com/digoal/blog/blob/master/README.md "22709685feb7cab07d30f30387f0a9ae")
  
  
#### [About 德哥](https://github.com/digoal/blog/blob/master/me/readme.md "a37735981e7704886ffd590565582dd0")
  
  
![digoal's wechat](../pic/digoal_weixin.jpg "f7ad92eeba24523fd47a6e1a0e691b59")
  
