## VectorChord新版本发布: 支持图(DiskANN和HNSW)索引、召回率评估  
            
### 作者            
digoal            
            
### 日期            
2025-08-25            
            
### 标签            
PostgreSQL , PolarDB , DuckDB , 图 , hnsw , diskann , vectorchord , pgvector , 向量       
            
----            
            
## 背景      
VectorChord 更新了, 这次更新迎来了2个大特性:  
- 基于图(DiskANN和HNSW)的索引, 索引可超越内存大小  
- 内置召回率评估函数  
  
如果你还不太了解VectorChord, 也可以先翻一翻我之前写的文章  
- [《VectorChord 向量插件学习心得》](../202505/20250513_01.md)    
- [《向量插件新贵 VectorChord(IVF+ RaBitQ量化), pgvector 和 milvus 都被秒杀了》](../202504/20250427_02.md)    
  
或者直接看其开源项目或文档  
- https://github.com/tensorchord/VectorChord  
- https://docs.vectorchord.ai/vectorchord/usage/graph-index.html  
- https://deepwiki.com/tensorchord/VectorChord  
  
以及一些图索引相关的论文和原理介绍文章  
- [《数据库筑基课 - 向量索引之 HNSW》](../202506/20250624_03.md)    
- [《pgvector hnsw高频更新场景的坑》](../202505/20250507_01.md)    
- [《AI论文解读 | Efficient and robust approximate nearest neighbor search using Hierarchical Navigable Small World graphs》](../202506/20250619_02.md)    
- [《AI论文解读 | Filtered − DiskANN: Graph Algorithms for Approximate Nearest Neighbor Search with Filters》](../202507/20250702_01.md)    
- [《AI论文解读 | FreshDiskANN: A Fast and Accurate Graph-Based ANN Index for Streaming Similarity Search》](../202507/20250701_01.md)    
- [《AI论文解读 | DiskANN: Fast Accurate Billion-point Nearest Neighbor Search on a Single Node》](../202505/20250514_03.md)    
- [《pgvectorscale: pgvector diskann 向量索引扩展与优化》](../202406/20240613_01.md)    
- [《TimescaleDB 发布基于DiskANN的增强向量索引》](../202309/20230928_01.md)    
- [《一种新的向量检索索引 DiskANN: Fast Accurate Billion-point Nearest Neighbor Search on a Single Node》](../202107/20210729_03.md)    
  
本文来看看 VectorChord 基于图(DiskANN和HNSW)的索引与pgvector有什么不一样?   
  
内置召回率评估函数如何使用?   
  
## 一、VectorChord graph index for vector type  
VectorChord 的索引类型`vchordg`是基于磁盘的图索引，内存消耗较低。  
  
创建一个名为`items`的索引, `embedding`的列类型为`vector(n)`。  
  
要创建`vchordg`索引，可以使用以下 SQL。  
```  
CREATE INDEX ON items USING vchordg (embedding vector_l2_ops);  
```  
  
注意: vchordg索引功能目前处于预览阶段。  
  
### 调优  
建立索引时，通常需要调整两个选项：`m`和`ef_construction`。`m`是每个顶点的最大邻居数，`ef_construction`是插入数据期间顶点包含最近邻居的动态列表的大小(通常比`m`大, 随着插入过程更新这个动态列表, 以构建更好的图.)。  
  
在搜索(query)时，您需要调整`ef_search`。`ef_search`是搜索期间包含最近邻居的动态列表的大小。  
  
```  
CREATE INDEX ON items USING vchordg (embedding vector_l2_ops) WITH (options = $$  
m = 64  
ef_construction = 128  
$$);  
  
SET vchordg.ef_search TO '128';  
SELECT * FROM items ORDER BY embedding <-> '[3,1,2]' LIMIT 10;  
```  
  
作为基于磁盘的索引，`vchordg`通常只需要将量化向量保留在buffer池中即可保持性能。默认情况下，vchordg量化D维向量为2D位。设行数为N。那么，索引所需的总内存为2DN位。如果你的内存非常有限，并且正在使用超高维向量，可以考虑将向量量化为D位。那么，索引所需的总内存为DN位。  
```  
CREATE INDEX ON items USING vchordg (embedding vector_l2_ops) WITH (options = $$  
bits = 1  
m = 64  
ef_construction = 128  
$$);  
```  
  
可以使用多个进程来加速索引构建。请参阅调优( https://docs.vectorchord.ai/vectorchord/usage/performance-tuning.html#indexing )。  
  
### 参考  
#### 操作符类(ops)  
  
下表列出了vchordg所支持的所有可用运算符类。  
  
运算符类	| 描述	| op 1	| op 2  
---|---|---|---  
`vector_l2_ops`	|索引适用于`vector`类型和欧几里得距离	|`<->(vector,vector)`	|`<<->>(vector,vector)`  
`vector_ip_ops`	|索引适用于`vector`类型和负内积	(negative inner product)|`<#>(vector,vector)`	|`<<#>>(vector,vector)`  
`vector_cosine_ops`	|索引适用于`vector`类型和余弦距离	|`<=>(vector,vector)`	|`<<=>>(vector,vector)`  
`halfvec_l2_ops`	|索引适用于`halfvec`类型和欧几里得距离	|`<->(halfvec,halfvec)`	|`<<->>(halfvec,halfvec)`  
`halfvec_ip_ops`	|索引适用于`halfvec`类型和负内积	|`<#>(halfvec,halfvec)`	|`<<#>>(halfvec,halfvec)`  
`halfvec_cosine_ops`	|索引适用于`halfvec`类型和余弦距离	|`<=>(halfvec,halfvec)`	|`<<=>>(halfvec,halfvec)`  
  
`<<->>`，`<<#>>`，`<<=>>`是`VectorChord`插件定义的运算符。  
  
有关`<<->>`、`<<#>>`、`<<=>>`的更多信息，请参阅( https://docs.vectorchord.ai/vectorchord/usage/range-query.html )。  
  
  
#### 索引选项  
`bits`   
- 描述：`RaBitQ`量化后的比特与维度的比率。`bits = 2`提供更好的召回率，`bits = 1`消耗更少的内存, 提供更高的QPS。  
- 类型：整数  
- 默认：2  
- 例子：  
    - `bits = 2`意味着D维向量量化为2D位(bit)。  
    - `bits = 1`意味着D维向量量化为D位(bit)。  
  
`m`  
- 描述：每个顶点的最大邻居数。m值越大，召回率越好，但存储需求也越高。  
- 类型：整数  
- 默认：32  
- 例子：  
    - m = 32意味着每个顶点的邻居最多有32个。  
    - m = 64意味着每个顶点的邻居最多有64个。  
  
`ef_construction`  
- 描述：插入过程中包含最近邻居的动态列表的大小。ef_construction值越大，召回率越好，但插入速度越慢。  
- 类型：整数  
- 默认：64  
- 例子：  
    - ef_construction = 64意味着插入过程中包含最近邻居的动态列表的大小是64。  
    - ef_construction = 128意味着插入过程中包含最近邻居的动态列表的大小是128。  
  
`alpha`  
- 描述：alpha是剪枝期间选择的值。此选项必须是一个升序列表，其中第一个元素为1.0，最后一个元素小于2.0。  
- 类型：浮点数列表  
- 默认：`[1.0, 1.2]`  
- 例子：  
    - `alpha = [1.0, 1.2]`相当于在DiskANN中设置`alpha = 1.2`。  
    - `alpha = [1.0]`相当于HNSW中的默认剪枝策略。  
- 注意：当距离度量为负内积(negative inner product)时此选项无效。  
  
`beam_construction`  
- 描述：插入期间使用的束宽度。束宽度指的是一次访问的顶点数量。由于从 SSD 随机读取少量扇区的时间与读取单个扇区的时间几乎相同，因此较大的束宽度可以有效减少往返 SSD 的次数，从而提高性能。<b>由于这会增加计算量，因此对于已完全加载到内存中的索引而言是不利的。</b>   
- 类型：整数  
- 默认：1  
- 例子：  
    - `beam_construction = 8`表示索引在插入时一次访问 8 个顶点。  
    - `beam_construction = 1`表示索引在插入过程中一次访问 1 个顶点。  
  
  
#### 搜索参数  
`vchordg.ef_search`  
- 描述：搜索时最近邻居的动态列表的大小。`vchordg.ef_search`值越大，召回率越高，但 QPS 越低。  
- 类型：整数  
- 默认：64  
- 领域：`[1, 65535]`  
- 例子：  
    - `SET vchordg.ef_search = 64`表示在搜索过程中包含最近邻居的动态列表的大小是64  
    - `SET vchordg.ef_search = 128`表示在搜索过程中包含最近邻居的动态列表的大小是128  
  
`vchordg.beam_search`  
- 描述：搜索过程中使用的束宽度。束宽度指的是一次访问的顶点数量。由于从 SSD 随机读取少量扇区的时间与读取单个扇区的时间几乎相同，因此较大的束宽度可以有效减少往返 SSD 的次数，从而提高性能。<b>由于这会增加计算量，因此对于已完全加载到内存中的索引而言是不利的。</b>   
- 类型：整数  
- 默认：1  
- 领域：`[1, 65535]`  
- 例子：  
    - `SET vchordg.beam_search = 8`表示索引在搜索时一次访问 8 个顶点。  
    - `SET vchordg.beam_search = 1`表示索引在搜索时一次访问 1 个顶点。  
  
## 二、内置召回率评估函数  
  
在向量搜索的语境中，召回率是指索引返回的`真实最近邻`与`近似最近邻`的比率。例如，如果索引检索到`100`个近似最近邻, 其中`97个`是真正的最近邻，那么召回率就是`97/100`。  
  
召回率衡量的是相关结果占搜索结果总数的比例。使用索引时，您可能希望了解不同参数对应的召回率和每秒查询次数 (QPS)。函数`vchordrq_evaluate_query_recall`旨在评估召回率。它接收一个返回行标识符的查询，并返回相应的召回率。  
```  
SET vchordrq.probes = '100';  
SET vchordrq.epsilon = 1.0;  
SELECT vchordrq_evaluate_query_recall(query => $$  
  SELECT ctid FROM items ORDER BY embedding <-> '[3,1,2]' LIMIT 10);  
$$);  
```  
  
默认情况下，该函数通过使用索引扫描生成估计的 `ground truth` 来评估召回率。如果您想通过 `table seq scan` 生成 `ground truth` 来评估召回率，请将函数`exact_search`参数设置为`true`。  
```  
SET vchordrq.probes = '100';  
SET vchordrq.epsilon = 1.0;  
SELECT vchordrq_evaluate_query_recall(query => $$  
  SELECT ctid FROM items ORDER BY embedding <-> '[3,1,2]' LIMIT 10  
$$, exact_search => true);  
```  
  
### 参考  
`vchordg` 索引暂时不支持此功能。  
  
`vchordrq` 索引 `vchordrq_evaluate_query_recall` 函数说明  
- 描述：评估给定`vchordrq`索引扫描查询的召回率。  
- 结果：real  
- 参数：  
    - `query: text`，评估召回率的query  
    - `exact_search: boolean`，使用真实情况而不是估计的真实情况  
    - `accu_probes: text`，`vchordrq.probes` 的估计真实值  
    - `accu_epsilon: real`，`vchordrq.epsilon` 的估计真实值  
- 例子：  
    - `SELECT vchordrq_evaluate_query_recall(query => $$ SELECT ctid FROM t ORDER BY val <-> '[0.5, 0.25, 1.0]' LIMIT 10 $$);`  
    - `SELECT vchordrq_evaluate_query_recall(query => $$ SELECT ctid FROM t ORDER BY val <-> '[0.5, 0.25, 1.0]' LIMIT 10 $$, exact_search => true);`  
    - `SELECT vchordrq_evaluate_query_recall(query => $$ SELECT ctid FROM t ORDER BY val <-> '[0.5, 0.25, 1.0]' LIMIT 10 $$, accu_probes => '9999', accu_epsilon => 4.0);`  
  
---    
  
# 补充 1     
<b> `vchordg` 索引中 `alpha` 选项的作用和设计原理。    </b>  
    
## Alpha 选项的作用    
    
`alpha` 参数是 `vchordg` 索引中用于邻居选择的关键参数，它控制图构建过程中的剪枝策略。   该参数定义为一个浮点数数组，默认值为 `[1.0, 1.2]`。      
    
### 参数约束    
    
`alpha` 参数有严格的验证规则：      
- 必须按升序排列    
- 所有值必须在 1.0 到 2.0 之间    
- 第一个值必须是 1.0    
- 数组长度限制在 1-8 个元素    
    
## 设计原理    
    
### 鲁棒剪枝算法    
    
`alpha` 参数在鲁棒剪枝算法（robust pruning）中发挥核心作用。   该算法通过多轮剪枝来选择最优的邻居节点：    
    
1. **多轮剪枝策略**：对于 L2 距离/余弦距离，算法会遍历 `alpha` 数组中的每个值进行剪枝；对于其他距离类型，只使用 `alpha = 1.0`。      
    
2. **邻居质量控制**：在每轮剪枝中，算法检查候选邻居与已选邻居的距离关系，只有当 `dis_u < alpha * dis_v` 时才接受该邻居。      
    
### 在图构建中的应用    
    
`alpha` 参数在以下场景中被使用：    
    
1. **插入操作**：新向量插入时，使用 `alpha` 参数选择最佳邻居。      
    
2. **维护操作**：图维护过程中重新选择邻居时也使用该参数。      
    
### 距离类型限制    
    
值得注意的是，非 1.0 的 `alpha` 值仅适用于 L2 和余弦距离。   对于其他距离类型，系统会发出警告并仅使用 `alpha = 1.0`。    
    
## Notes    
    
`alpha` 参数的设计基于 HNSW 算法的鲁棒剪枝策略，通过控制邻居选择的严格程度来平衡图的连通性和搜索质量。较大的 `alpha` 值会选择更多样化的邻居，而较小的值则倾向于选择距离更近的邻居。默认的 `[1.0, 1.2]` 配置提供了一个良好的平衡点。    
    
    
    
---    
    
# 补充 2    
    
<b> `vchordrq_evaluate_query_recall` 函数中 `ctid` 的作用以及 `exact_search` 参数的算法差别。    </b>  
    
## ctid 的作用    
    
`ctid` 是 PostgreSQL 中的行标识符（tuple identifier），用于唯一标识表中的每一行。   在召回率评估中，`ctid` 起到关键的比较基准作用：    
    
### 作为唯一标识符进行结果比较    
    
函数通过执行查询并收集返回的 `ctid` 数组来比较不同搜索策略的结果。   具体流程是：    
    
1. **收集粗略搜索结果**：首先执行原始查询，将结果的 `ctid` 收集到 `rough` 数组中    
2. **收集精确搜索结果**：然后执行高精度或精确搜索，将结果的 `ctid` 收集到 `accu` 数组中      
3. **计算交集**：通过比较两个 `ctid` 数组的交集来计算召回率      
    
### 为什么必须返回 ctid    
    
测试用例显示，如果查询返回的不是 `ctid` 而是其他列（如 `val` 或 `*`），会导致类型转换错误。   这是因为函数内部专门设计为处理 `tid[]` 类型的数组。    
    
## exact_search 参数的算法差别    
    
`exact_search` 参数控制是否使用`精确搜索(全表扫描)`作为基准真值（ground truth）：    
    
### exact_search = false（默认）    
    
当设置为 `false` 时，函数使用`高精度的近似搜索`作为基准：      
    
- **保存原始探测设置**：记录当前的 `vchordrq.probes` 设置    
- **自动调整探测参数**：将探测数设置为最大值 `65535` 以获得最高精度    
- **调整 epsilon 参数**：使用传入的 `accu_epsilon`（默认1.9）进行重排序    
- **移除扫描限制**：设置 `max_scan_tuples = -1` 移除扫描元组数量限制    
    
### exact_search = true    
    
当设置为 `true` 时，函数完全禁用索引扫描，强制使用顺序扫描：      
    
- **禁用索引扫描**：通过 `SET LOCAL vchordrq.enable_scan = off` 强制使用精确的顺序扫描    
- **获得真正的精确结果**：这提供了理论上的最佳结果作为召回率计算的基准    
    
### 实际测试验证    
    
测试用例验证了两种模式都能正常工作，并且在简单数据集上都能达到 100% 的召回率。      
    
## Notes    
    
`ctid` 作为 PostgreSQL 的物理行标识符，提供了一个稳定且唯一的比较基准，使得召回率评估能够准确比较不同搜索策略返回的具体行。`exact_search` 参数的设计允许用户在计算成本和精确度之间做出权衡：使用 `false` 可以快速获得高质量的近似基准，而使用 `true` 则提供理论上的最佳精确基准。    
    
    
---    
    
# 补充 3    
    
<b> `vchordrq_evaluate_query_recall` 函数中"收集精确搜索结果"这一步骤的详细实现过程。   </b>    
    
## 精确搜索结果收集的详细流程    
    
在 `vchordrq_evaluate_query_recall` 函数中，"收集精确搜索结果"是指函数执行第二次查询来获取高精度或精确的搜索结果作为基准真值（ground truth）。      
    
### 两种精确搜索模式    
    
根据 `exact_search` 参数的设置，函数采用不同的策略：    
    
#### 1. exact_search = true：完全精确搜索    
    
当 `exact_search` 为 `true` 时，函数强制禁用索引扫描：      
    
- **禁用索引扫描**：`SET LOCAL vchordrq.enable_scan = off` 强制 PostgreSQL 使用顺序扫描而不是向量索引    
- **获得理论最优结果**：这确保了搜索结果是真正的精确结果，没有任何近似误差    
    
#### 2. exact_search = false：高精度近似搜索    
    
当 `exact_search` 为 `false` 时，函数通过调整多个参数来获得高精度的近似结果：      
    
**参数调整策略：**    
    
1. **探测数设置**：根据原始 `probes` 设置自动调整    
   - 如果原始 `probes` 为空，保持为空    
   - 如果包含逗号（多个值），设置为 `'65535,65535'`    
   - 否则设置为 `'65535'`（最大探测数）    
    
2. **重排序参数**：设置 `vchordrq.epsilon` 为传入的 `accu_epsilon`（默认1.9）    
    
3. **扫描限制移除**：`SET LOCAL vchordrq.max_scan_tuples = -1` 移除扫描元组数量限制    
    
### 查询执行和结果收集    
    
无论采用哪种模式，函数都会执行相同的查询收集逻辑：      
    
```sql    
EXECUTE format('SELECT coalesce(array_agg(id), array[]::tid[]) FROM (%s) AS result(id)', query)    
INTO accu;    
```    
    
这里的关键点是：    
- 查询必须返回 `ctid` 类型的结果    
- 使用 `array_agg()` 将所有结果收集到 `tid[]` 数组中    
- 如果没有结果，返回空的 `tid[]` 数组    
    
### 测试验证    
    
测试用例验证了两种模式的正确性：      
    
- 第一个测试使用默认的高精度近似搜索（`exact_search=false`）    
- 第二个测试使用完全精确搜索（`exact_search=true`）    
- 两种模式在简单数据集上都能达到 100% 的召回率    
    
## Notes    
    
"收集精确搜索结果"这一步骤的核心是通过调整 PostgreSQL 的查询执行策略来获得尽可能准确的基准结果。`exact_search=false` 模式通过最大化索引参数来获得高质量的近似结果，而 `exact_search=true` 模式则完全绕过索引使用暴力搜索来获得理论最优结果。这种设计允许用户在计算成本和精确度之间做出权衡。    
    
---  
  
# 补充 4  
<b> VectorChord 中 `vchordrq.epsilon` 参数的详细说明。  </b>   
  
## `vchordrq.epsilon` 参数概述  
  
`vchordrq.epsilon` 是 VectorChord 的 `vchordrq` 索引方法中的一个关键配置参数，用于控制搜索精度与速度之间的权衡。    
  
## 参数定义和默认值  
  
该参数在 Rust 代码中定义为浮点数类型，默认值为 1.9：    
  
参数的取值范围被限制在 0.0 到 4.0 之间：    
  
## 参数作用机制  
  
`epsilon` 参数在搜索算法中用于计算下界（lowerbound），影响 RaBitQ 量化搜索的精度。在搜索过程中，它被用来调整误差容忍度：    
  
具体计算公式为：`lowerbound = Distance::from_f32(rough - err * epsilon)`，<b> 其中 `epsilon` 值越大，搜索范围越宽，召回率越高但速度越慢。</b>     
  
## 使用方式  
  
### PostgreSQL 配置  
您可以通过 PostgreSQL 的 GUC 系统设置该参数：  
```sql  
SET vchordrq.epsilon = 1.5;  
```  
  
### 基准测试中的使用  
在性能基准测试脚本中，`epsilon` 参数可以通过命令行参数指定：    
  
然后在数据库连接中应用：    
  
### 召回率评估中的应用  
在 `vchordrq_evaluate_query_recall` 函数中，`epsilon` 参数用于控制准确性评估时的搜索精度，默认值同样为 1.9：    
  
## Notes  
  
`epsilon` 参数是 VectorChord 特有的优化参数，专门用于 `vchordrq` 索引(rq量化ivfflat索引)方法。它不适用于 `vchordg` 索引(图索引)方法。该参数的调优需要根据具体的数据集和查询需求在精度和性能之间找到平衡点。较小的 `epsilon` 值会提供更快的搜索速度但可能降低召回率，而较大的值则相反。  
  
## 参考  
https://docs.vectorchord.ai/vectorchord/usage/graph-index.html  
  
https://docs.vectorchord.ai/vectorchord/usage/measure-recall.html  
  
      
#### [期望 PostgreSQL|开源PolarDB 增加什么功能?](https://github.com/digoal/blog/issues/76 "269ac3d1c492e938c0191101c7238216")
  
  
#### [PolarDB 开源数据库](https://openpolardb.com/home "57258f76c37864c6e6d23383d05714ea")
  
  
#### [PolarDB 学习图谱](https://www.aliyun.com/database/openpolardb/activity "8642f60e04ed0c814bf9cb9677976bd4")
  
  
#### [PostgreSQL 解决方案集合](../201706/20170601_02.md "40cff096e9ed7122c512b35d8561d9c8")
  
  
#### [德哥 / digoal's Github - 公益是一辈子的事.](https://github.com/digoal/blog/blob/master/README.md "22709685feb7cab07d30f30387f0a9ae")
  
  
#### [About 德哥](https://github.com/digoal/blog/blob/master/me/readme.md "a37735981e7704886ffd590565582dd0")
  
  
![digoal's wechat](../pic/digoal_weixin.jpg "f7ad92eeba24523fd47a6e1a0e691b59")
  
