## PostgreSQL 超强代理 pgdog : “分片/负载均衡/连接池”应有尽有  
          
### 作者          
digoal          
          
### 日期          
2025-09-05         
          
### 标签          
PostgreSQL , PolarDB , DuckDB , sharding , load balance , connection pool , pgdog        
          
----          
          
## 背景    
提起PostgreSQL连接池, 你第一时间是不是想到了 pgbouncer?  
  
提起PostgreSQL读写分离, 第一时间想到的是不是 pgpool-II?  
  
提起shared nothing, 第一时间想到的是不是 citus?   
  
可是每一个都不太完美, 例如pgbouncer虽然效率高, 但是单进程的. pgpool-II虽然支持读写分离, 但是本身的效率一般. citus呢虽然支持sharding但是它需要安装插件, 对除了微软云以外的其他RDS云服务不友好!  
  
有没有一款软件支持"分片/负载均衡/连接池"所有功能, 而且又稳定又强大? 还不受制于插件呢?  
  
有了, 他就是pgdog.  
  
https://github.com/pgdogdev/pgdog  
  
## pgdog 简介  
pgdog 功能非常强大, 以下简单介绍其中几个重要功能, 更多请参考其文档.  
  
1、负载均衡  
  
PgDog 是 PostgreSQL 的一个应用层（OSI 7 级）PG 负载均衡器。它能够理解 Postgres wire protocol 协议，可以代理多个副本（以及主数据库），并在数据库之间均匀分配事务。它支持多种策略，例如“RR、随机和最少活跃连接”。PgDog 还可以检查query并将`SELECT`发送到副本(如果select里有用户自定义函数, 并且函数中有DML/DDL时需注意验证, 个人估计没有pgpool-II那种白名单模式, 也太复杂了.)，将所有其他query发送到主数据库。这允许在一个 PgDog 部署中代理所有数据库。  
  
![pic](20250905_08_pic_001.png)  
  
https://docs.pgdog.dev/features/load-balancer/  
  
2、只读节点健康检查及自动切换负载  
  
PgDog 维护着一个实时的健康主机列表。当数据库未通过健康检查时，它会被从活跃轮换中移除，query也会被重新路由到其他副本。它的工作原理类似于 HTTP 负载均衡器，只不过它是为你的数据库设计的。  
  
故障转移可最大限度地提高数据库可用性，并防止网络连接不良、硬件临时故障或配置错误。  
  
注意, 由于很多产品primary都有HA机制, 所以pgdog不对primary进行故障转移切换, 只是不停尝试.   
  
健康检查和故障自动切换负载仅发生在多个replica节点之间.  
  
![pic](20250905_08_pic_002.png)  
  
https://docs.pgdog.dev/features/load-balancer/healthchecks/  
  
3、连接池  
  
与 PgBouncer 一样，PgDog 支持事务（和会话）模式连接池，使用事务模式时允许数十万个客户端仅使用几个 PostgreSQL 服务器连接。  
  
![pic](20250905_08_pic_003.png)  
  
https://docs.pgdog.dev/features/transaction-mode/  
  
4、sharding 技术  
  
PgDog 能够处理具有多个分片的数据库，方法是将查询自动路由到一个或多个分片。使用原生 PostgreSQL 解析器，PgDog 可以理解查询、提取分片键并确定最佳路由策略。对于跨分片查询，PgDog 会在内存中组装和转换结果，并将它们全部发送到客户端，就像它们来自单个数据库一样。  
  
https://docs.pgdog.dev/features/sharding/  
  
5、copy 协议支持  
  
PgDog 附带文本/CSV 解析器，可以自动将COPY命令拆分到所有分片中。这使得客户端无需预处理即可将数据导入到分片的 PostgreSQL 中。  
  
![pic](20250905_08_pic_004.png)  
  
https://docs.pgdog.dev/features/sharding/copy/  
  
5、重分片技术  
  
PgDog 理解 PostgreSQL 逻辑复制协议，可以在后台在数据库之间拆分数据，且无需停机。这允许对现有数据库进行分片，并在生产环境中向现有集群添加更多分片，而不会影响数据库操作。  
  
https://docs.pgdog.dev/features/sharding/resharding/  
  
  
## 本地运行 PgDog  
编译  
```  
git clone --depth 1 https://github.com/pgdogdev/pgdog  
cd pgdog  
cargo build --release  
```  
  
配置  
PgDog 有两个配置文件：  
- `pgdog.toml` 包含常规设置和 PostgreSQL 服务器信息  
- `users.toml` 包含用户和密码  
  
大多数选项都有合理的默认值，因此在同一台机器上运行的单个用户和数据库的基本配置非常短：  
  
pgdog.toml  
```  
[[databases]]  
name = "pgdog"  
host = "127.0.0.1"  
```  
  
users.toml  
```  
[[users]]  
name = "pgdog"  
password = "pgdog"  
database = "pgdog"  
```  
  
如果您想尝试一下，可以进行如下设置：  
```  
CREATE DATABASE pgdog;  
CREATE USER pgdog PASSWORD 'pgdog' LOGIN;  
```  
  
尝试分片功能  
  
分片数据库集群在配置中设置。例如，要设置一个 2 分片集群，您可以：  
  
pgdog.toml  
```  
[[databases]]  
name = "pgdog_sharded"  
host = "127.0.0.1"  
database_name = "shard_0"  
shard = 0  
  
[[databases]]  
name = "pgdog_sharded"  
host = "127.0.0.1"  
database_name = "shard_1"  
shard = 1  
```  
  
不要忘记指定用户配置：  
  
users.toml  
```  
[[users]]  
database = "pgdog_sharded"  
name = "pgdog"  
password = "pgdog"  
```  
  
最后，为了使其在本地工作，请创建所需的数据库：  
```  
CREATE DATABASE shard_0;  
CREATE DATABASE shard_1;  
  
GRANT ALL ON DATABASE shard_0 TO pgdog;  
GRANT ALL ON DATABASE shard_1 TO pgdog;  
```  
  
启动 PgDog  
  
可以使用 Cargo 运行 PgDog：  
```  
cargo run --release  
```  
  
命令行选项  
  
PgDog 支持多个命令行选项：  
- `-c, --config <CONFIG>`：配置文件的路径（默认值`"pgdog.toml"`：）  
- `-u, --users <USERS>`：users.toml 文件的路径（默认值`"users.toml"`：）  
- `-d, --database_url <DATABASE_URL>`：连接 URL。可以多次指定以添加多个数据库连接。提供这些 URL 后，它们会覆盖配置文件中的数据库配置。  
  
直接使用数据库 URL 的示例：  
```  
cargo run --release -- -d postgres://user:pass@localhost:5432/db1 -d postgres://user:pass@localhost:5433/db2  
```  
  
您可以使用psql或任何其他 PostgreSQL 客户端连接到 PgDog ：  
```  
psql "postgres://pgdog:pgdog@127.0.0.1:6432/pgdog?gssencmode=disable"  
```  
    
## benchmark  
  
PgDog 尽力将其对数据库性能的影响降至最低。在客户端和服务器之间传递数据时，我们会格外小心，确保执行的操作尽可能少。  
  
以下列出的所有基准测试均在我的本地系统（AMD Ryzen 7 5800X）上进行。实际性能会受到网络速度、查询复杂度等因素的影响，尤其是运行 PgDog 和 PostgreSQL 服务器的硬件。  
  
pgbench  
  
测试 PostgreSQL 性能最简单的方法是使用pgbench。它是所有 PostgreSQL 安装（Mac 和 Linux）的标准配置：  
```  
$ pgbench --version  
pgbench (PostgreSQL) 16.4 (Postgres.app)  
```  
  
标准的 pgBench 基准测试将运行INSERT、UPDATE、DELETE和SELECT，以全面了解数据库性能。由于我们只测试 PgDog 的性能，因此我们将SELECT仅运行查询，并尽量减少硬盘 I/O 对此测试的影响。  
  
可以通过将`-S`参数传递给pgbench来重现此基准测试。以下结果是使用 `pgdog.toml` 中的配置执行的。  
  
结果如下  
  
1、多线程模式  
  
下面的数字是事务模式下的单个数据库基准。workers设置为4，因此 PgDog 正在运行 4 个线程并使用异步 I/O。  
  
协议  
  
协议列指示 pgbench 使用哪种通信协议与 PgDog/Postgres 通信。  
  
simple协议 发送查询，其参数包含在查询文本中。这要求 Postgres 仅接收一条消息，但在 PgDog 内部会产生解析开销。  
  
extended协议 将参数与查询文本分离。这可以防止 SQL 注入攻击，但 PgDog 能够删除重复语句并减少大部分解析开销。  
  
prepared协议 是最快的，因为 pgbench 重用了相同的语句，并且只发送了不同的参数。这样就无需在 PgDog 和 Postgres 内部解析语句。  
  
Protocol	|Clients	|TPS	|Latency  
---|---|---|---  
simple	|1	|10,790.06	|0.093 ms  
simple	|10	|70,661.18	|0.137 ms  
simple	|100	|78,232.15	|1.266 ms  
extended	|1	|11,634.29	|0.086 ms  
extended	|10	|74,529.28	|0.128 ms  
extended	|100	|94,584.0	|1.045 ms  
prepared	|1	|17,468.19	|0.057 ms  
prepared	|10	|110,942.87	|0.084 ms  
prepared	|100	|119,273.2	|0.825 ms  
  
  
2、单线程  
  
该基准测试运行时workers设置为 0。这使得 PgDog 以单线程模式运行，但仍使用异步 I/O。  
  
Protocol	| Clients	| TPS	| Latency  
---|---|---|---  
simple	|1	|11,042.68	|0.090 ms  
simple	|10	|30,209.56	|0.331 ms  
simple	|100	|28,931.41	|3.349 ms  
extended	|1	|11,702.49	|0.085 ms  
extended	|10	|49,920.91	|0.200 ms  
extended	|100	|47,108.79	|2.075 ms  
prepared	|1	|18,222.30	|0.055 ms  
prepared	|10	|53,468.63	|0.187 ms  
prepared	|100	|50,441.38	|1.943 ms  
  
3、解释  
  
（1 个客户端）的基准测试`-c 1`是衡量最佳情况下性能的良好基准。不存在资源争用，PgDog 能够有效地在一个套接字中接收数据，并将其推送到另一个套接字。  
  
当有 10 个客户端主动查询数据库时，连接池已满负荷（`default_pool_size`设置为`10`）。当没有客户端等待连接时，连接池必须全力为客户端提供服务，系统不能有任何空闲。  
  
由于连接的客户端数量超过可用服务器数量的 10 倍，连接资源竞争异常激烈，PgDog 必须确保所有连接都能获得公平的服务。此基准测试中稳定的吞吐量证明了我们能够有效地分时共享服务器连接。  
  
解析器开销  
  
PgDog 会解析语句以确定它们的去向。使用`simple协议`时，PgDog 无法缓存语句（因为它们包含参数），因此解析器的开销非常明显。使用extended和prepared协议时，缓存可以正常工作，解析器的开销几乎完全消除。  
  
在现实世界中  
  
在生产环境中，PostgreSQL 客户端通常处于空闲状态。例如，Web 应用程序会花费大量时间解析 HTTP 请求、运行代码并等待网络 I/O。这为 PgDog（和 PostgreSQL）提供了充足的时间来处理数千个客户端的查询。  
  
硬件影响  
  
基准测试结果会因硬件而异。例如，这些数字在新款 Apple M 芯片上会更好，而在老款 Intel CPU 上则会更慢。此基准测试是在 AMD Ryzen 7 5800X 上运行的。您的测试结果可能会有所不同，但总体趋势大致相同。  
  
pgbench配置  
```  
export PGPASSWORD=pgdog  
  
pgbench -P 1 -h 127.0.0.1 -p 6432 \  
    -U pgdog pgdog -c 10 -t 100000 -S \  
    --protocol prepared  
``` 

## 8.28 新闻: pgdog 支持插件开发了
现在，您可以将自己的逻辑直接注入 PgDog 的查询路由器，从而更改其分片和负载平衡算法。
   
PgDog 拥有强大的插件系统，允许您自定义查询路由行为。插件使用 Rust 编写，编译成共享库，并在运行时加载。更多参考文末开发文档.  
  
## 参考  
https://docs.pgdog.dev/  
  
https://github.com/pgdogdev/pgdog  
  
https://docs.pgdog.dev/architecture/benchmarks/  
   
https://pgdog.dev/blog/plugins-are-back  
   
https://docs.rs/pgdog-plugin  
  
https://docs.pgdog.dev/features/plugins/    
  
#### [期望 PostgreSQL|开源PolarDB 增加什么功能?](https://github.com/digoal/blog/issues/76 "269ac3d1c492e938c0191101c7238216")
  
  
#### [PolarDB 开源数据库](https://openpolardb.com/home "57258f76c37864c6e6d23383d05714ea")
  
  
#### [PolarDB 学习图谱](https://www.aliyun.com/database/openpolardb/activity "8642f60e04ed0c814bf9cb9677976bd4")
  
  
#### [PostgreSQL 解决方案集合](../201706/20170601_02.md "40cff096e9ed7122c512b35d8561d9c8")
  
  
#### [德哥 / digoal's Github - 公益是一辈子的事.](https://github.com/digoal/blog/blob/master/README.md "22709685feb7cab07d30f30387f0a9ae")
  
  
#### [About 德哥](https://github.com/digoal/blog/blob/master/me/readme.md "a37735981e7704886ffd590565582dd0")
  
  
![digoal's wechat](../pic/digoal_weixin.jpg "f7ad92eeba24523fd47a6e1a0e691b59")
  
