## 幻读和不可重复读的区别  
          
### 作者          
digoal          
          
### 日期          
2025-10-01         
          
### 标签          
PostgreSQL , PolarDB , DuckDB , MVCC , 隔离级别 , RR , 不可重复读 , 幻读 , MySQL , 并发性 , 锁 , 快照          
          
----          
          
## 背景  
本文介绍一下幻读和不可重复读的区别, 同时对比MySQL和PG在解决幻读方面的具体实现机制.   
- 一、幻读和不可重复读的概念区别  
- 二、PostgreSQL 如何在RR隔离级别模式下解决幻读  
- 三、MySQL 如何在RR隔离级别模式下解决幻读  
- 四、对比MySQL和PostgreSQL解决幻读的本质区别  
  
# 一、幻读和不可重复读的概念区别  
幻读（Phantom Read）和不可重复读（Non-repeatable Read）是数据库事务隔离级别中讨论的两种**并发问题**。它们都与事务在读取数据时，其他事务同时修改数据而引发的数据不一致有关，但它们影响的数据范围和表现形式有所不同。  
  
---  
  
## 不可重复读 (Non-repeatable Read)  
  
**定义：**  
在一个事务内，两次或多次查询**同一条数据记录**，发现该记录的**值不同**。这是因为在第一次查询之后、第二次查询之前，**另一个事务**修改了这条记录并提交了。  
  
**关注点：** **修改**（UPDATE）和**单条记录的值**。  
  
**例子：**  
  
1.  **事务 A** 开始，查询 ID 为 10 的用户余额，结果是 **500 元**。  
2.  **事务 B** 开始，将 ID 为 10 的用户余额修改为 **1000 元**，并**提交**。  
3.  **事务 A** 再次查询 ID 为 10 的用户余额，结果变成了 **1000 元**。  
    * **结果：** 事务 A 在两次读取同一条记录时，得到了不一致的结果。  
  
---  
  
## 幻读 (Phantom Read)  
  
**定义：**  
在一个事务内，两次执行**同一个范围查询**（例如：`WHERE condition`），发现第二次查询的结果集里**多了一些或少了一些记录**。这是因为在第一次查询之后、第二次查询之前，**另一个事务**插入（INSERT）或删除了（DELETE）符合查询条件的记录，并提交了。  
  
**关注点：** **新增/删除**（INSERT/DELETE）和**多条记录的集合**（记录的数量）。  
  
**例子：**  
  
1.  **事务 A** 开始，查询年龄大于 30 的员工数量，结果是 **50 人**。  
2.  **事务 B** 开始，**插入**了 5 个年龄为 40 岁的新员工，并**提交**。  
3.  **事务 A** 再次查询年龄大于 30 的员工数量，结果变成了 **55 人**。  
    * **结果：** 事务 A 在两次执行相同的查询时，查询到的记录**数量**不同，就像出现了“幻影”一样。  
  
---  
  
## 总结和核心区别  
  
| 特性 | 不可重复读 (Non-repeatable Read) | 幻读 (Phantom Read) |  
| :--- | :--- | :--- |  
| **关注的变化** | **值**被修改 (UPDATE) | **数量/集合**发生变化 (INSERT/DELETE) |  
| **对象** | **同一条**已经存在的数据记录 | 符合查询条件的**多条**数据记录（集合） |  
| **隔离级别** | **读已提交 (Read Committed)** 级别下可能出现 | **可重复读 (Repeatable Read)** 级别下仍可能出现 (取决于数据库实现，如 MySQL 的默认设置解决了幻读) |  
  
简单来说：  
  
* **不可重复读**：记录还在，但**内容变了**（UPDATE）。  
* **幻读**：记录的**数量变了**（INSERT 或 DELETE），像看到了“新出现”或“消失”的记录。  
  
在标准的 SQL 隔离级别中，**可重复读 (Repeatable Read)** 级别可以防止**不可重复读**，但**不一定**能防止**幻读**。而最高的隔离级别——**串行化 (Serializable)** 可以解决这两种并发问题。不过，很多数据库（如 **MySQL** 默认的 `Repeatable Read` 级别）通过使用 **Next-Key Locks** 或其他机制，实际上也解决了幻读问题。  
  
# 二、PostgreSQL 如何在RR隔离级别模式下解决幻读  
PostgreSQL 的 **MVCC (Multi-Version Concurrency Control)** 机制在 **可重复读 (Repeatable Read, RR)** 隔离级别下之所以能够同时解决**不可重复读**和**幻读**问题，关键在于其对 **事务快照（Transaction Snapshot）** 的严格和一致性使用。  
  
---  
  
## 核心机制：事务快照 (Transaction Snapshot)  
  
在 PostgreSQL 的 RR 模式下，一个事务（称之为 $T_A$）启动时，会生成一个**事务快照**。这个快照记录了系统中所有已提交的、未提交的、以及正在进行的事务的状态。  
  
1.  **快照的时间点：** 这个快照是在 $T_A$ **第一次执行数据修改语句**（`SELECT`, `INSERT`, `UPDATE`, `DELETE`）时创建的。  
2.  **快照的可见性规则：** 在 $T_A$ 整个生命周期内，它所能看到的数据版本都必须符合这个快照的规则：  
    * 只能看到在快照创建时**已经提交**的数据版本。  
    * **忽略**所有在快照创建后才提交的事务所做的任何更改。  
  
正是这个“**快照隔离**”的特性，使得 RR 模式在 PostgreSQL 中比 SQL 标准所定义的 RR 级别更强大，从而解决了不可重复读和幻读。  
  
---  
  
## 解决不可重复读 (Non-Repeatable Read)  
  
**不可重复读**关注的是**同一条记录的值**被另一个事务修改。  
  
| 步骤 | 事务 A (RR 模式) | 事务 B (修改并提交) | 结果 |  
| :--- | :--- | :--- | :--- |  
| **1.** | 启动，并执行第一次 `SELECT` (快照 $S_A$ 生成) | | **事务 A** 看到记录 V1 版本。|  
| **2.** | | `UPDATE` 记录，将其修改为 V2 版本，并 **提交**。 | **事务 A** 的快照 $S_A$ 已经生成。|  
| **3.** | 执行第二次 `SELECT` 同一条记录 | | **事务 A** 仍然只能看到快照 $S_A$ 允许它看到的 **V1 版本**。|  
  
**结论：** 即使事务 B 已经修改并提交了数据，事务 A 由于持有旧的快照 $S_A$，会**忽略**事务 B 的更改，从而**重复读取**到相同的值，解决了不可重复读。  
  
---  
  
## 解决幻读 (Phantom Read)  
  
**幻读**关注的是**符合条件的记录集合**被另一个事务新增或删除。  
  
| 步骤 | 事务 A (RR 模式) | 事务 B (插入/删除并提交) | 结果 |  
| :--- | :--- | :--- | :--- |  
| **1.** | 启动，并执行第一次范围 `SELECT` (快照 $S_A$ 生成) | | **事务 A** 看到 10 条记录。|  
| **2.** | | `INSERT` 5 条新记录（或 `DELETE` 5 条记录），并 **提交**。 | **事务 A** 的快照 $S_A$ 已经生成。|  
| **3.** | 执行第二次范围 `SELECT` 相同的条件 | | **事务 A** 仍然只能看到快照 $S_A$ 允许它看到的 **那 10 条记录**。|  
  
**结论：** 事务 B 插入或删除的新记录，其**事务 ID** 是在快照 $S_A$ 生成**之后**才提交的。根据 MVCC 的可见性规则，事务 A 在进行范围查询时会**自动过滤掉**这些“太新”的版本，因此两次查询到的记录集合**数量保持一致**，解决了幻读。  
  
## 与 SQL 标准的区别  
  
SQL 标准定义的 `Repeatable Read` 级别，通常只要求**锁住**你读取的**数据行**以防止修改，但对新的**插入行**（即幻读）并没有要求必须阻止。  
  
**PostgreSQL** 的 MVCC 实现是基于**快照隔离 (Snapshot Isolation)** 的，它保证了事务开始后看到的数据集合是**完全一致**的，包括行值和行数，这是一种更强的隔离，因此能够同时解决不可重复读和幻读。  
  
# 三、MySQL 如何在RR隔离级别模式下解决幻读  
  
好的，MySQL 默认的事务隔离级别是 **可重复读 (Repeatable Read, RR)**。与标准的 SQL 规范不同，**MySQL 的 RR 级别能够有效防止幻读**。它主要通过其独特的 **锁机制**，特别是 **Next-Key Locks**（临键锁），来实现这一目标。  
  
---  
  
## 1. Next-Key Locks（临键锁）机制概述  
  
MySQL 的 **InnoDB 存储引擎**在 RR 隔离级别下，执行范围查询（例如 `SELECT ... WHERE age > 20`）时，并不会只使用简单的行锁，而是使用一种结合了 **行锁 (Record Lock)** 和 **间隙锁 (Gap Lock)** 的复合锁：**Next-Key Lock**。  
  
$$\text{Next-Key Lock} = \text{Record Lock (行锁)} + \text{Gap Lock (间隙锁)}$$  
  
* **行锁 (Record Lock):** 锁住实际存在的索引记录。  
* **间隙锁 (Gap Lock):** 锁住索引记录之间的**间隙**，以及第一个记录之前的间隙或最后一个记录之后的间隙。它锁住的是一个**范围**，而不是具体的记录。  
  
**Next-Key Lock** 锁定的范围是从**当前记录**（不含）到**下一条记录**（含）的一个**左开右闭区间** $(A, B]$。  
  
## 2. Next-Key Locks 如何解决幻读  
  
幻读发生在当一个事务 $T_A$ 两次执行范围查询时，另一个事务 $T_B$ 在该范围中**插入**或**删除**了新行并提交。Next-Key Locks 的作用就是防止 $T_B$ 在 $T_A$ 查询的**间隙**中进行插入或删除操作。  
  
我们以一个包含 `ID` 索引的表 `T` 为例，其中已有的记录 ID 值为 10, 20, 30。  
  
| 索引间隙 | Next-Key Lock 锁定的范围 |  
| :--- | :--- |  
| $\text{(负无穷, 10]}$ | 第一个间隙和记录 10 |  
| $\text{(10, 20]}$ | 间隙和记录 20 |  
| $\text{(20, 30]}$ | 间隙和记录 30 |  
| $\text{(30, 正无穷)}$ | 最后一个间隙（注意：最后一个间隙通常只用间隙锁） |  
  
### 幻读场景示例（使用 `SELECT FOR UPDATE` 或 `SELECT FOR SHARE`）  
  
假设事务 $T_A$ 想要查询并锁定所有 ID 在 $(10, 30]$ 之间的记录，以确保没有人在其中添加新员工。  
  
**步骤：**  
  
| 步骤 | 事务 A (RR 模式) | 事务 B (插入操作) | 结果 |  
| :--- | :--- | :--- | :--- |  
| **1.** | `BEGIN;` | | |  
| **2.** | `SELECT * FROM T WHERE ID > 10 AND ID <= 30 FOR UPDATE;` | | **事务 A** 获得了两个 Next-Key Locks：**$\text{(10, 20]}$** 和 **$\text{(20, 30]}$**。|  
| **3.** | | `INSERT INTO T (ID) VALUES (25);` | **事务 B 阻塞！** 尝试插入 ID=25 的记录，但 25 落在 $\text{(20, 30]}$ 的间隙内。**事务 A** 的 Next-Key Lock 锁住了这个间隙。|  
| **4.** | | **等待超时或事务 A 提交/回滚** | **幻读被阻止。** 只要事务 A 不释放锁，事务 B 就无法插入新记录。|  
| **5.** | `COMMIT;` | | 事务 A 释放所有锁。|  
| **6.** | | **事务 B 才能执行插入操作** | |  
  
**解析：**  
  
1.  当 $T_A$ 执行 `SELECT ... FOR UPDATE` 时，它不仅锁定了 ID 为 20 和 30 的**记录本身**（行锁），还锁定了 $\text{(10, 20)}$ 和 $\text{(20, 30)}$ 这两个**间隙**（间隙锁）。  
2.  事务 $T_B$ 试图插入 ID 为 25 的记录。由于 25 位于 $T_A$ 锁定的 $\text{(20, 30]}$ 间隙内，**插入操作被阻塞**。  
3.  因此， $T_A$ 即使在稍后再次执行同样的查询，也不会看到 ID=25 这条**新的幻影记录**，因为这条记录根本无法在 $T_A$ 事务期间被插入。  
  
## 3. 注意：纯查询 (SELECT) 与 快照读 (Snapshot Read)  
  
需要注意的是，在 MySQL 的 RR 模式下：  
  
* **普通 SELECT 语句** (即**快照读/Snapshot Read**) 是通过 **MVCC**（多版本并发控制）机制实现的，它读取的是事务开始时的版本快照。  
    * **解决幻读：** 快照读本身也可以防止幻读，因为它只看**事务启动时已提交**的数据。如果 $T_B$ 在 $T_A$ 启动后插入并提交了新行， $T_A$ 的快照是**看不到**这行新数据的。  
* **锁定读语句** (例如 `SELECT ... FOR UPDATE` 或 `SELECT ... FOR SHARE`) 是通过 **Next-Key Locks** 机制实现的，它读取的是**最新数据**并加锁。  
    * **解决幻读：** Next-Key Locks 的作用是**阻止**其他事务在锁定的范围内进行 **INSERT** 或 **DELETE**，从而真正从**物理上消除**幻读发生的可能性，保证**数据安全性和一致性**。  
  
**总结来说，Next-Key Locks 是 MySQL InnoDB 在 RR 级别下，用于实现真正的、物理上的“可重复读”和“无幻读”的核心机制，特别是在涉及数据修改或显式锁定的场景中。**  
  
# 四、对比MySQL和PostgreSQL解决幻读的本质区别  
  
好的，MySQL (InnoDB) 和 PostgreSQL 在**可重复读 (Repeatable Read, RR)** 隔离级别下都能解决幻读问题，但它们采用的**本质机制**和**哲学**是完全不同的。  
  
---  
  
## MySQL (InnoDB) 解决幻读的本质：**物理锁（Next-Key Locks）**  
  
MySQL 的 InnoDB 存储引擎在 RR 级别下，主要通过 **锁（Locking）** 机制来解决幻读，特别是 **Next-Key Locks（临键锁）** 。  
  
| 特性 | 描述 | 核心原理 |  
| :--- | :--- | :--- |  
| **隔离级别** | 可重复读 (Repeatable Read, RR) |  
| **核心机制** | **Next-Key Locks (临键锁)**，结合了**行锁**和**间隙锁**。 |  
| **解决本质** | **阻塞其他事务的写入。** 事务 A 通过加锁，**物理上阻止**事务 B 在 A 查询的范围内进行 `INSERT` 或 `DELETE` 操作，从而保证 A 再次查询时记录数量不变。 |  
| **影响** | **读写操作相互影响。** 锁定读（`SELECT ... FOR UPDATE`）会阻止其他事务在间隙内插入数据，降低了并发性。 |  
| **何时生效** | **锁定读**（`SELECT ... FOR UPDATE` 或 `SELECT ... FOR SHARE`）时，锁住索引记录及其间的**间隙**。 |  
| **哲学** | **“宁可错杀，不可放过”。** 使用强力锁机制，在数据操作层面确保一致性。 |  
  
**简而言之：** MySQL 是通过在事务进行范围查询时，**把数据和数据之间的“空地”（间隙）都锁起来**，让其他事务根本无法在那个范围里“偷偷摸摸”地添加或删除记录，从源头上**消除了**幻读的可能。  
  
---  
  
## PostgreSQL 解决幻读的本质：**快照隔离（Snapshot Isolation）**  
  
PostgreSQL 在 RR 级别下，主要通过 **MVCC (多版本并发控制)** 提供的 **事务快照（Transaction Snapshot）** 机制来解决幻读。  
  
| 特性 | 描述 | 核心原理 |  
| :--- | :--- | :--- |  
| **隔离级别** | 可重复读 (Repeatable Read, RR) |  
| **核心机制** | **事务快照（Snapshot Isolation）** ，基于 MVCC。 |  
| **解决本质** | **隔离事务的可见性。** 事务 A **看不到**事务 B 在 A 启动快照后所做的任何更改（包括插入、删除和修改），从而保证两次查询结果集的一致性。 |  
| **影响** | **读写分离，并发性高。** 读操作不加锁，不阻塞写操作；写操作也不阻塞读操作。 |  
| **何时生效** | 事务**第一次执行查询**时，生成一个固定的、全局的快照，并贯穿整个事务生命周期。 |  
| **哲学** | **“眼不见为净”。** 允许其他事务修改数据，但对当前事务保持不可见，保障一致性。 |  
  
**简而言之：** PostgreSQL 是通过在事务开始时， **给事务拍一张“照片”（快照）** 。该事务后续所有的查询都只看这张“照片”上的数据。即使其他事务在后台插入了新记录并提交，这些新记录对当前的事务来说是“透明”或“隐形”的，**自然也就不会发生幻读**。  
  
---  
  
## 对比总结：本质的区别  
  
| 特征 | MySQL (Next-Key Locks) | PostgreSQL (Snapshot Isolation) |  
| :--- | :--- | :--- |  
| **解决方式** | **物理阻止 (Locking)** | **逻辑隔离 (MVCC Snapshot)** |  
| **关键工具** | Next-Key Locks（间隙锁） | 事务快照（Transaction Snapshot） |  
| **性能影响** | 在**锁定读**时，可能因为加锁而**降低并发**。 | 读操作不加锁，**并发性高**。 |  
| **读操作** | 普通 `SELECT` 使用 MVCC 快照，锁定读使用 **Next-Key Lock**。 | 所有 `SELECT` 都使用 **MVCC 快照**。 |  
| **事务冲突** | **阻塞** (事务 B 插入被阻塞，直到 A 释放锁)。 | **不阻塞** (事务 B 可以插入，但对 A 不可见)。 |  
| **数据是否真实** | 锁定读能确保读取到**最新**且**被锁定**的数据。 | 总是读取事务**开始时**的**旧版本**数据。 |  
   
  
#### [期望 PostgreSQL|开源PolarDB 增加什么功能?](https://github.com/digoal/blog/issues/76 "269ac3d1c492e938c0191101c7238216")
  
  
#### [PolarDB 开源数据库](https://openpolardb.com/home "57258f76c37864c6e6d23383d05714ea")
  
  
#### [PolarDB 学习图谱](https://www.aliyun.com/database/openpolardb/activity "8642f60e04ed0c814bf9cb9677976bd4")
  
  
#### [PostgreSQL 解决方案集合](../201706/20170601_02.md "40cff096e9ed7122c512b35d8561d9c8")
  
  
#### [德哥 / digoal's Github - 公益是一辈子的事.](https://github.com/digoal/blog/blob/master/README.md "22709685feb7cab07d30f30387f0a9ae")
  
  
#### [About 德哥](https://github.com/digoal/blog/blob/master/me/readme.md "a37735981e7704886ffd590565582dd0")
  
  
![digoal's wechat](../pic/digoal_weixin.jpg "f7ad92eeba24523fd47a6e1a0e691b59")
  
