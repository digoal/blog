## AI论文解读 | Sql-Like And Quel-Like Correlation Queries With Aggregates Revisited
        
### 作者        
digoal        
        
### 日期        
2025-10-04       
        
### 标签        
PostgreSQL , PolarDB , DuckDB , AI , 论文解读        
        
----        
        
## 背景  
      
https://www2.eecs.berkeley.edu/Pubs/TechRpts/1984/ERL-m-84-75.pdf        
  
提示:          
```          
读懂《Sql-Like And Quel-Like Correlation Queries With Aggregates Revisited》这篇论文需要提前掌握哪些基础知识, 请使用中文通熟易懂的讲解这些基础知识, 可以引用论文中的图、表或使用Markdown支持的图形(text,mermaid等)增加解释性. 
  
使用中文通熟易懂的解读《Sql-Like And Quel-Like Correlation Queries With Aggregates Revisited》这篇论文, 其中的关键内容请着重讲解, 可以引用论文中的图、表或使用Markdown支持的图形(text,mermaid等)增加解释性. 
  
提取《Sql-Like And Quel-Like Correlation Queries With Aggregates Revisited》这篇论文中的重要术语, 使用中文对这些术语进行通熟易懂的讲解, 可以引用论文中的图、表或使用Markdown支持的图形(text,mermaid等)增加解释性. 
```     
  
## 1 前置知识 
  
为了帮助您理解这篇名为《SQL-Like And Quel-Like Correlation Queries With Aggregates Revisited》的论文 ，您需要掌握一些**关系数据库**和**查询语言**的基础知识。

这篇论文主要讨论的是**嵌套查询**（Nested Queries）的**语义**（Semantics）和**优化算法**（Optimization Algorithms），特别是涉及到**聚合函数**（Aggregates）和**关联**（Correlation）的情况。

以下是您需要提前了解的关键概念，我将用通俗易懂的中文进行解释：

-----

## 1\. 关系数据库基础

您需要知道数据库是由**关系**（Relations，即**表**Table）组成的，每个关系有**属性**（Attributes，即**列**Column）和**元组**（Tuples，即**行**Row）。

  * **示例关系（表）**
    论文中使用了两个示例关系：**`PARTS`**（零件）和 **`SUPPLY`**（供应）。

    | 关系 | 属性 (列) | 含义 |
    | :--- | :--- | :--- |
    | **PARTS** | `PNUM` | 零件编号 (Part Number) |
    | | `QOH` | 现有数量 (Quantity On Hand) |
    | **SUPPLY** | `PNUM` | 零件编号 |
    | | `QUAN` | 运输数量 (Quantity) |
    | | `SHIPDATE` | 运输日期 (Ship Date) |

  * **数据实例**
    论文中给出了具体的实例数据，例如：

    | PARTS | PNUM | QOH |
    | :---: | :---: | :---: |
    | | 3 | 6 |
    | | 10 | 1 |
    | | 8 | 0 |

    | SUPPLY | PNUM | QUAN | SHIPDATE |
    | :---: | :---: | :---: | :---: |
    | | 3 | 4 | 7-3-79 |
    | | 3 | 2 | 10-1-78 |
    | | 10 | 1 | 6-8-78 |
    | | 10 | 2 | 8-10-81 |
    | | 5 | 5 | 5-7-83 |

-----

## 2\. SQL 和 QUEL 查询语言

这篇论文围绕两种主要的查询语言展开讨论：

### 2.1. SQL (Structured Query Language)

  * **核心结构**：您应该熟悉 `SELECT`, `FROM`, `WHERE` 这些基本子句。

  * **嵌套查询 (Nested Query)**：一个查询块包含在另一个查询块的 `WHERE` 子句中。

  * **关联查询 (Correlation Query)**：**内层查询**引用了**外层查询**中的关系属性。这是论文讨论的重点。

      * **论文中的示例 (Query Q1)** 
        ```sql
        SELECT PNUM 
        FROM PARTS 
        WHERE QOH = (SELECT MAX( QUAN)  -- 内层查询：聚合函数 MAX
                       FROM SUPPLY 
                       WHERE SUPPLY.PNUM = PARTS.PNUM -- 关联条件：引用外层 PARTS 的 PNUM
                         AND SHIPDATE < '1-1-80') 
        ```
      * **类型 JA 查询 (Type-JA Query)**：论文的核心讨论对象。它的定义是：内层查询块的 `WHERE` 子句包含一个引用外层关系的**连接谓词**（join predicate），并且内层查询块的 `SELECT` 子句包含一个**聚合函数**（Aggregate Function）。

### 2.2. QUEL (Query Language)

  * **核心结构**：QUEL 使用 **`RANGE OF`** 来声明变量（域变量），使用 **`RETRIEVE`** 来获取数据。
      * **示例** 
        ```quel
        RANGE OF P IS PARTS
        RANGE OF S IS SUPPLY
        RETRIEVE (P.PNUM)
        WHERE P.QOH = COUNT(S.SHIPDATE
                              WHERE S.PNUM = P.PNUM AND S.SHIPDATE < '1-1-80')
        ```
  * **BY-list 机制**：QUEL 区分**简单聚合**（Scalar Aggregate，得到单个值）和**聚合函数**。要实现像 SQL 关联查询那样的“分组并计算聚合”，必须使用 `BY` 列表（BY-list）来明确指定分组的属性 。
      * **关联聚合**：`COUNT(S.SHIPDATE BY P.PNUM ...)` 告诉系统按 `P.PNUM` 分组来计算计数。

-----

## 3\. 核心概念：语义和优化

理解论文的关键在于区分查询的**原始语义**和**优化后的等效转换**。

### 3.1. 原始语义：嵌套迭代 (Nested-Iteration)

这是定义关联查询**正确答案**的标准方法 ：

  * **工作方式**：对于外层关系（如 `PARTS`）中的**每一个元组**（行），将它的关联属性值（如 `PARTS.PNUM`）代入内层查询，然后独立地执行内层查询。将内层查询的结果与外层查询的条件进行比较。
  * **通俗理解**：就像一个 **`for` 循环**：
    ```
    对于 PARTS 表中的每一行 P：
        计算内层查询的结果 R (比如 MAX(QUAN))，只考虑那些 PNUM 等于 P.PNUM 的 SUPPLY 行。
        如果 P.QOH 等于 R，则保留 P.PNUM。
    ```
  * **问题**：性能非常差，因为内层查询要被执行多次（外层有多少行就执行多少次）。

### 3.2. 优化算法：一次性求值转换

为了提高性能，优化算法的目标是**只计算一次聚合** ：

  * **核心思想**：将关联查询（Type-JA）转换成一个**连接查询**（Join Query）。

  * **Kim 的算法**：通过创建一个**临时关系**（Temporary Relation，如 `TEMP`），先对内层关系进行分组计算聚合值，然后将这个临时关系与外层关系进行连接 。

      * **步骤（以 Q1 为例）** ：
        1.  计算**临时表 `TEMP`**：
            ```sql
            TEMP (SUPPNUM, MAXQUAN) = (SELECT PNUM, MAX(QUAN)
                                        FROM SUPPLY
                                        WHERE SHIPDATE < '1-1-80'
                                        GROUP BY PNUM)
            ```
        2.  将外层查询转换为**连接查询**：
            ```sql
            SELECT PNUM
            FROM PARTS, TEMP
            WHERE PARTS.QOH = TEMP.MAXQUAN
              AND PARTS.PNUM = TEMP.SUPPNUM
            ```

  * **问题所在**：论文证明，这种转换在处理**空集上的聚合**时，与嵌套迭代的语义不一致，尤其是使用 **`COUNT`** 聚合函数时会出错 。

-----

## 4\. 关键难点：空集上的聚合 (Aggregates Over Empty Sets)

这是论文的核心技术点。当内层查询的 `WHERE` 子句筛选出**零个元组**（空集）时，聚合函数应该返回什么值？

  * **对于 MAX/MIN/SUM/AVG**：

      * **方案 (a)（默认值 0）** ：一些系统会默认返回 0 。
      * **方案 (b)（NULL 值）** ：SQL 标准或某些系统（如 Ingres）会返回一个特殊的 **`NULL`** 值 。在 SQL 的三值逻辑中，`QOH = NULL` 会评估为**未知**（Unknown, `?`），导致该行不被选中 。

  * **对于 COUNT**：

      * **定义**：**`COUNT`** 函数在空集上是**完全定义**的，结果是 **0** 。因此，`NULL` 值的处理方式不再是逃避错误的借口 。
      * **Kim 转换的失败原因**：在 Kim 的优化算法中，临时表的计算使用了 `WHERE...GROUP BY` 语义 。如果外层关联列（如 `PARTS.PNUM` = 8）在内层关系（`SUPPLY`）中**完全没有对应的元组**，那么在创建临时表 `TEMP` 的 `GROUP BY` 步骤中，这个 **`PNUM`（即 8）根本不会出现在 `TEMP` 中** 。这导致原本应该计数为 0 的行，在最终的连接中丢失了 。

    **简单来说：**

      * **嵌套迭代**：看到 `PNUM` = 8，执行内层查询，得到空集，`COUNT` 返回 **0**。如果 `QOH` 也是 0，则匹配。
      * **Kim 转换**：在构建临时表 `TEMP` 时，`PNUM` = 8 **没有出现在 `SUPPLY` 中**，所以 `TEMP` 中**没有** `(8, 0)` 这一行。最终连接时，`PNUM` = 8 的行被遗漏了。

  * **QUEL 的解决方法**：QUEL 的优化算法通过**首先投影外层关联列**（即 `BY-list` 中的列）到临时表并**初始化聚合值为 0**（如 `CT := 0`） ，保证了所有外层关联值都会有一个初始的聚合值，从而避免了 `COUNT` 在空集上计算导致的丢失问题 。

理解这些概念，尤其是**嵌套迭代**和**优化转换**在处理**空集 `COUNT` 聚合**时的区别，将是您理解论文中“SQL 算法失败”和“QUEL 算法修复”的关键。
  
## 2 解读论文 
  
好的，這就為您通俗易懂地解讀這篇名為《SQL-Like and Quel-Like Correlation Queries with Aggregates Revisited》的論文。

### 論文核心思想概覽

這篇發表於1984年的論文  是一篇「學術糾錯」性質的文章。作者Werner Kiessling重新審視了當時已有的一些用於優化特定SQL和QUEL數據庫查詢的算法，特別是那些涉及 **嵌套查詢（nested queries）** 、 **聚合函數（aggregates）** 和 **關聯條件（correlated predicates）** 的複雜查詢 。

論文的核心結論是：

1.  當時流行的針對SQL嵌套查詢的優化算法，在處理 `COUNT` 聚合函數時存在**根本性的錯誤** ，會導致計算出錯誤的結果，而且這個錯誤很難修復 。
2.  對於另一種類似的查詢語言QUEL，其算法雖然更優越，但也存在一個小Bug，不過這個Bug可以被輕易修復 。

簡單來說，作者發現當時的學者們為了提升數據庫查詢速度而設計的「快捷算法」，在某些情況下會「抄錯路」，從而得出與原始、緩慢但準確的查詢方法不一致的答案。

-----

### 關鍵內容深度解析

#### 1\. 什麼是「關聯嵌套聚合查詢」(Type-JA Query)？

這是本文討論的核心問題。我們用論文中的經典例子來說明 。

假設我們有兩個數據庫表：

  * **PARTS (零件表)**：記錄零件編號 (`PNUM`) 和庫存數量 (`QOH`) 。
  * **SUPPLY (供應表)**：記錄供應的零件編號 (`PNUM`)、供應數量 (`QUAN`) 和發貨日期 (`SHIPDATE`) 。

現在，有一個查詢需求 Q1：

> **找出所有這樣的零件：其當前庫存數量 (`QOH`) 等於它在1980年1月1日之前，單次發貨的最大數量 (`MAX(QUAN)`)。** 

這個需求寫成SQL就是論文中的**Query Q1**：

```sql
SELECT PNUM
FROM PARTS
WHERE QOH = (SELECT MAX(QUAN)
             FROM SUPPLY
             WHERE SUPPLY.PNUM = PARTS.PNUM AND
                   SHIPDATE < '1-1-80')
```

這種查詢的特點是：

  * **嵌套 (Nested)**：有一個查詢（內層）嵌套在另一個查詢（外層）的 `WHERE` 條件裡。
  * **關聯 (Correlated)**：內層查詢的條件 (`SUPPLY.PNUM = PARTS.PNUM`) 引用了外層查詢的表 (`PARTS`) 的字段值。這意味著內層查詢不能獨立執行，它需要依賴外層查詢的每一行數據。
  * **聚合 (Aggregate)**：內層查詢使用了聚合函數，如 `MAX`、`COUNT` 等。

論文將這種查詢稱為 **Type-JA Query** 。

#### 2\. 兩種查詢評估方法：慢而準 vs. 快但錯

##### 方法一：嵌套迭代法 (Nested-Iteration) - 慢但準確

這是最直觀、最符合查詢語義的執行方式 。

1.  遍歷 `PARTS` 表的**每一行**。
2.  對於 `PARTS` 的每一行，取出其 `PNUM` 值。
3.  將這個 `PNUM` 值代入內層查詢，執行一次內層查詢，計算出最大發貨量。
4.  用計算出的結果與當前 `PARTS` 行的 `QOH` 進行比較，如果相等，則該 `PNUM` 符合條件。

這種方法就像「一個一個地核對」，邏輯清晰，結果準確，但性能極差。如果 `PARTS` 表有1萬行，內層查詢就要執行1萬次 。

##### 方法二：查詢轉換法 (Transformation Algorithm) - 快但可能出錯

為了提高性能，當時的研究者（如論文中提到的Kim ）提出了一種優化算法：將嵌套查詢轉換為一個**Join（連接）查詢**，這樣內層聚合計算只需要執行一次 。

以上述Query Q1為例，轉換過程分為兩步 ：

1.  **第一步**：先獨立計算出所有在 '1-1-80' 之前有發貨記錄的零件的 `MAX(QUAN)`，並存入一個臨時表 `TEMP` 。
    ```sql
    -- 創建臨時表 TEMP
    TEMP (SUPPNUM, MAXQUAN) = 
        (SELECT PNUM, MAX(QUAN)
         FROM SUPPLY
         WHERE SHIPDATE < '1-1-80'
         GROUP BY PNUM)
    ```
2.  **第二步**：然後將 `PARTS` 表與這個 `TEMP` 表進行 Join 操作，找出符合條件的零件 。
    ```sql
    -- Join 查詢
    SELECT P.PNUM
    FROM PARTS P, TEMP T
    WHERE P.PNUM = T.SUPPNUM AND P.QOH = T.MAXQUAN
    ```

這個方法顯然快得多，因為它避免了對 `PARTS` 表的循環迭代。

#### 3\. 算法的致命缺陷：`COUNT` 函數和「空集合」問題

論文作者指出，上述的「查詢轉換法」在使用 `MAX`、`MIN`、`SUM` 等聚合函數時，只要正確處理 `NULL` 值（即對於沒有發貨記錄的零件，`MAX` 結果為 `NULL`），結果就是正確的 。

然而，當聚合函數是 `COUNT` 時，這個算法就出錯了 。

我們來看論文中的**Query Q2**，它只是把Q1的`MAX`換成了`COUNT`：

> **找出所有這樣的零件：其庫存 (`QOH`) 等於它在1980年1月1日之前的發貨次數。** 

```sql
-- Query Q2
SELECT PNUM
FROM PARTS
WHERE QOH = (SELECT COUNT(SHIPDATE)
             FROM SUPPLY
             WHERE SUPPLY.PNUM = PARTS.PNUM AND
                   SHIPDATE < '1-1-80')
```

`COUNT` 函數有一個重要特性：**對於空集合，`COUNT` 的結果是 0，而不是 `NULL`** 。

##### 讓我們用論文中的數據來看看兩種方法的结果差异：

**數據表示例:** 

| PARTS | PNUM | QOH |
| :--- | :---: | :-: |
| | 3 | 6 |
| | 10 | 1 |
| | 8 | 0 |

| SUPPLY | PNUM | QUAN | SHIPDATE |
| :--- | :---: | :-: | :---: |
| | 3 | 4 | 7-3-79 |
| | 3 | 2 | 10-1-78 |
| | 10 | 1 | 6-8-78 |
| | 10 | 2 | 8-10-81 |
| | 5 | 5 | 5-7-83 |

-----

**使用「慢而準」的嵌套迭代法分析Q2：**

  * **對於 PNUM = 3**：1980年前有2次發貨記錄，`COUNT`=2。`QOH`=6。`6 != 2`，不匹配。
  * **對於 PNUM = 10**：1980年前有1次發貨記錄，`COUNT`=1。`QOH`=1。`1 == 1`，**匹配**。
  * **對於 PNUM = 8**：1980年前沒有發貨記錄（空集合），`COUNT`=0。`QOH`=0。`0 == 0`，**匹配**。

因此，**正確的結果應該是 `{10, 8}`** 。

-----

**使用「快但錯」的查詢轉換法分析Q2：** 

1.  **創建臨時表 `TEMP`**：算法只會處理在 `SUPPLY` 表中 `SHIPDATE < '1-1-80'` 的記錄。

      * PNUM=3，有2條記錄。
      * PNUM=10，有1條記錄。
      * **PNUM=8**，因為在 `SUPPLY` 表中根本沒有它的發貨記錄，所以在 `GROUP BY` 這一步，**PNUM=8 就被過濾掉了！** 

    所以 `TEMP` 表的內容是：
    | TEMP | SUPPNUM | CT |
    | :--- | :---: | :-: |
    | | 3 | 2 |
    | | 10 | 1 |

2.  **執行 Join 操作**：

      * `PARTS` 的 `{10, 1}` 與 `TEMP` 的 `{10, 1}` 匹配，所以 **10** 被選中。
      * `PARTS` 的 `{8, 0}` 因為在 `TEMP` 表中找不到 `SUPPNUM=8` 的行，所以無法Join，被丟棄了。

因此，**錯誤的結果是 `{10}`** 。

**錯誤的根源**：查詢轉換法在第一步（生成`TEMP`表）時，是基於 `SUPPLY` 表的，它丟失了那些在 `PARTS` 表中存在但在 `SUPPLY` 表中沒有符合條件記錄的零件信息（如PNUM=8）。而嵌套迭代法則保證了 `PARTS` 表中的每一個零件都被考慮到 。

作者進一步指出，即使嘗試用更複雜的邏輯（比如 `OR...IS NOT IN`）去彌補這個錯誤，也只能在單層嵌套查詢中起作用。對於更複雜的多層嵌套查詢，這種「打補丁」的方法是行不通的 。

#### 4\. QUEL 語言的處理方式：更優越但仍有瑕疵

論文接著分析了另一種數據庫語言QUEL。QUEL的語法和處理方式與SQL不同，它要求用戶通過 `BY` 關鍵字顯式指定關聯列 。

QUEL的算法是這樣工作的（以Query Q2' 為例）：

1.  **第一步**：它不是從內層的 `SUPPLY` 表開始，而是先從外層的 `PARTS` 表中，把所有需要關聯的 `PNUM` 值取出來，存入臨時表 `TEMP1`，並將計數器初始化為0 。這一步就**保證了所有 `PARTS` 表中的零件都被考慮到**。
    ```
    TEMP1:
    PNUM | CT
    -----|----
    3    | 0
    10   | 0
    8    | 0
    ```
2.  **第二步**：然後才去計算 `SUPPLY` 表中的發貨次數。
3.  **第三步**：用計算出的真實計數值去更新 `TEMP1` 表。對於沒有記錄的PNUM=8，其計數值依然是0。
4.  **第四步**：最後將更新後的 `TEMP1` 與 `PARTS` 表進行Join，得到正確結果 `{10, 8}` 。

作者認為QUEL的方法從根本上避免了SQL轉換算法的錯誤 。但他也發現，QUEL的一個被稱為「BY-list optimization」的優化措施，在處理超過一層的嵌套查詢時，會錯誤地修改查詢邏輯，導致一個**新的Bug** 。不過，作者認為這個Bug很容易修復，不像SQL的那個問題是根本性的 。

### 結論與影響

這篇論文的結論非常清晰：

  * **對於SQL**：當時流行的、旨在提高性能的查詢轉換算法在處理帶 `COUNT` 的關聯嵌套查詢時是**錯誤的** 。這個缺陷源於 `GROUP BY` 子句的語義，很難被優雅地修復 。
  * **對於QUEL**：其處理聚合查詢的算法設計更為健壯，雖然存在一個可修復的小Bug，但其核心思想是正確的 。
  * **深層啟示**：作者認為這也反映出將聚合操作完美融入關係代數（數據庫的理論基礎）本身就是一件困難的事情 。

這篇論文在當時對數據庫系統的實現者和研究者起到了重要的警示作用，指出了在追求查詢優化時，必須要極其小心，確保轉換後查詢的語義與原始語義（即嵌套迭代的語義）完全一致，否則速度的提升將以犧牲結果的正確性為代價。
  
## 3 术语 
  
好的，我将为您提取《SQL-Like And QUEL-Like Correlation Queries With Aggregates Revisited》这篇论文中的重要术语，并用通俗易懂的中文进行解释。这篇论文主要围绕数据库查询优化和语义一致性展开。

-----

## 论文重要术语及其解释

### 1\. 关联查询 (Correlation Queries)

  * **定义**：指**嵌套查询**中的内层查询块引用了外层查询块中的关系属性 。这种引用使得内层查询的结果依赖于外层查询的当前元组。
  * **通俗理解**：想象一下一个 Excel 表格，您在某一列中设置了一个公式，这个公式需要引用同一行中另一列的值来计算。在数据库查询中，内层的计算（子查询）必须依赖于外层当前正在处理的数据行。
  * **论文示例（Query Q1）** ：
    ```sql
    SELECT PNUM FROM PARTS 
    WHERE QOH = (SELECT MAX(QUAN) 
                   FROM SUPPLY 
                   WHERE SUPPLY.PNUM = PARTS.PNUM -- 关联发生在这里
                     AND SHIPDATE < '1-1-80')
    ```
    内层查询使用 `PARTS.PNUM` 来筛选 `SUPPLY` 表中的数据，这就是一个关联。

-----

### 2\. Type-JA 查询 (Type-JA Queries)

  * **定义**：特指一种嵌套的 SQL-like 查询 。
      * 内层查询的 `WHERE` 子句包含一个**连接谓词**（join predicate），该谓词引用了外层查询的关系 。
      * 内层查询的 `SELECT` 子句包含一个**聚合函数**（Aggregate Function）。
  * **通俗理解**：这是论文重点讨论的查询类型。它结合了**关联**（J for Join）和**聚合**（A for Aggregate）。论文中的 Q1 和 Q2 都是 Type-JA 查询。

-----

### 3\. 嵌套迭代 (Nested-Iteration) 语义

  * **定义/语义**：这是定义关联查询结果的**标准方法**和**原始语义** 。它通过对外层查询的每个关联值，重复执行一次内层查询块来计算聚合 。
  * **通俗理解**：这是“最直接但效率最低”的执行方式。
    1.  取外层表（`PARTS`）的第一行。
    2.  将这行的数据代入内层查询，并执行。
    3.  将内层结果与外层条件比较。
    4.  重复上述步骤，直到外层表的所有行都处理完毕 。
  * **重要性**：**嵌套迭代**的结果被视为**正确的答案**。所有优化算法都必须保证其结果与此语义一致 。
  * **性能问题**：这种方法通常性能很差 。

-----

### 4\. 查询转换算法 (Transformation Algorithms)

  * **定义**：旨在设计更快的算法，通过**只计算一次内层聚合**而不是重复迭代，来处理关联查询 。
  * **通俗理解**：将复杂的“循环查询”（嵌套迭代）转换为更高效的“连接查询”（Join Query）。
      * **Kim/Kiessling 的 SQL-like 转换**：通过先创建一个包含聚合值的临时关系 `TEMP`，然后将 `PARTS` 和 `TEMP` 进行连接来实现 。
      * **论文的发现**：尽管这种转换对于 `MAX`, `MIN`, `SUM`, `AVG` 聚合函数在正确使用 **NULL** 值的情况下通常是等效的 ，但它在涉及 **`COUNT`** 聚合函数时**会失败** 。

-----

### 5\. 空集上的聚合 (Aggregates Over Empty Sets)

  * **定义**：当内层查询的 `WHERE` 子句筛选出的元组集合是**空集**（没有匹配的行）时，聚合函数应该返回的值 。

  * **区别**：

      * **`MAX`, `MIN`, `SUM`, `AVG`**：通常返回一个特殊的 **NULL** 值 。在 SQL 的三值逻辑中，`QOH = NULL` 会评估为“未知”，导致该行不被选中 。
      * **`COUNT`**：是一个**完全定义**的函数，在空集上的定义值为 **0** 。

  * **导致 SQL 转换失败的原因**：当使用 `COUNT` 时，如果外层关联列（如 `PARTS.PNUM` = 8）在内层关系中找不到匹配行，Kim 的 `WHERE...GROUP BY` 转换语义会导致：

      * **嵌套迭代**：计算结果为 $COUNT() = 0$ 。
      * **Kim 转换**：`GROUP BY` 过程只对有匹配的行分组，因此 `PNUM=8` 不会出现在临时表 `TEMP` 中，导致最终结果丢失了那些聚合值为 0 的行 。

-----

### 6\. QUEL 的 BY-list 机制

  * **定义**：QUEL 语言通过在聚合函数中明确使用 **`BY` 列表**（BY-list），来指定分组和计算聚合的属性 。
      * **示例**：`COUNT(S.SHIPDATE BY P.PNUM ...)` 。
  * **优势**：QUEL 的优化算法**首先将外层关联列 **（即 BY-list）** 投影到一个临时关系并初始化聚合值为 0** 。
      * **通俗理解**：QUEL 的做法是“先报到，再统计”。它先列出所有可能的外层关联值（即使它们在内层关系中没有匹配），并把它们的计数设为 0。然后才开始计算实际的计数并替换 0。
      * **重要性**：这种方法**避免了** SQL 转换中 `COUNT` 聚合丢失空集关联值的问题 ，使其在 Type-JA 查询上与嵌套迭代语义一致（存在少数例外情况）。

-----

### 7\. BY-list 优化 (BY-list optimization)

  * **定义**：Ingres (QUEL 的实现) 中的一个优化步骤，试图从聚合函数的子查询中**消除逻辑上多余的范围变量**（range variables） 。
  * **通俗理解**：在某些情况下，如果一个变量在 `BY` 列表中出现，优化器可能会试图用另一个等价的变量替换它，或直接删除看似多余的关联条件。
  * **论文的发现**：如果该优化被**无条件应用**，对于**关联级别大于 1**（即多层嵌套）的查询，它会导致**结果不一致**（产生错误答案）。论文通过 Q3' 证明了这一点，发现了一个**可修复的 Bug** 。
  
## 参考        
         
https://www2.eecs.berkeley.edu/Pubs/TechRpts/1984/ERL-m-84-75.pdf    
        
<b> 以上内容基于DeepSeek、Qwen、Gemini及诸多AI生成, 轻微人工调整, 感谢杭州深度求索人工智能、阿里云、Google等公司. </b>        
        
<b> AI 生成的内容请自行辨别正确性, 当然也多了些许踩坑的乐趣, 毕竟冒险是每个男人的天性.  </b>        
      
#### [期望 PostgreSQL|开源PolarDB 增加什么功能?](https://github.com/digoal/blog/issues/76 "269ac3d1c492e938c0191101c7238216")
  
  
#### [PolarDB 开源数据库](https://openpolardb.com/home "57258f76c37864c6e6d23383d05714ea")
  
  
#### [PolarDB 学习图谱](https://www.aliyun.com/database/openpolardb/activity "8642f60e04ed0c814bf9cb9677976bd4")
  
  
#### [PostgreSQL 解决方案集合](../201706/20170601_02.md "40cff096e9ed7122c512b35d8561d9c8")
  
  
#### [德哥 / digoal's Github - 公益是一辈子的事.](https://github.com/digoal/blog/blob/master/README.md "22709685feb7cab07d30f30387f0a9ae")
  
  
#### [About 德哥](https://github.com/digoal/blog/blob/master/me/readme.md "a37735981e7704886ffd590565582dd0")
  
  
![digoal's wechat](../pic/digoal_weixin.jpg "f7ad92eeba24523fd47a6e1a0e691b59")
  
