## DuckDB 源码学习: 4.1 连接处理（Join Processing）       
                                
### 作者                                
digoal                                
                                
### 日期                                
2025-10-23                                
                                
### 标签                                
DuckDB , 源码学习                                
                                
----                                
                                
## 背景                 
本文介绍 DuckDB 的连接执行系统，包括各种连接算法、哈希表实现以及操作符选择逻辑。连接处理负责根据指定的条件将多个表中的行进行组合，具体实现了诸如哈希连接（hash join）、归并连接（merge join）和嵌套循环连接（nested loop join）等算法。  
  
## 连接算法概览  
  
DuckDB 实现了多种连接算法，每种算法都针对不同的场景进行了优化，这些场景取决于数据特征、连接条件和内存限制。  
  
![pic](20241023_14_pic_001.jpg)  
  
**连接算法选择逻辑**    
  
源文件：  
- [`src/execution/physical_plan/plan_comparison_join.cpp`（第 22–100 行）](https://github.com/duckdb/duckdb/blob/05a2403c/src/execution/physical_plan/plan_comparison_join.cpp#L22-L100)  
  
## 哈希连接实现  
  
哈希连接是 DuckDB 的主要连接算法，通过 `PhysicalHashJoin` 操作符和 `JoinHashTable` 类实现。它将较小的关系表（构建端，build side）构建成哈希表，并用较大的关系表（探测端，probe side）对其进行探测。  
  
### 核心哈希连接架构    
![pic](20241023_14_pic_002.jpg)  
  
源文件：    
- [`src/execution/join_hashtable.cpp`（第 35–118 行）](https://github.com/duckdb/duckdb/blob/05a2403c/src/execution/join_hashtable.cpp#L35-L118)    
- [`src/execution/operator/join/physical_hash_join.cpp`（第 31–110 行）](https://github.com/duckdb/duckdb/blob/05a2403c/src/execution/operator/join/physical_hash_join.cpp#L31-L110)  
  
### 哈希表结构  
  
`JoinHashTable` 使用线性探测（linear probing）哈希表，并通过“盐值”（salt）优化来处理哈希冲突：  
- **条目结构**：每个哈希表项（`ht_entry_t`）包含一个盐值（salt value）和一个指向元组数据的指针。    
- **线性探测**：当发生冲突时，通过向前扫描，直到找到一个空槽位或匹配的条目为止。    
- **盐值优化**：在哈希表较大（超过 8192 个条目）时启用，用于减少探测过程中的内存访问开销。    
- **元组布局**：数据以列式格式存储在可配置布局的 `TupleDataCollection` 中。  
  
**关键类与方法：**    
- `JoinHashTable::Build()` – 从输入数据块构建哈希表    
- `JoinHashTable::Probe()` – 探测哈希表并初始化扫描结构    
- `JoinHashTable::ScanStructure::Next()` – 遍历探测结果    
- `JoinHashTable::InsertHashes()` – 插入条目并处理冲突    
  
源文件：    
- [`src/include/duckdb/execution/join_hashtable.hpp`（第 58–450 行）](https://github.com/duckdb/duckdb/blob/05a2403c/src/include/duckdb/execution/join_hashtable.hpp#L58-L450)    
- [`src/execution/join_hashtable.cpp`（第 376–449 行）](https://github.com/duckdb/duckdb/blob/05a2403c/src/execution/join_hashtable.cpp#L376-L449)  
  
### 完美哈希连接优化（Perfect Hash Join Optimization）  
  
对于具有密集范围的小整数连接键，DuckDB 使用完美哈希连接优化：   
  
![pic](20241023_14_pic_003.jpg)  
  
该优化在可行时直接将连接键用作数组索引，从而完全消除哈希冲突。  
  
源文件：    
- [`src/execution/operator/join/perfect_hash_join_executor.cpp`（第 66–121 行）](https://github.com/duckdb/duckdb/blob/05a2403c/src/execution/operator/join/perfect_hash_join_executor.cpp#L66-L121)    
- [`src/include/duckdb/execution/operator/join/perfect_hash_join_executor.hpp`（第 22–71 行）](https://github.com/duckdb/duckdb/blob/05a2403c/src/include/duckdb/execution/operator/join/perfect_hash_join_executor.hpp#L22-L71)  
  
### 外部哈希连接（External Hash Join）  
  
对于超出内存限制的连接操作，DuckDB 通过基数分区（radix partitioning）实现外部哈希连接：  
- **基数分区（Radix Partitioning）**：利用哈希前缀对数据进行分区，以减小工作集（working set）的大小。    
- **溢出管理（Spill Management）**：`ProbeSpill` 负责处理无法装入内存的探测端（probe-side）数据。    
- **递归处理（Recursive Processing）**：对于过大的分区，会使用额外的基数位（radix bits）进行递归再分区。  
  
源文件：    
- [`src/execution/join_hashtable.cpp`（第 441–450 行）](https://github.com/duckdb/duckdb/blob/05a2403c/src/execution/join_hashtable.cpp#L441-L450)    
- [`src/include/duckdb/execution/join_hashtable.hpp`（第 341–449 行）](https://github.com/duckdb/duckdb/blob/05a2403c/src/include/duckdb/execution/join_hashtable.hpp#L341-L449)   
  
## 其他连接算法  
  
### 分段归并连接（Piecewise Merge Join）  
  
`PhysicalPiecewiseMergeJoin` 为范围谓词（如 `t1.a < t2.b`）实现排序-归并连接（sort-merge join）：    
  
![pic](20241023_14_pic_004.jpg)  
  
当两侧数据均可高效排序时，该算法会被选用。  
  
源文件：    
- [`src/execution/operator/join/physical_piecewise_merge_join.cpp`（第 17–56 行）](https://github.com/duckdb/duckdb/blob/05a2403c/src/execution/operator/join/physical_piecewise_merge_join.cpp#L17-L56)     
- [`src/include/duckdb/execution/operator/join/physical_piecewise_merge_join.hpp`（第 20–80 行）](https://github.com/duckdb/duckdb/blob/05a2403c/src/include/duckdb/execution/operator/join/physical_piecewise_merge_join.hpp#L20-L80)   
  
### 不等式连接（Inequality JOIN , IE Join）  
  
`PhysicalIEJoin` 使用“Union 算法”实现了一种专门用于处理两个不等式谓词的连接算法：  
- **双重排序（Dual Sort）**：根据不等式的方向，分别对两个关系按不同的键进行排序。    
- **Union 算法（Union Algorithm）**：高效地找出满足两个不等式条件的所有元组对。    
- **位图过滤（Bitmap Filtering）**：使用位掩码（bitmasks）来跟踪匹配的组合。  
  
源文件：    
- [`src/execution/operator/join/physical_iejoin.cpp`（第 22–71 行）](https://github.com/duckdb/duckdb/blob/05a2403c/src/execution/operator/join/physical_iejoin.cpp#L22-L71)     
- [`src/include/duckdb/execution/operator/join/physical_iejoin.hpp`（第 16–62 行）](https://github.com/duckdb/duckdb/blob/05a2403c/src/include/duckdb/execution/operator/join/physical_iejoin.hpp#L16-L62)   
  
### 嵌套循环连接（Nested Loop Join）  
  
`PhysicalNestedLoopJoin` 为复杂谓词提供一种后备算法：  
- **物化右表（Materialized RHS）**：右表（RHS）被完整物化存储在 `ColumnDataCollection` 中。    
- **笛卡尔迭代（Cartesian Iteration）**：每个左表元组都会与所有右表元组进行比较。    
- **表达式求值（Expression Evaluation）**：可对任意的连接谓词进行求值。  
  
源文件：    
- [`src/execution/operator/join/physical_nested_loop_join.cpp`（第 12–29 行）](https://github.com/duckdb/duckdb/blob/05a2403c/src/execution/operator/join/physical_nested_loop_join.cpp#L12-L29)     
- [`src/include/duckdb/execution/operator/join/physical_nested_loop_join.hpp`（第 15–83 行）](https://github.com/duckdb/duckdb/blob/05a2403c/src/include/duckdb/execution/operator/join/physical_nested_loop_join.hpp#L15-L83)   
  
## 连接规划与算法选择  
  
`PlanComparisonJoin()` 中的连接规划逻辑会根据多个因素选择最优的连接算法：  
  
![pic](20241023_14_pic_005.jpg)  
  
**选择标准（Selection Criteria）：**  
- **哈希连接（Hash Join）**：等值谓词（equality predicates）的默认选择    
- **完美哈希连接（Perfect Hash）**：适用于键值范围小且密集的小整数键    
- **归并连接（Merge Join）**：适用于单个范围谓词（如 `a < b`）    
- **不等式连接（IE Join）**：适用于两个或更多范围谓词    
- **嵌套循环连接（Nested Loop）**：适用于复杂谓词或小规模关系    
- **分块嵌套循环连接（Blockwise NL）**：适用于任意表达式  
  
源文件：  
- [`src/execution/physical_plan/plan_comparison_join.cpp`（第 38–100 行）](https://github.com/duckdb/duckdb/blob/05a2403c/src/execution/physical_plan/plan_comparison_join.cpp#L38-L100)   
  
## 连接类型与语义  
  
DuckDB 支持所有标准 SQL 连接类型，并针对每种类型进行专门处理：  
- **INNER（内连接）**：仅返回匹配的行    
- **LEFT/RIGHT/FULL OUTER（左/右/全外连接）**：包含不匹配的行，并用 NULL 填充缺失部分    
- **SEMI/ANTI（半连接/反连接）**：根据右表是否存在匹配项，返回左表的行    
- **MARK（标记连接）**：添加一个布尔列，指示是否存在匹配    
- **SINGLE（单匹配连接）**：确保每个左表行最多只匹配一个右表行    
  
每种连接算法都在其各自的 `Next()` 方法中实现了针对特定连接类型的逻辑。  
  
源文件：    
- [`src/execution/join_hashtable.cpp`（第 841–874 行）](https://github.com/duckdb/duckdb/blob/05a2403c/src/execution/join_hashtable.cpp#L841-L874)     
- [`src/execution/operator/join/physical_nested_loop_join.cpp`（第 330–345 行）](https://github.com/duckdb/duckdb/blob/05a2403c/src/execution/operator/join/physical_nested_loop_join.cpp#L330-L345)   
         
#### [期望 PostgreSQL|开源PolarDB 增加什么功能?](https://github.com/digoal/blog/issues/76 "269ac3d1c492e938c0191101c7238216")
  
  
#### [PolarDB 开源数据库](https://openpolardb.com/home "57258f76c37864c6e6d23383d05714ea")
  
  
#### [PolarDB 学习图谱](https://www.aliyun.com/database/openpolardb/activity "8642f60e04ed0c814bf9cb9677976bd4")
  
  
#### [PostgreSQL 解决方案集合](../201706/20170601_02.md "40cff096e9ed7122c512b35d8561d9c8")
  
  
#### [德哥 / digoal's Github - 公益是一辈子的事.](https://github.com/digoal/blog/blob/master/README.md "22709685feb7cab07d30f30387f0a9ae")
  
  
#### [About 德哥](https://github.com/digoal/blog/blob/master/me/readme.md "a37735981e7704886ffd590565582dd0")
  
  
![digoal's wechat](../pic/digoal_weixin.jpg "f7ad92eeba24523fd47a6e1a0e691b59")
  
