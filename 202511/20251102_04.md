## VectorChord 源码学习: 6.5 基准测试 (Benchmarking)  
                                                            
### 作者                                                            
digoal                                                            
                                                            
### 日期                                                            
2025-11-02                                                            
                                                            
### 标签                                                            
VectorChord , 源码学习                                                            
                                                            
----                                                            
                                                            
## 背景                 
本文介绍 VectorChord 提供的用于衡量搜索性能和准确性的**基准测试 (benchmarking)** 工具。主要工具是 `bench.py`，它对 VectorChord 索引执行查询，并报告**召回率 (recall)**、**吞吐量 (throughput) / 每秒查询次数 (QPS)** 和**延迟 (latency)** 指标。  
  
## 概述 (Overview)  
  
基准测试系统通过对已索引的表执行一组测试查询，并将结果与**真实最近邻 (ground truth nearest neighbors)** 进行比较，来衡量**向量搜索 (vector search)** 性能。它支持**顺序执行 (sequential execution)**（带有详细的进度跟踪）和**并行执行 (parallel execution)**（用于测量最大吞吐量）。  
  
**来源:** [`scripts/bench.py` 1-267](https://github.com/tensorchord/VectorChord/blob/ac12e257/scripts/bench.py#L1-L267) [`scripts/README.md` 54-59](https://github.com/tensorchord/VectorChord/blob/ac12e257/scripts/README.md#L54-L59)  
  
## 基准测试工作流程 (Benchmark Workflow)  
  
![pic](20251102_04_pic_001.jpg)  
  
**来源:** [`scripts/bench.py` 27-56](https://github.com/tensorchord/VectorChord/blob/ac12e257/scripts/bench.py#L27-L56) [`scripts/bench.py` 235-267](https://github.com/tensorchord/VectorChord/blob/ac12e257/scripts/bench.py#L235-L267)  
  
## 数据集格式 (Dataset Format)  
  
基准测试需要一个包含测试查询和真实最近邻的 **HDF5** 文件。该文件必须具有以下结构：  
  
| 数据集键 (Dataset Key) | 形状 (Shape) | 描述 (Description) |  
| :--- | :--- | :--- |  
| `test` | `(m, dim)` | 测试查询向量，其中 `m` 是查询数量 |  
| `neighbors` | `(m, k)` | 每个查询的真实最近邻 ID (Ground truth nearest neighbor IDs) |  
  
**ANN Benchmarks** 仓库提供了示例数据集：  
  
```  
# Small datasets (1M vectors)  
wget http://ann-benchmarks.com/sift-128-euclidean.hdf5  
wget http://ann-benchmarks.com/gist-960-euclidean.hdf5  
  
# Large datasets (5M-100M vectors)  
wget https://myscale-datasets.s3.ap-southeast-1.amazonaws.com/laion-5m-test-ip.hdf5  
wget https://myscale-datasets.s3.ap-southeast-1.amazonaws.com/laion-100m-test-ip.hdf5  
```  
  
**来源:** [`scripts/README.md` 23-31](https://github.com/tensorchord/VectorChord/blob/ac12e257/scripts/README.md#L23-L31) [`scripts/bench.py` 240-242](https://github.com/tensorchord/VectorChord/blob/ac12e257/scripts/bench.py#L240-L242)  
  
## 命令行接口 (Command Line Interface)  
  
### 基本用法 (Basic Usage)  
  
```  
python scripts/bench.py \
  -n [table_name] \
  -i [dataset.hdf5] \
  -m [metric] \
  --nprob [probes] \
  --epsilon [epsilon] \
  --url postgresql://user:pass@localhost:5432/dbname  
```  
  
### 参数参考 (Arguments Reference)  
  
| 参数 (Argument) | 类型 (Type) | 默认值 (Default) | 描述 (Description) |  
| :--- | :--- | :--- | :--- |  
| `-n, --name` | string | required | 包含已索引向量的表名称 |  
| `-i, --input` | string | required | HDF5 数据集文件路径 |  
| `-m, --metric` | choice | `l2` | 距离度量 (Distance metric)：`l2` (L2距离)，`cos` (余弦相似度)，或 `dot` (内积) |  
| `--url` | string | required | PostgreSQL 连接 URL |  
| `-t, --top` | int | `10` | 要检索的结果数量 (10 或 100) |  
| `--nprob` | int | `100` | 针对 `vchordrq` 索引的探针数量 (Number of probes) |  
| `--epsilon` | float | `1.0` | `vchordrq` 搜索的 **Epsilon** 参数 |  
| `--processes` | int | `1` | 并行进程数 (1 表示顺序执行) |  
  
**来源:** [`scripts/bench.py` 27-55](https://github.com/tensorchord/VectorChord/blob/ac12e257/scripts/bench.py#L27-L55) [`scripts/README.md` 54-59](https://github.com/tensorchord/VectorChord/blob/ac12e257/scripts/README.md#L54-L59)  
  
## 距离度量和操作符 (Distance Metrics and Operators)  
  
该脚本将度量名称转换为 **PostgreSQL** 距离操作符 (distance operators)：  
  
![pic](20251102_04_pic_002.jpg)  
  
**来源:** [`scripts/bench.py` 244-251](https://github.com/tensorchord/VectorChord/blob/ac12e257/scripts/bench.py#L244-L251)  
  
## 连接配置 (Connection Configuration)  
  
`create_connection()` 函数建立了具有基准测试优化设置的连接：  
  
![pic](20251102_04_pic_003.jpg)  
  
**来源:** [`scripts/bench.py` 58-87](https://github.com/tensorchord/VectorChord/blob/ac12e257/scripts/bench.py#L58-L87)  
  
## 顺序基准测试 (Sequential Benchmarking)  
  
顺序模式 (`--processes 1`) 一次执行一个查询，并实时跟踪进度。此模式对于了解**每个查询的延迟分布 (per-query latency distribution)** 和监控查询执行时的召回率非常有用。  
  
### 顺序执行流程 (Sequential Execution Flow)  
  
![pic](20251102_04_pic_004.jpg)  
  
进度条输出包括运行指标：  
  
```  
recall: 0.9534 QPS: 28.45 P50: 35.12ms: 100%|████████| 10000/10000  
```  
  
**来源:** [`scripts/bench.py` 201-233](https://github.com/tensorchord/VectorChord/blob/ac12e257/scripts/bench.py#L201-L233)  
  
## 并行基准测试 (Parallel Benchmarking)  
  
并行模式 (`--processes > 1`) 将查询分配给多个工作进程，以测量最大吞吐量 (maximum throughput)。每个进程创建自己的数据库连接，并独立执行完整的查询集。  
  
### 并行执行架构 (Parallel Execution Architecture)  
  
![pic](20251102_04_pic_005.jpg)  
  
**来源:** [`scripts/bench.py` 110-136](https://github.com/tensorchord/VectorChord/blob/ac12e257/scripts/bench.py#L110-L136) [`scripts/bench.py` 164-199](https://github.com/tensorchord/VectorChord/blob/ac12e257/scripts/bench.py#L164-L199)  
  
## 指标计算 (Metrics Calculation)  
  
### 召回率 (Recall)  
  
召回率通过将检索结果与真实数据进行比较来衡量搜索准确性：  
  
```  
Recall = total_hits / (k × m × num_processes)  
```  
  
其中：  
  
  * `total_hits` = 所有查询中匹配 ID 的总和  
  * `k` = 请求的结果数量 (top-10 或 top-100)  
  * `m` = 测试查询的数量  
  * `num_processes` = 并行进程的数量  
  
对于每个查询，当检索到的 ID 出现在该查询的**真实邻居 (ground truth neighbors)** 中时，即计为一次“命中 (hit)”。  
  
**来源:** [`scripts/bench.py` 152-154](https://github.com/tensorchord/VectorChord/blob/ac12e257/scripts/bench.py#L152-L154)  
  
### QPS（每秒查询次数, Queries Per Second）  
  
**QPS** 衡量吞吐量。顺序模式和并行模式的计算有所不同：  
  
**顺序模式 (Sequential mode)：**  
  
```  
QPS = m / sum(latencies)  
```  
  
**并行模式 (Parallel mode)：**  
  
```  
QPS = (m × num_processes) / calculate_coverage(time_intervals)  
```  
  
`calculate_coverage()` 函数合并重叠的**时间间隔 (overlapping time intervals)** 以计算实际的**挂钟时间跨度 (wall-clock time span)**，从而考虑到并发查询执行。  
  
**来源:** [`scripts/bench.py` 139-162](https://github.com/tensorchord/VectorChord/blob/ac12e257/scripts/bench.py#L139-L162) [`scripts/bench.py` 90-107](https://github.com/tensorchord/VectorChord/blob/ac12e257/scripts/bench.py#L90-L107)  
  
### 时间覆盖率计算 (Time Coverage Calculation)  
  
![pic](20251102_04_pic_006.jpg)  
  
取所有worker process的开始时间最小值和结束时间最大值, 得到总时间跨度.  
  
**来源:** [`scripts/bench.py` 90-107](https://github.com/tensorchord/VectorChord/blob/ac12e257/scripts/bench.py#L90-L107)  
  
### 延迟百分位数 (Latency Percentiles)  
  
**P50** 和 **P99** 延迟是根据单个查询延迟的分布计算得出的：  
  
```  
latencies_ms = np.array(latencies) * 1000  # Convert to milliseconds  
p50 = np.percentile(latencies_ms, 50)     # Median  
p99 = np.percentile(latencies_ms, 99)     # 99th percentile  
```  
  
**来源:** [`scripts/bench.py` 156-160](https://github.com/tensorchord/VectorChord/blob/ac12e257/scripts/bench.py#L156-L160)  
  
## 查询执行细节 (Query Execution Details)  
  
每个查询执行一个标准的 **PostgreSQL** `ORDER BY` 查询：  
  
```  
SELECT id FROM {table_name}  
ORDER BY embedding {operator} %s  
LIMIT {k}  
```  
  
操作符取决于距离度量：  
  
  * L2 距离: `<->`  
  * 余弦相似度 (Cosine similarity): `<=>`  
  * 内积 (Inner product): `<#>`  
  
通过将检索结果和真实数据都转换为**集合 (sets)** 并计算**交集 (intersection)** 来进行比较：  
  
```  
result_ids = set([p[0] for p in result[:k]])  
ground_truth_ids = set(ground_truth[:k].tolist())  
hit = len(result_ids & ground_truth_ids)  
```  
  
**来源:** [`scripts/bench.py` 122-125](https://github.com/tensorchord/VectorChord/blob/ac12e257/scripts/bench.py#L122-L125) [`scripts/bench.py` 208-216](https://github.com/tensorchord/VectorChord/blob/ac12e257/scripts/bench.py#L208-L216)  
  
## 代码结构 (Code Structure)  
  
### 关键函数 (Key Functions)  
  
| 函数 (Function) | 目的 (Purpose) |  
| :--- | :--- |  
| `build_arg_parse()` | 使用 `argparse` 定义命令行参数 |  
| `create_connection()` | 建立具有优化设置的 **PostgreSQL** 连接 |  
| `process_batch()` | 用于并行执行的**工作函数 (Worker function)** |  
| `calculate_coverage()` | 为并行 **QPS** 合并重叠的时间间隔 |  
| `calculate_metrics()` | 从原始结果计算召回率、**QPS**、**P50**、**P99** |  
| `sequential_bench()` | 顺序执行查询并带有进度跟踪 |  
| `parallel_bench()` | 将查询分配给多个进程 |  
  
**来源:** [`scripts/bench.py` 1-267](https://github.com/tensorchord/VectorChord/blob/ac12e257/scripts/bench.py#L1-L267)  
  
### 数据流 (Data Flow)  
  
![pic](20251102_04_pic_007.jpg)  
  
**来源:** [`scripts/bench.py` 139-199](https://github.com/tensorchord/VectorChord/blob/ac12e257/scripts/bench.py#L139-L199)  
  
## 示例用法 (Example Usage)  
  
### 基本顺序基准测试 (Basic Sequential Benchmark)  
  
```  
python scripts/bench.py \
  -n sift \
  -i sift-128-euclidean.hdf5 \
  -m l2 \
  --nprob 100 \
  --epsilon 1.0 \
  --url postgresql://postgres:password@localhost:5432/postgres  
```  
  
输出：  
  
```  
Top: 10  
  Recall: 0.9534  
  QPS: 28.45  
  P50 latency: 35.12ms  
  P99 latency: 78.23ms  
```  
  
### 并行基准测试以实现吞吐量 (Parallel Benchmark for Throughput)  
  
```  
python scripts/bench.py \
  -n laion \
  -i laion-100m-test-ip.hdf5 \
  -m dot \
  --nprob 50 \
  --epsilon 1.5 \
  --processes 8 \
  --url postgresql://postgres:password@localhost:5432/postgres  
```  
  
### 召回率与速度的权衡 (Recall vs. Speed Tradeoff)  
  
测试不同的参数组合以探索召回率/速度的权衡：  
  
```  
# High recall, lower QPS  
python scripts/bench.py -n data -i dataset.hdf5 -m l2 --nprob 200 --epsilon 2.0  
  
# Balanced  
python scripts/bench.py -n data -i dataset.hdf5 -m l2 --nprob 100 --epsilon 1.5  
  
# High QPS, lower recall  
python scripts/bench.py -n data -i dataset.hdf5 -m l2 --nprob 50 --epsilon 1.0  
```  
  
**来源:** [`scripts/README.md` 54-59](https://github.com/tensorchord/VectorChord/blob/ac12e257/scripts/README.md#L54-L59)  
  
## 结果解读 (Interpreting Results)  
  
### 召回率 (Recall)  
  
  * **\> 0.95**: 准确性极佳，适合生产环境  
  * **0.90 - 0.95**: 适用于大多数应用的良好准确性  
  * **\< 0.90**: 可能需要参数调优或重建索引  
  
### QPS  
  
**QPS** 取决于：  
  
  * 硬件 (CPU, 内存, 磁盘)  
  * 数据集大小和**维度 (dimensionality)**  
  * 索引参数 (`--nprob`, `--epsilon`)  
  * 并行进程数 (Number of parallel processes)  
  
作为参考，VectorChord 在 100M 个 768 维向量上，通过适当的**水平扩展 (horizontal scaling)**，可实现 10,000+ **QPS**。  
  
### 延迟 (Latency)  
  
  * **P50**: 典型查询性能  
  * **P99**: 99% 查询的**最坏情况性能 (Worst-case performance)**  
  
较低的延迟表明：  
  
  * 更好的索引调优  
  * 有效的**预热 (prewarming)**  
  * 为热数据提供了足够的内存  
  
**来源:** [`README.md` 39-59](https://github.com/tensorchord/VectorChord/blob/ac12e257/README.md#L39-L59)  
  
## 性能调优 (Performance Tuning)  
  
连接设置应用了多项优化：  
  
| 设置 (Setting) | 值 (Value) | 目的 (Purpose) |  
| :--- | :--- | :--- |  
| `jit` | `false` | 禁用短查询的 **JIT** 编译开销 |  
| `effective_io_concurrency` | `200` | **预取 (prefetching)** 优化的提示 |  
| `vchordrq.probes` | configurable (可配置) | 要探测的 **IVF** 单元格数量 (Number of IVF cells to probe) |  
| `vchordrq.epsilon` | configurable (可配置) | **Reranking** 阈值乘数 |  
| `vchordrq_prewarm()` | called (调用) | 将索引页加载到**共享缓冲区 (shared buffers)** 中 |  
  
`vchordrq_prewarm()` 函数在基准测试开始前将索引页加载到 **PostgreSQL** 的**共享缓冲区池 (shared buffer pool)** 中，从而消除了**冷启动效应 (cold-start effects)**。  
  
**来源:** [`scripts/bench.py` 76-86](https://github.com/tensorchord/VectorChord/blob/ac12e257/scripts/bench.py#L76-L86)  
  
## 依赖项 (Dependencies)  
  
基准测试脚本需要：  
```  
import psycopg          # PostgreSQL driver  
import h5py             # HDF5 file reading  
import numpy as np      # Array operations, percentiles  
from pgvector.psycopg import register_vector  # pgvector type support  
from tqdm import tqdm   # Progress bars  
import multiprocessing as mp  # Parallel execution  
```  
  
使用以下命令安装：  
  
```  
pip install psycopg h5py numpy pgvector tqdm  
```  
  
**来源:** [`scripts/README.md` 6-14](https://github.com/tensorchord/VectorChord/blob/ac12e257/scripts/README.md#L6-L14) [`scripts/bench.py` 15-24](https://github.com/tensorchord/VectorChord/blob/ac12e257/scripts/bench.py#L15-L24)  
    
  
#### [期望 PostgreSQL|开源PolarDB 增加什么功能?](https://github.com/digoal/blog/issues/76 "269ac3d1c492e938c0191101c7238216")
  
  
#### [PolarDB 开源数据库](https://openpolardb.com/home "57258f76c37864c6e6d23383d05714ea")
  
  
#### [PolarDB 学习图谱](https://www.aliyun.com/database/openpolardb/activity "8642f60e04ed0c814bf9cb9677976bd4")
  
  
#### [PostgreSQL 解决方案集合](../201706/20170601_02.md "40cff096e9ed7122c512b35d8561d9c8")
  
  
#### [德哥 / digoal's Github - 公益是一辈子的事.](https://github.com/digoal/blog/blob/master/README.md "22709685feb7cab07d30f30387f0a9ae")
  
  
#### [About 德哥](https://github.com/digoal/blog/blob/master/me/readme.md "a37735981e7704886ffd590565582dd0")
  
  
![digoal's wechat](../pic/digoal_weixin.jpg "f7ad92eeba24523fd47a6e1a0e691b59")
  
