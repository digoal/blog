## 使用 pgcat 在 Postgres 中进行事务池化         
                                                
### 作者                                                
digoal                                                
                                                
### 日期                                                
2025-11-07                                               
                                                
### 标签                                                
PostgreSQL , DuckDB , 连接池 , pgcat , pgbouncer , 会话池化 , 事务池化 , 语句池化                    
                                                
----                                                
                                                
## 背景            
PG的连接池很多, 例如pgdog, pgcat, pgbouncer, pgpool-ii 等等, 还有其他不一一列举.    
    
连接池解决的问题通常是高并发的问题, 因为PG是进程模式, 如果应用同时开很多连接(但不是同时提出SQL请求)时, 可节省资源.     
    
连接池的池化模式通常有3种:    
- 会话, 会话释放后, 池里的连接才能释放共享给其他客户端    
- 事务, 事务结束即可释放共享给其他客户端. 以前这个模式很多功能不齐全, 现在都支持了, 例如会话层设置的变量、prepared statement等, 都支持了.      
- 语句, 语句结束即可释放共享给其他客户端    
    
现在用得最多的就是事务池化模式.    
    
下面看看“使用 pgcat 在 Postgres 中进行事务池化”, 了解一下事务池化都做了什么?     
    
原文: https://www.enterprisedb.com/blog/transaction-pooling-postgres-pgcat    
    
# 翻译    
    
## 使用 pgcat 在 Postgres 中进行事务池化     
    
**作者：** Phil Eaton    
**日期：** 2025年10月24日    
    
Postgres 为每个连接的客户端提供一个自己的进程，称为客户端后端（client backend）。由于担心 (1) 资源争用或 (2) 延迟，或 (3) 两者兼有，我们用户通常会将客户端连接的最大数量限制在几百个。然后我们会引入像 pgbouncer 或 pgcat 这样的连接池。这些连接池通过将许多客户端连接透明地多路复用到单个 Postgres 客户端后端上，可以处理更多的连接（且延迟更低）。但这是如何工作的？它的行为又是怎样的呢？    
    
让我们以 pgcat 为例来看一看。    
    
### 构建 Postgres 和 pgcat    
    
我本来希望能通过找到一个适用于 pgcat 和 Postgres 的良好 `docker-compose.yml` 来跳过考虑依赖和配置。pgcat 仓库里有一个，但我没能让它工作，可能是因为我用的是 podman 而不是 docker。我也找不到其他能用的 `docker-compose.yaml` 文件。所以，我们直接从源代码构建 Postgres 和 pgcat，避免 docker/podman 权限问题。    
    
```bash    
$ git clone https://github.com/postgres/postgres     
$ cd postgres     
$ git checkout REL_18_STABLE     
$ ./configure --without-icu \
 --prefix=$(pwd)/build \
 --libdir=$(pwd)/build/lib     
$ make -j16 && make install    
```    
    
然后创建一个实例并启动它，同时为你的用户添加一个密码（pgcat 似乎需要这个）。    
    
```bash    
$ ./build/bin/initdb testdb     
$ ./build/bin/pg_ctl -D $(pwd)/testdb -l logfile start     
$ ./build/bin/psql postgres -c "ALTER USER $(whoami) WITH PASSOWRD '$(whoami)'"    
```    
    
现在我们来获取并构建 pgcat。    
    
```bash    
$ git clone https://github.com/postgresml/pgcat     
$ cd pgcat     
$ cargo build    
```    
    
pgcat 需要一个配置文件，但仓库中自带的配置文件涉及的功能太多了，我只想要一个最小化的配置。所以我从一个空文件开始，不断添加设置，直到 pgcat 不再报错缺少设置，最终得到了这个 `pgcat.toml` 文件：    
    
```bash    
echo '     
 [general] admin_username = "$(whoami)" # Must be set but we won't use this. admin_password = "" # Must be set but can be blank. port = 6432     
 [pools.postgres.shards.0] servers = [["localhost", 5432, "primary"]] database = "postgres"     
 [pools.postgres.users.0] username = "$(whoami)" password = "$(whoami)" pool_size = 1 ' > pgcat.toml    
```    
    
我们告诉 pgcat 如何以及在哪里连接，以及 pgcat 自身应该在端口 `6432` 运行。在本文的其余部分，我们将只调整 `pool_size` 这一个设置。我们会在后面详细说明。    
    
启动 pgcat：    
    
```bash    
$ ./target/debug/pgcat pgcat.toml    
```    
    
### pool\_size = 1    
    
现在我们有 Postgres 在运行，也有 pgcat 在运行。让我们用 psql REPL 连接到 pgcat（回到我们克隆的 Postgres 仓库的根目录）：    
    
```bash    
$ PGPASSWORD=$(whoami) ./build/bin/psql -h localhost -p 6432 postgres     
psql (18rc1)     
Type "help" for help.     
postgres=#    
```    
    
pgcat 正在拦截客户端 (psql) 和 Postgres 客户端后端之间的所有交互。但是从客户端本身很难分辨出我们是连接到了连接池还是直接连接到了 Postgres。    
    
让我们编辑这个会话的 psql 提示符，以便在我们添加更多会话时更容易区分它们。    
    
```sql    
postgres=# \set PROMPT1 '[client1] %/%R%x%# '    
[client1] postgres=# \set PROMPT2 '[client1] %/%R%x%# '    
[client1] postgres=#    
```    
    
现在我们运行一个简单的查询。    
    
```sql    
[client1] postgres=# SELECT 'hello world';    
 ?column?     
-------------     
 hello world     
(1 row)    
```    
    
现在我们检查一下实际执行我们查询的 Postgres 客户端后端进程 ID (PID)。    
    
```sql    
[client1] postgres=# SELECT pg_backend_pid();    
 pg_backend_pid     
----------------     
 19584     
(1 row)    
```    
    
现在我们做一些会话本地的事情，改变我们的时区。我在纽约，所以我的时区是 `America/New_York`。    
    
```sql    
[client1] postgres=# SHOW timezone;    
 TimeZone     
------------------     
 America/New_York     
(1 row)    
```    
    
我们把它改为 `America/Los_Angeles`。    
    
```sql    
[client1] postgres=# SET timezone TO 'America/Los_Angeles';    
 SET     
[client1] postgres=# SHOW timezone;    
 TimeZone     
---------------------     
 America/Los_Angeles     
(1 row)    
```    
    
保持这个 psql 会话打开，并在另一个终端打开另一个 psql 会话。    
    
```bash    
$ PGPASSWORD=$(whoami) ./build/bin/psql -h localhost -p 6432 postgres     
psql (18rc1)     
Type "help" for help.     
postgres=#    
```    
    
我们也为这个会话设置提示符来区分它。    
    
```sql    
postgres=# \set PROMPT1 '[client2] %/%R%x%# '    
[client2] postgres=# \set PROMPT2 '[client2] %/%R%x%# '    
[client2] postgres=#    
```    
    
在 client2 中，时区应该是 `America/New_York`，因为这是默认值。    
    
```sql    
[client2] postgres=# SHOW timezone;    
 TimeZone     
------------------     
 America/New_York     
(1 row)    
```    
    
现在检查 Postgres 客户端后端 PID。    
    
```sql    
[client2] postgres=# SELECT pg_backend_pid();    
 pg_backend_pid     
----------------     
 19584     
(1 row)    
```    
    
太酷了！在 Postgres 中，这本不应该发生！如果我是直接连接到 Postgres，这些 PID 将是唯一的。每个客户端一个进程。但我们正在跨客户端共享同一个进程。    
    
回头检查 client1 中的时区设置，确保它没有以某种方式被重置。    
    
```sql    
[client1] postgres=# SHOW timezone;    
 TimeZone     
---------------------     
 America/Los_Angeles     
(1 row)    
```    
    
仍然是它自己的值。因此，除其他外，连接池使得它看起来好像我们有自己的会话，就像每个客户端都有自己唯一的 Postgres 客户端后端一样，即使我们有多个客户端共享同一个 Postgres 客户端后端。    
    
### 共享就是... 关爱？    
    
这些连接池的基本工作方式是有一个开放的 Postgres 客户端后端连接池。在事务池化模式下，它会从池中获取一个客户端后端连接，并在事务结束后释放它。Postgres 中的每个语句都是一个事务，因此每个客户端只在语句执行期间占用池中的连接。    
    
如果一个客户端运行了一个需要一段时间才能执行完成的语句，它可能会使其他客户端无法访问池中的连接。我们最容易看到这种情况是因为我们设置了 `pool_size = 1`，所以连接池只允许有一个开放的 Postgres 客户端后端。    
    
例如，让我们在 client2 上调用 `pg_sleep(15)` 持续 15 秒。它会看起来挂起 15 秒然后返回：    
    
```sql    
[client2] postgres=# SELECT pg_sleep(15);    
 pg_sleep     
----------     
     
(1 row)    
```    
    
在 client2 上敲下 Enter 后，立即在 client1 上运行一个 `SELECT 1`。client1 会挂起几秒钟，然后返回一个错误：    
    
```sql    
[client1] postgres=# SELECT 1;    
 FATAL: could not get connection from the pool - AllServersDown    
```    
    
但是一旦 client2 的 sleep 完成并且语句执行完毕，client1 将能够再次运行命令。    
    
```sql    
[client1] postgres=# SELECT 1;    
 FATAL: could not get connection from the pool - AllServersDown    
-- 稍后 --    
[client1] postgres=# SELECT 1;    
 ?column?     
----------     
 1     
(1 row)    
```    
    
这很合理！我们共享了同一个 Postgres 客户端后端！    
    
你可能会说，长时间运行的语句是不好的做法。确实如此。那我们来试试交互式事务。    
    
在 client1 上，用 `BEGIN` 开始一个交互式事务。    
    
```sql    
[client1] postgres=# BEGIN;    
 BEGIN     
[client1] postgres=*#    
```    
    
然后在 client2 上尝试运行一个 `SELECT 1`：    
    
```sql    
[client2] postgres=# select 1;    
 FATAL: could not get connection from the pool - AllServersDown    
```    
    
它挂起并失败了。现在我们在 client1 的事务中运行一个查询，然后提交它。    
    
```sql    
[client1] postgres=# BEGIN;    
 BEGIN     
[client1] postgres=*# SELECT 1;    
 ?column?     
----------     
 1     
(1 row)     
[client1] postgres=*# COMMIT;    
 COMMIT    
```    
    
现在回到 client2，一旦 client1 的事务完成，我们就可以再次访问 Postgres 客户端后端了。    
    
```sql    
[client2] postgres=# SELECT 1;    
 FATAL: could not get connection from the pool - AllServersDown    
-- client1 提交后    
[client2] postgres=# SELECT 1;    
 ?column?     
----------     
 1     
(1 row)    
```    
    
在我看来，只允许一个 Postgres 客户端后端时，这种行为玩起来很有趣。但现在让我们看看如果允许不止一个客户端后端会发生什么。    
    
### pool\_size = 2    
    
在我们上面修改的 `pgcat.toml` 中，在 pgcat 仓库内，将 `pool_size` 从 1 改为 2。然后 `Ctrl-c` 停止 pgcat 服务器并再次运行它。关闭两个 psql 会话并启动两个新的会话。给它们设置相同的提示符前缀 `[client1]` 和 `[client2]`。    
    
查看 client1 当前的 Postgres 客户端后端 PID 是多少。（它会改变，因为我们重启了连接池。）    
    
```bash    
$ PGPASSWORD=$(whoami) ./build/bin/psql -h localhost -p 6432 postgres     
psql (18rc1)     
Type "help" for help.     
postgres=# \set PROMPT1 '[client1] %/%R%x%# '     
[client1] postgres=# \set PROMPT2 '[client1] %/%R%x%# '     
[client1] postgres=# SELECT pg_backend_pid();    
 pg_backend_pid     
----------------     
 20809     
(1 row)    
```    
    
对 client2 也做同样的操作：    
    
```bash    
$ PGPASSWORD=$(whoami) ./build/bin/psql -h localhost -p 6432 postgres     
psql (18rc1)     
Type "help" for help.     
postgres=# \set PROMPT2 '[client2] %/%R%x%# '     
postgres=# \set PROMPT1 '[client2] %/%R%x%# '     
[client2] postgres=# SELECT pg_backend_pid();    
 pg_backend_pid     
----------------     
 20809     
(1 row)    
```    
    
所以即使我们允许 pgcat 使用不止一个 Postgres 客户端后端，它仍然只使用一个，这很有趣。当然，我们此刻所做的任何观察都只是观察而已。连接池如何选择实现其池化策略，很可能不属于其公共 API 的一部分。尽管如此，让我们来探究一下它的行为。    
    
现在如果我们有一个阻塞的客户端连接会发生什么？如果我们在 client2 上启动一个交互式事务：    
    
```sql    
[client2] postgres=# BEGIN;    
 BEGIN     
[client2] postgres=*# SELECT pg_backend_pid();    
 pg_backend_pid     
----------------     
 20809     
(1 row)    
```    
    
仍然是之前的那一个。保持这个事务开放。    
    
然后 client1 上执行一个简单的 `SELECT 1`：    
    
```sql    
[client1] postgres=# SELECT 1;    
 ?column?     
----------     
 1     
(1 row)    
```    
    
它成功了！让我们看看 client1 运行在哪个客户端后端 PID 上。    
    
```sql    
[client1] postgres=# SELECT pg_backend_pid();    
 pg_backend_pid     
----------------     
 21004     
(1 row)    
```    
    
不是之前的那一个！因此，由于一个客户端阻塞了一个连接的使用，并且 `pool_size` 允许更多连接，pgcat 打开了一个新的 Postgres 客户端后端供客户端连接使用。    
    
现在让我们在 client2 上提交事务，并检查该事务完成后它拥有的 Postgres 客户端后端 PID。    
    
```sql    
[client2] postgres=# BEGIN;    
 BEGIN     
[client2] postgres=*# SELECT pg_backend_pid();    
 pg_backend_pid     
----------------     
 20809     
(1 row)     
[client2] postgres=*# COMMIT;    
 COMMIT     
[client2] postgres=# SELECT pg_backend_pid();    
 pg_backend_pid     
----------------     
 21004     
(1 row)    
```    
    
它变了！让我们再检查一次。再检查一次。又检查一次。    
    
```sql    
[client2] postgres=#     
[client2] postgres=# SELECT pg_backend_pid();    
 pg_backend_pid     
----------------     
 20809     
(1 row)     
[client2] postgres=# SELECT pg_backend_pid();    
 pg_backend_pid     
----------------     
 21004     
(1 row)     
[client2] postgres=# SELECT pg_backend_pid();    
 pg_backend_pid     
----------------     
 20809     
(1 row)    
```    
    
client1 也是一样。    
    
```sql    
[client1] postgres=# SELECT pg_backend_pid();    
 pg_backend_pid     
----------------     
 21004     
(1 row)     
[client1] postgres=# SELECT pg_backend_pid();    
 pg_backend_pid     
----------------     
 20809     
(1 row)     
[client1] postgres=# SELECT pg_backend_pid();    
 pg_backend_pid     
----------------     
 21004     
(1 row)    
```    
    
所以基本上，逻辑似乎是：客户端将（随机地？）从现有连接池中拉取连接，并且在所有现有连接都被阻塞之前不会创建新的连接。每个客户端可能在每个事务中都使用一个完全不同的 Postgres 客户端后端来运行其事务。    
    
这相当巧妙！    
    
### 预备语句(prepared statement)及其他高级功能    
    
我们只关注了连接池的绝对基础知识。即便如此，我仍然想尝试更多连接池（pgbouncer、odyssey、pgpool-ii 等），看看它们的行为是否都一样，或者是否也能像我为 pgcat 所做的那样搭建一个最小工作环境。    
    
各种连接池支持（例如，事务模式下的预备语句(prepared statement)）和不支持/不能支持（例如，事务模式下的 LISTEN/NOTIFY）许多高级功能，在本文中我将忽略这些。    
    
### 那么会话池化呢？    
    
连接池可能支持多种池化模式，而不仅仅是事务池化。它们可能还支持会话池化（session pooling）和语句池化（statement pooling，我不会深入探讨）。    
    
在会话池化中，每个客户端连接都映射到一个单一的 Postgres 客户端后端。就像直接连接到 Postgres 一样。这意味着像 LISTEN/NOTIFY 这样的功能可以正常工作。不同之处在于，连接池不会在客户端连接结束时允许 Postgres 客户端后端退出，而是会保留该 Postgres 客户端后端，并将其重复用于未来的客户端连接。    
    
会话池化有助于避免建立连接的延迟，甚至可以帮助扩展客户端连接的数量，因为连接池会在可配置的超时时间内对连接进行排队，而 Postgres 在达到 `max_connections` 开放连接数后会立即拒绝连接。它在扩展客户端连接数量方面不如事务池化有效，但仍然是一种改进。    
    
基本上，连接池默认使用事务池化，因为这种模式可以处理更多的连接。当用户需要事务池化无法实现的功能或行为时，他们会切换到会话池化。    
         
#### [PolarDB 学习图谱](https://www.aliyun.com/database/openpolardb/activity "8642f60e04ed0c814bf9cb9677976bd4")
  
  
#### [PostgreSQL 解决方案集合](../201706/20170601_02.md "40cff096e9ed7122c512b35d8561d9c8")
  
  
#### [德哥 / digoal's Github - 公益是一辈子的事.](https://github.com/digoal/blog/blob/master/README.md "22709685feb7cab07d30f30387f0a9ae")
  
  
#### [About 德哥](https://github.com/digoal/blog/blob/master/me/readme.md "a37735981e7704886ffd590565582dd0")
  
  
![digoal's wechat](../pic/digoal_weixin.jpg "f7ad92eeba24523fd47a6e1a0e691b59")
  
