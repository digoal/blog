## PostGIS 性能优化系列文章: 空间裁剪优化, 相交谓词与叠加操作(Intersection Predicates and Overlays)    
                                      
### 作者                                      
digoal                                      
                                      
### 日期                                      
2025-11-21                                      
                                      
### 标签                                      
PostgreSQL , PostGIS , 性能优化                                         
                                      
----                                      
                                      
## 背景       
空间裁剪告别低效, 解锁 PostGIS 的极致性能!    
  
在地理空间数据处理领域，**PostGIS** 是无数开发者和分析师手中的利器。然而，面对海量数据 —— 无论是进行大规模的边界**裁剪**（clipping）、计算复杂的**交集**（Intersection），还是执行繁琐的**叠加操作**（Overlays） ——  您是否也曾遭遇**查询速度缓慢**、系统资源被**过度消耗**的痛点？标准的空间连接和求交方法虽然直观，但在处理数百万个地块或多边形时，其性能瓶颈往往令人望而却步。  
  
**您的痛点：** 每次执行 **ST_Intersection** 等复杂的空间叠加函数时，您的数据库都在进行大量不必要的几何运算，导致应用响应迟缓，用户体验大打折扣。难道就没有一种简单、高效的方法来解决这个问题吗？  
  
**解决方案就在眼前！**    
  
本文将为您揭示一个鲜为人知但 **效果惊人** 的 **PostGIS 性能优化模式** 。这个模式的核心在于：巧妙利用速度更快的 **布尔空间谓词**（Boolean Spatial Predicates）作为“**高性能快捷路径**”，来**取代**在大多数情况下都是多余的、计算成本高昂的**空间叠加操作** 。通过一个简单的 **CASE 语句**技巧，您将学会如何将您的几何图形智能地划分为“快速通过”和“必须裁剪”两个流，从而让昂贵的计算只在绝对必要时才执行。  
  
想知道如何用一个简单优雅的 SQL 模式，将您的空间查询速度提升 **30% 甚至更多** 吗？请继续阅读，掌握这个专家级的优化秘诀，让您的 **PostGIS** 系统真正飞驰起来！  
  
以下内容来自:    
- https://www.crunchydata.com/blog/postgis-performance-intersection-predicates-and-overlays  
  
## PostGIS 性能：相交谓词与叠加操作 (PostGIS Performance: Intersection Predicates and Overlays)  
  
在这个系列中，我们将讨论各种可以加速 **PostGIS** 的方法。一个常见的地理空间操作是裁剪（**clipping**）出一个集合，其中包含在一个更大形状内的较小形状。今天，我们来回顾一下查询某个事物内部包含哪些事物的最有效方法。  
  
![pic](20251121_10_pic_001.avif)  
  
通常，较小的形状会在它们跨越边界的地方被裁剪，使用 **ST\_Intersection**（交集）函数。  
  
![pic](20251121_10_pic_002.avif)  
  
以下 SQL 是一个简单的基于 **ST\_Intersects**（相交）的空间连接（**spatial join**）：  
  
```sql  
SELECT ST_Intersection(polygon.geom, p.geom) AS geom  
  FROM parcels p  
  JOIN polygon  
    ON ST_Intersects(polygon.geom, p.geom);  
```  
  
当在一个小测试区域上运行时，这个查询大约耗时 14 毫秒（14ms）。这很快，但问题规模很小，更大的操作将会更慢。  
  
有一个简单的方法可以加快查询速度，它利用了布尔空间谓词（**boolean spatial predicates**）比空间叠加操作（**spatial overlay operations**）更快的优势。  
  
此话怎讲？  
  
“布尔空间谓词”（**Boolean spatial predicates**）是像 **ST\_Intersects** 和 **ST\_Contains**（包含）这样的函数。它们接受两个几何图形，并返回“真”（**true**）或“假”（**false**），表示这些几何图形是否通过了指定的测试。  
- https://postgis.net/docs/ST_Intersects.html  
- https://postgis.net/docs/ST_Contains.html  
  
“空间叠加操作”（**Spatial overlay operations**）是像 **ST\_Intersection** 或 **ST\_Difference**（差异）这样的函数，它们接受两个几何图形，并根据指定的规则生成一个新的几何图形。  
- https://postgis.net/docs/ST_Intersection.html  
- https://postgis.net/docs/ST_Difference.html  
  
谓词（**Predicates**）之所以更快，是因为它们的测试通常允许逻辑短路（**logical short circuits**）（一旦发现任意两条边相交，你就知道几何图形相交了），并且它们可以利用预处理几何（**prepared geometry**）的优化来缓存（**cache**）和索引（**index**）函数调用之间的边界。  
- https://libgeos.org/doxygen/classgeos_1_1geom_1_1prep_1_1PreparedGeometry.html  
  
空间叠加（**spatial overlay**）的速度提升只是观察到一个事实：对于大多数叠加操作，有一大组要素可以原封不动地添加到结果集中——即那些完全包含在裁剪形状中的要素。我们可以使用 **ST\_Contains** 来识别它们。  
  
![pic](20251121_10_pic_003.avif)  
  
同样，有一小部分要素跨越了边界，因此确实需要被裁剪。这些要素是满足 **ST\_Intersects** 但不满足 **ST\_Contains** 的要素。  
  
![pic](20251121_10_pic_004.avif)  
  
这种更高性能的函数使用更快的谓词（**predicates**）将较小的形状过滤成两个流：一个用于求交集（**intersection**），一个用于保持不变的包含（**inclusion**）。  
  
```sql  
SELECT  
  CASE  
    WHEN ST_Contains(polygon.geom, p.geom) THEN p.geom  
    ELSE ST_Intersection(polygon.geom, p.geom)  
    END AS geom  
  FROM parcels p  
  JOIN polygon  
    ON ST_Intersects(polygon.geom, p.geom);  
```  
  
这里使用了两个谓词：  
  
1.  连接子句中的 **ST\_Intersects** 确保只有可能参与叠加操作（**overlay**）的地块（**parcels**）被送入 **CASE 语句**（CASE statement）。  
2.  在 **CASE 语句** 中，**ST\_Contains** 谓词对那些不跨越边界的地块执行无操作（**no-ops**），即直接返回原始几何。  
  
在我们的微小示例上运行时，该查询仅在 9 毫秒（9ms）内执行完成。令人惊讶的是，在这样一个小型示例上，差异也大到足以测量。  
  
### 使用 CASE 语句结合谓词和叠加操作  
  
这里的核心思想是认识到像 **ST\_Contains** 和 **ST\_Intersects** 这样的布尔空间谓词（**boolean spatial predicates**），在计算上比像 **ST\_Intersection** 这样的空间叠加操作（**spatial overlay operations**）快得多。  
  
标准但缓慢的方法会裁剪所有相交的要素。优化的方法使用 **CASE 语句** 和 **ST\_Contains** 检查来创建一个**快捷路径**（shortcut）：如果一个较小的几何图形完全包含在较大的裁剪多边形内，我们就返回未更改的几何图形（一个快速的无操作/no-op），并完全绕过较慢的 **ST\_Intersection** 计算。  
  
您可以将这种优化模式应用于涉及裁剪（**clipping**）、空间连接（**spatial joins**）或叠加操作（**overlays**）的任何 **PostGIS** 工作中，只要您怀疑有大量要素可能被边界完全包含。通过将几何图形过滤并划分为“完全包含”（**fully contained**）（快速路径）和“跨越边界”（**crossing the border**）（慢速路径）两个流，您确保只有在严格必要裁剪边缘时，才会执行昂贵的叠加操作。  
       
#### [PolarDB 学习图谱](https://www.aliyun.com/database/openpolardb/activity "8642f60e04ed0c814bf9cb9677976bd4")
  
  
#### [PostgreSQL 解决方案集合](../201706/20170601_02.md "40cff096e9ed7122c512b35d8561d9c8")
  
  
#### [德哥 / digoal's Github - 公益是一辈子的事.](https://github.com/digoal/blog/blob/master/README.md "22709685feb7cab07d30f30387f0a9ae")
  
  
#### [About 德哥](https://github.com/digoal/blog/blob/master/me/readme.md "a37735981e7704886ffd590565582dd0")
  
  
![digoal's wechat](../pic/digoal_weixin.jpg "f7ad92eeba24523fd47a6e1a0e691b59")
  
