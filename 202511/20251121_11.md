## Spock ：PostgreSQL 的多主复制插件  
                                        
### 作者                           
digoal                            
                    
### 日期                          
2025-11-21                              
                                        
### 标签                            
PostgreSQL , multi-master , logical replication , DDL                       
                                        
----                                        
                                        
## 背景    
Spock 是一个 **PostgreSQL 扩展**，专为实现 **多主（Multi-Master）复制** 而设计。它允许集群中的**多个节点**同时接受读写操作，并在它们之间同步数据更改。  
  
https://github.com/pgEdge/spock  
  
### 主要特点  
  
* **多主复制 (Multi-Master Replication)**：这是 Spock 的核心功能。集群中的所有节点都可以作为主节点，接受写入并相互复制数据更改，从而提高写入可用性和性能。  
* **基于逻辑解码 (Logical Decoding)**：Spock 利用 PostgreSQL 的逻辑解码特性来捕获数据更改，从而实现高效和灵活的复制。  
* **冲突解决 (Conflict Resolution)**：在多主环境中，当不同节点同时修改同一行数据时，Spock 提供了内置的机制来检测和解决冲突。  
* **自动 DDL 复制 (Automatic DDL Replication)**：它可以自动复制数据定义语言 (DDL) 更改，如 `CREATE TABLE` 或 `ALTER TABLE`，从而简化集群管理。  
* **兼容性**：支持 **PostgreSQL 15 及更高版本**。  
  
简而言之，Spock 提供了一种健壮且高可用的方式来构建分布式 PostgreSQL 数据库集群。  
  
## Spock 用于 PostgreSQL 的多主复制 - 先决条件和要求  
  
Spock 扩展为 **PostgreSQL 15 及更高版本**提供多主复制。在设计集群时，请考虑以下要求：  
  
  * 您需要在集群中的**每个节点**上安装 **`Spock` 扩展**。如果您正在执行主版本升级，旧节点可以运行最新版本的 pgLogical2，然后再升级为 Spock 节点。  
  
  * 在集群中的**每个节点**上，**表必须具有相同的名称并位于相同的schema中**。要检查现有表的表名和schema名，您可以连接到数据库，使用 **`psql`** 和 **`\d`** 元命令：  
  
    `SELECT schemaname, tablename FROM pg_tables ORDER BY schemaname, tablename;`  
  
    例如：  
  
    ```sql  
    lcdb=# \d  
                   List of relations  
     Schema |      Name      |   Type   |  Owner  
    --------+----------------+----------+----------  
     public | table_a        | table    | ec2-user  
     public | table_a_id_seq | sequence | ec2-user  
     public | table_b        | table    | ec2-user  
     public | table_b_id_seq | sequence | ec2-user  
     public | table_c        | table    | ec2-user  
     public | table_c_id_seq | sequence | ec2-user  
    (6 rows)  
    ```  
  
  * **每个表**还必须具有**相同的列和主键**，并且**每列**具有**相同的数据类型**。要查看特定模式中所有表的详细信息，请连接到数据库，使用 psql 和 **`\d schema_name.*`** 命令；例如：  
  
    ```sql  
    lcdb=# \d public.*  
                                       Table "public.table_a"  
       Column   |           Type           | Collation | Nullable |           Default  
    ------------+--------------------------+-----------+----------+------------------------------  
     id         | bigint                   |           | not null | generated always as identity  
     name       | text                     |           | not null |  
     qty        | integer                  |           | not null |  
     created_at | timestamp with time zone |           | not null | now()  
    Indexes:  
        "table_a_pkey" PRIMARY KEY, btree (id)  
  
                           Sequence "public.table_a_id_seq"  
      Type  | Start | Minimum |       Maximum       | Increment | Cycles? | Cache  
    --------+-------+---------+---------------------+-----------+---------+-------  
     bigint |     1 |       1 | 9223372036854775807 |         1 | no      |     1  
    Sequence for identity column: public.table_a.id  
  
         Index "public.table_a_pkey"  
     Column |  Type  | Key? | Definition  
    --------+--------+------+------------  
     id     | bigint | yes  | id  
    primary key, btree, for table "public.table_a"  
    ...  
    ```  
  
  * 充当**仅**订阅者的任何备用节点上的 **`CHECK` 约束**和 **`NOT NULL` 约束**必须**相同或更宽松**。  
  
## 构建 Spock 扩展  
  
您需要在已修补的 **PostgreSQL 源代码树**上构建 Spock 扩展，该源代码树已应用了 **`spock/patches/Postgres-version`** 目录中针对特定版本的 **`.diff` 文件**。构建 Postgres 和 Spock 扩展的高级步骤如下：  
  
1.  获取 [Postgres 源代码](https://www.postgresql.org/docs/current/install-getsource.html)。  
  
2.  将补丁文件复制到基本仓库；每个 Postgres 版本的补丁都在 [spock 仓库](https://github.com/pgEdge/spock/tree/main/patches)中特定于版本的子目录中。然后，应用每个补丁，使用命令：  
  
    `patch -p1 < path_to_patch/patch_name`  
  
    请注意，您**必须**按照它们在 `spock` 仓库中前缀指定的**数字顺序**应用补丁（例如，先是 `pg16-015-patch-name`，然后是 `pg16-020-patch-name`，然后是 `pg16-025-patch-name`）。  
  
3.  按照 [PostgreSQL 文档](https://www.postgresql.org/docs/current/install-make.html)中的说明，**`configure`**、**`make`** 和 **`make install`** Postgres 服务器。  
  
4.  构建完成后，将您的 **`pg_config` 文件**的位置添加到您的 **`PATH` 变量**中：  
  
    `export PATH=path_to_pg_config_file`  
  
5.  然后，克隆 **`pgedge/spock`** 仓库：  
  
    `git clone https://github.com/pgEdge/spock.git`  
  
6.  接下来，**`make`** 然后 **`make install`** spock。  
  
7.  然后，更新您的 Postgres **`postgresql.conf` 文件**，设置：  
  
    ```bash  
    shared_preload_libraries = 'spock'  
    track_commit_timestamp = on # needed for conflict resolution  
    ```  
  
8.  然后，连接到服务器，并使用 **`CREATE EXTENSION` 命令**在您希望复制的数据库中的**每个节点**上创建 spock 扩展：  
  
    `CREATE EXTENSION spock;`  
  
### 基本配置和使用  
  
在配置复制集群之前，您需要在集群的**每个节点**上执行以下步骤：  
  
  * 构建 Postgres 和 Spock，并创建 Spock 扩展。  
  * 初始化**相同的数据库**。  
  * 修改 **`postgresql.conf` 文件**以支持**逻辑解码**和**自动 DDL 复制**。  
  * 修改 **`pg_hba.conf` 文件**和任何防火墙，以确保节点之间具有**连通性**。  
  
**配置设置**  
  
修改 **`postgresql.conf` 文件**，添加：  
  
```  
wal_level = 'logical'  
max_worker_processes = 10   # 供应商节点上每个数据库需要一个  
                            # 订阅者节点上每个节点需要一个  
max_replication_slots = 10  # 供应商节点上每个节点需要一个  
max_wal_senders = 10        # 供应商节点上每个节点需要一个  
shared_preload_libraries = 'spock'  
track_commit_timestamp = on # 解决冲突所需  
```  
  
您还需要在**每个节点**上启用**自动 DDL 复制**；将这些 GUC 也添加到 **`postgresql.conf` 文件**中：  
  
```  
spock.enable_ddl_replication=on  
spock.include_ddl_repset=on  
```  
  
您还需要配置您的 **`pg_hba.conf` 文件**以允许节点之间的连接，并确保防火墙不会阻止访问。逻辑复制连接被 `pg_hba.conf` 视为对供应商数据库的常规连接。  
  
修改配置文件后，**重启** Postgres 服务器；例如：  
  
`pg_ctl -D /path/to/data_directory restart`  
  
**配置复制**  
  
首先，我们将在集群中的**每个节点**上调用 **`spock.node_create` 命令**。例如，以下命令创建一个名为 **`n1`** 的节点，可通过 `dsn` 变量指定的连接字符串访问：  
  
```  
SELECT spock.node_create(  
    node_name := 'n1',  
    dsn := 'host=10.0.0.5 port=5432 dbname=acctg'  
);  
```  
  
使用以下命令创建名为 **`n2`** 的节点：  
  
```  
SELECT spock.node_create(  
    node_name := 'n2',  
    dsn := 'host=10.0.0.7 port=5432 dbname=acctg'  
);  
```  
  
接下来，创建节点之间的**订阅**。由于这是多主复制，因此**每个节点**都充当**订阅者**和**供应商**。第一个命令创建 `n1` 和 `n2` 之间的订阅：  
  
```  
SELECT spock.sub_create(  
    subscription_name := 'sub_n1n2',  
    provider_dsn := 'host=10.0.0.7 port=5432 dbname=acctg'  
);  
```  
  
在 `n1` 上调用的命令指定了订阅名称（`sub_n1n2`）以及它订阅的节点的连接字符串（`n2`）。接下来，在 `n2` 上创建一个连接到 `n1` 的订阅：  
  
```  
SELECT spock.sub_create(  
    subscription_name := 'sub_n2n1',  
    provider_dsn := 'host=10.0.0.5 port=5432 dbname=acctg'  
);  
```  
  
要**启动复制**，我们将使用 **[pgbench](https://www.postgresql.org/docs/current/pgbench.html)** 添加表；由于我们启用了**自动 DDL 复制**，我们将在 `n1` 上添加表，它们将**自动传播**到 `n2`：  
  
```  
/path to pgbench/pgbench -i -s 10 acctg  
```  
  
然后，要确认复制，您可以连接到 **`n1`** 和 **`n2`**，使用 psql 检查 pgbench 表。  
  
```  
psql (17.x)  
Type "help" for help.  
  
bench=# \dt  
               List of relations  
 Schema |       Name        | Type  |  Owner  
--------+-------------------+-------+---------  
 public | pgbench_accounts  | table | postgres  
 public | pgbench_branches  | table | postgres  
 public | pgbench_history   | table | postgres  
 public | pgbench_tellers   | table | postgres  
(4 rows)  
```  
  
    
#### [PolarDB 学习图谱](https://www.aliyun.com/database/openpolardb/activity "8642f60e04ed0c814bf9cb9677976bd4")
  
  
#### [PostgreSQL 解决方案集合](../201706/20170601_02.md "40cff096e9ed7122c512b35d8561d9c8")
  
  
#### [德哥 / digoal's Github - 公益是一辈子的事.](https://github.com/digoal/blog/blob/master/README.md "22709685feb7cab07d30f30387f0a9ae")
  
  
#### [About 德哥](https://github.com/digoal/blog/blob/master/me/readme.md "a37735981e7704886ffd590565582dd0")
  
  
![digoal's wechat](../pic/digoal_weixin.jpg "f7ad92eeba24523fd47a6e1a0e691b59")
  
