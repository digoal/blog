## AI 纠正了我的愚蠢: 如何让PG自定义聚合函数的finalfunc仅执行一次?   
        
### 作者        
digoal        
        
### 日期        
2025-12-01       
        
### 标签        
AI , PostgreSQL , 自定义聚合 , finalfunc    
        
----        
        
## 背景    
今天, IF club 群里发了一个问题: 如何让PostgreSQL自定义聚合函数的finalfunc仅执行一次?    
  
在我的碳基神经元还停留在过去式, 记忆也出现了混乱, 也没有去看最新文档(没有使用RAG)的情况下, 非常自信的回答了:   
  
“应该是该聚合函数没有实现 parallel (PS: 其实是需要实现 COMBINEFUNC, 将不同worker的中间结果进行合并的函数), 所以会多次调用finalfunc(PS: 这是错误的). 只要在定义agg func时设置为 parallel unsafe 即可!”  
  
大错特错, 我蠢到家了. AI 狠狠的给了我一巴掌.    
  
PS: 这些是我之前写的一些PG agg相关的文章, 仅供参考, 如果你想知道聚合的内部运算逻辑, 可以看一下:  
- [《PostgreSQL 10 自定义并行计算聚合函数的原理与实践 - (含array_agg合并多个数组为单个一元数组的例子)》](../201801/20180119_04.md)      
- [《PostgreSQL 多个数组聚合为一维数组加速(array_agg)》](../201802/20180208_02.md)      
- [《PostgreSQL Oracle 兼容性之 - 自定义并行聚合函数 PARALLEL_ENABLE AGGREGATE》](../201803/20180312_03.md)      
- [《Greenplum 支持人为多阶段聚合的方法 - 直连segment(PGOPTIONS='-c gp_session_role=utility') Or gp_dist_random('gp_id') Or 多阶段聚合 prefunc》](../201806/20180624_02.md)      
- [《Postgres-XC customized aggregate introduction》](../201305/20130502_01.md)        
- [《PostgreSQL aggregate function customize》](../201212/20121218_02.md)       
  
AI 的牛逼在于它的神经元比我多多了, 同时它训练的素材也比我多多了, 并且它还有基于实时资料库的RAG, 我在AI面前就是弱鸡!  
  
  
## AI 纠正了我的错误  
要让自定义聚合函数的finalfunc只执行一次，需要从聚合状态共享和finalfunc属性两个方面进行控制。  
  
## 主要方法  
  
### 1. 设置FINALFUNC_MODIFY为READ_ONLY  
  
在创建聚合函数时指定finalfunc为只读模式：  
  
```sql  
CREATE AGGREGATE my_aggregate(input_type) (  
    SFUNC = transition_function,  
    STYPE = transition_type,  
    FINALFUNC = final_function,  
    FINALFUNC_MODIFY = READ_ONLY  
);  
```  
  
`FINALFUNC_MODIFY = READ_ONLY`表示finalfunc不修改其参数，这是默认值（除了有序集合聚合） 。  
  
### 2. 禁用聚合状态共享  
  
通过设置`shareable = false`来防止多个聚合共享同一个状态值 ：  
  
```c  
// 在聚合函数的内部实现中  
peragg->shareable = false;  
```  
  
### 3. 在finalfunc内部实现执行控制  
  
在finalfunc中添加状态检查逻辑，确保只执行一次：  
  
```c  
Datum  
my_finalfunc(PG_FUNCTION_ARGS)  
{  
    static bool executed = false;  
      
    if (executed)  
        PG_RETURN_NULL();  
          
    // 执行实际的final逻辑  
    executed = true;  
    // ... 你的处理逻辑  
      
    PG_RETURN_DATUM(result);  
}  
```  
  
## 执行机制分析  
  
PostgreSQL的聚合执行流程中，finalfunc在`finalize_aggregate`函数中被调用 ：  
  
1. 每个聚合组处理完所有输入行后调用一次finalfunc  
2. 如果存在多个相同的聚合引用，它们会共享状态（当shareable=true时）  
3. finalfunc可能被重新执行，如`array_agg_finalfn`的注释所示   
  
## 最佳实践  
  
### 完整的聚合函数创建示例  
  
```sql  
-- 转换函数  
CREATE FUNCTION my_transfn(internal, integer)   
RETURNS internal AS 'MODULE_PATHNAME' LANGUAGE C;  
  
-- 最终函数  
CREATE FUNCTION my_finalfn(internal)   
RETURNS integer AS 'MODULE_PATHNAME' LANGUAGE C IMMUTABLE;  
  
-- 创建聚合，确保finalfunc只执行一次  
CREATE AGGREGATE my_agg(integer) (  
    SFUNC = my_transfn,  
    STYPE = internal,  
    FINALFUNC = my_finalfunc,  
    FINALFUNC_MODIFY = READ_ONLY,  
    PARALLEL = SAFE  
);  
```  
  
### 测试验证  
  
可以使用测试用例验证finalfunc的执行次数 ：  
  
```sql  
-- 在transfn和finalfn中添加NOTICE来观察调用次数  
CREATE FUNCTION test_transfn(state int4, n int4) RETURNS int4 AS $$  
BEGIN  
    RAISE NOTICE 'transfn called with %', n;  
    RETURN COALESCE(state, 0) + n;  
END;  
$$ LANGUAGE plpgsql;  
  
CREATE FUNCTION test_finalfn(state int4) RETURNS int4 AS $$  
BEGIN  
    RAISE NOTICE 'finalfn called with %', state;  
    RETURN state;  
END;  
$$ LANGUAGE plpgsql;  
```  
  
## Notes  
  
- `FINALFUNC_MODIFY`有三个选项：READ_ONLY、SHAREABLE、READ_WRITE  
- 当finalfunc需要修改状态时，必须设置为READ_WRITE，这会阻止状态共享  
- 有序集合聚合的默认FINALFUNC_MODIFY是READ_WRITE  
- 聚合状态共享优化在`AggInfo`结构中控制   
  
  
相关代码：  
  
doc/src/sgml/ref/create_aggregate.sgml  
```  
    <term><literal>FINALFUNC_MODIFY</literal> = { <literal>READ_ONLY</literal> | <literal>SHAREABLE</literal> | <literal>READ_WRITE</literal> }</term>  
    <listitem>  
     <para>  
      This option specifies whether the final function is a pure function  
      that does not modify its arguments.  <literal>READ_ONLY</literal> indicates  
      it does not; the other two values indicate that it may change the  
      transition state value.  See <xref linkend="sql-createaggregate-notes"/>  
      below for more detail.  The  
      default is <literal>READ_ONLY</literal>, except for ordered-set aggregates,  
      for which the default is <literal>READ_WRITE</literal>.  
     </para>  
```  
  
src/include/executor/nodeAgg.h  
```  
	 * "shareable" is false if this agg cannot share state values with other  
	 * aggregates because the final function is read-write.  
	 */  
	bool		shareable;  
```  
  
  
#### [PolarDB 学习图谱](https://www.aliyun.com/database/openpolardb/activity "8642f60e04ed0c814bf9cb9677976bd4")
  
  
#### [PostgreSQL 解决方案集合](../201706/20170601_02.md "40cff096e9ed7122c512b35d8561d9c8")
  
  
#### [德哥 / digoal's Github - 公益是一辈子的事.](https://github.com/digoal/blog/blob/master/README.md "22709685feb7cab07d30f30387f0a9ae")
  
  
#### [About 德哥](https://github.com/digoal/blog/blob/master/me/readme.md "a37735981e7704886ffd590565582dd0")
  
  
![digoal's wechat](../pic/digoal_weixin.jpg "f7ad92eeba24523fd47a6e1a0e691b59")
  
