## 跟着 ParadeDB 学 AI 搜索: 1 词汇搜索（Lexical Search） vs 语义搜索（Semantic Search）     
          
### 作者          
digoal          
          
### 日期          
2025-12-08          
          
### 标签          
PostgreSQL , 搜索 , paradedb , tantivy , 语义搜索 , 关键词搜索 , ranking , 混合搜索 , RAG , RRF         
          
----          
          
## 背景     
看完 paradedb 的文档 , 我知道它也在朝着 AI 搜索数据库的方向发展.   
  
AI 搜索, 目前的共识需求是: 语义搜索 , 关键词搜索 , 标量搜索 , 混合搜索! ( 个人认为应该还要加上 图、GIS等多模态功能 )    
  
目前围绕AI 搜索需求在做的产品, 我大概总结一下:  
- PG 的插件: vectorchord + vectorchord-bm25 + pg_tokenizer  
- PG 商业发行版: 海量 vastbase 向量版、vexdb  
- PG 的插件(本文主角): paradedb  
- OceanBase SeekDB.  
- DuckDB: vss + fts   
  
好的, 话不多说, 下面就跟着 ParadeDB 文档来体系化学习一下AI 搜索  
  
https://www.paradedb.com/learn  
        
## 词汇搜索（Lexical Search） vs 语义搜索（Semantic Search）  
  
不同的搜索工作负载（search workloads）对**相关性（relevancy）** 有不同的要求。例如，有些搜索问题仅依赖于**精确（exact）** 或**近似（approximate）的字符串匹配**，其中子字符串的出现（或缺失）决定了相关性（例如`“cat”`和`“black cat”`）。而另一些则依赖于**语义相似性（semantic similarity）** ，即**含义（meaning）** 决定了相关性（例如`“cat”`和`“feline”`）。  
  
从实施的角度来看，这两种模式是**正交的（orthogonal）** ：  
  
* **词汇方法（Lexical methods）** （包括**全文搜索（full-text search）** ）精确匹配**词元（tokens）** 。它们只有在查询（query）和文档（document）共享词汇时才能成功。  
* **语义方法（Semantic methods）** 捕获**意图含义（intended meaning）** ，但对于词汇系统能精确处理的**精确标识符（exact identifiers）** （如ID、数字、专有名称）来说，它们表现不佳。  
  
正是这种差异导致没有单一的检索方法在所有工作负载中都表现出色（然而，通过使用**混合搜索（hybrid search）** 将两者结合，可以提供一种折衷方案）。  
  
了解何时使用**词汇搜索（Lexical）** 、**语义搜索（Semantic）** 或**混合搜索（Hybrid search）** 取决于您的具体用例以及用户执行的查询类型。  
  
## 词汇搜索（Lexical Search）  
  
**词汇搜索（Lexical search）** 作为信息系统的一部分已经有数十年历史。早期的工作负载依赖于**确定性匹配（deterministic matching）** 。数据库和其他内部工具发出的大多数查询都引用了诸如ID或错误代码等**精确术语（exact terms）** 。例如，使用 `LIKE '%error%'` 的 **SQL** 查询会搜索任何包含子字符串“error”的文本。  
  
现代的词汇搜索要先进得多，它根据**词元出现（token presence）** 和**频率（frequency）** 来确定相关性。当查询词在整个语料库（corpus）中出现更频繁或更罕见时，文档得分会更高。  
  
### 词汇搜索如何工作？  
  
大多数**词汇搜索（Lexical search）** 实现都使用**倒排索引（inverted indexes）** 。**倒排索引**将每个**词元（token）** 映射到包含它的文档。这使得即使数据集增大，也能实现快速查找（fast lookups）。  
  
然而，结果也需要**排名（ranked）** 。**BM25**（Best Matching 25，**最佳匹配 25**）是词汇检索中最广泛使用的**排名函数（ranking function）** 。在**索引（indexing）** 时，文本会通过一个**分析器（analyzer）** 进行处理，该分析器将输入**词元化（tokenizes）** 。这些**词元（tokens）** 可以是单个词、短语或**词位（lexemes）** （每个词的词根）。每个词元都成为**倒排索引（inverted index）** 中的一个条目，同时记录包含该词元的文档数量及其出现频率。  
  
**词汇搜索（Lexical search）** 可以通过**词干提取（stemming）** （将词语简化为词根形式）和**同义词扩展（synonym expansion）** （匹配预定义的词表）等技术进行增强。然而，这些改进仍然依赖于**精确的词元匹配（exact token matching）** ，而不是理解上下文含义。  
  
### 什么是全文搜索（Full-Text Search）？  
  
**全文搜索（Full-Text Search）** 通过为查询本身添加**结构（structure）** 来扩展这个模型。**全文搜索**允许开发人员配置**词元（tokens）** 之间应如何关联，而不是独立处理它们。  
  
例如，**短语搜索（phrase search）** 要求词元以特定顺序出现，当顺序可能影响含义时（例如错误消息或函数签名），这非常有用。另一方面，**邻近搜索（proximity search）** 允许词元彼此靠近出现，但不要求精确顺序；这能更好地反映相关术语如何在文档或日志中出现。  
  
**全文搜索（Full-text search）** 仍然是纯粹的**词汇搜索（lexical）** 。它使用**倒排索引（inverted index）** 并扩展相同的词元统计数据。然而，**全文搜索**提供了一个更具**表达力（expressive）** 的查询工具包。  
  
  
## 语义搜索（Semantic Search）  
  
**语义搜索（Semantic search）** （也称为**向量搜索（vector search）** ）解决了**词汇搜索（lexical search）** 的一个根本限制。两段文本可以描述相同的想法，而**不使用重叠的词语（without overlapping words）** 。如果查询使用的措辞与所查找文档不同，搜索结果可能不相关（尽管带有同义词的词汇搜索可能有所帮助，但它仍然无法索引**概念（concepts）** ）。  
  
**密集向量检索（Dense vector retrieval）** 通过**近似含义（approximating meaning）** 而不是依赖词语匹配来弥合这一差距。**嵌入模型（Embedding models）** （如text-embedding-ada-002、sentence-transformers或E5）从大型数据集中学习概念之间的关系；然后将这些概念映射到一个**连续的向量空间（continuous vector space）** 中。  
  
### 语义搜索如何工作？  
  
在**索引（indexing）** 时，**嵌入模型（embedding model）** 将每个文档转换为一个**密集向量（dense vector）** 。这些向量代表从模型训练数据中学到的**语义信息（semantic information）** 。由于这种表示是连续的，表达相似想法的文档可以被放置在彼此**附近（near one another）** ，即使它们使用的词汇完全不同。  
  
直接搜索所有向量将非常昂贵，因此数据库使用**近似最近邻（ANN）索引（Approximate Nearest Neighbor indexes）** ，例如 **HNSW** 或 **IVF**。这些结构将向量组织成**分区（partitions）** ，使得检索少量**候选集（candidate set）** 成为可能。**ANN 索引**牺牲了少量的**召回率（recall）** ，以换取**吞吐量（throughput）** 和**延迟（latency）** 的显著提升。  
  
在**查询时（query time）** ，系统将查询**嵌入（embeds）** 到相同的**向量空间（vector space）** 中。然后，它使用**相似性度量（similarity metrics）** （例如**余弦相似度（cosine similarity）** 、**点积（dot product）** 或 **L2 距离（L2 distance）** ）来评估查询向量与每个候选向量的接近程度。  
  
  
## 混合搜索（Hybrid Search）  
  
**混合搜索（Hybrid search）** 并**没有取代（does not replace）** 词汇搜索或语义搜索。相反，它对它们进行**协调（coordinates）** 。当查询包含**结构化词元（structured tokens）** 时，**词汇方法（Lexical methods）** 是可靠的。当查询以**自然语言（natural language）** 表达意图时，**语义方法（Semantic methods）** 是可靠的。**混合搜索**结合了这些优势。  
  
在**混合搜索**中，**词汇方法**和**语义方法**都检索它们各自的**候选集（set of candidates）** 。每个列表反映了对用户意图的不同假设：一个基于**精确术语（exact terms）** ，另一个基于**上下文含义（contextual meaning）** 。任一方法浮现的文档都可能是相关的。将这些列表合并成一个**单一的排名（single ranking）** 可以在可能变化的查询类型中创建更稳定的**相关性信号（relevance signal）** 。  
  
### 混合搜索如何工作？  
  
**混合搜索（Hybrid search）** 首先**并行运行（running in parallel）** 多个检索方法。通常，**词汇搜索（lexical search）** 使用 **BM25** 检索并对候选者进行排名，这几乎总是词汇检索的最佳**基线（baseline）** 。与此同时，**向量搜索（vector search）** 使用**密集嵌入（dense embeddings）** 检索候选者。每种方法都根据其**内部评分规则（internal scoring rules）** 生成自己的**排名列表（ranked list）** 。  
  
在**查询时（query time）** ，这些列表需要合并成一个**最终的单一排名（single final ranking）** 。来自每种方法的**分数（scores）** 不能直接比较，因为**词汇分数（lexical scores）** 和**向量度量（vector measures）** 使用不同的**尺度（varying scales）** 。然而，像**倒数排序融合（Reciprocal Rank Fusion, RRF）** 这样的技术完全忽略原始分数，而**严格使用每个文档在其自身列表中的排名位置（rank position）** 。**RRF** 为每个文档分配一个**融合分数（fused score）** 。  
  
  
## 总结（Summary）  
  
**词汇搜索（Lexical）** 、**语义搜索（Semantic）** 和**混合搜索（Hybrid search）** 方法之所以存在，是因为用户表达意图的方式不同。有些查询依赖于**精确词元（exact tokens）** ，而有些则依赖于**上下文（context）** 。每种检索方法都针对不同类型的**相关性（relevance）** 进行了优化。  
  
除了选择检索方法之外，**查询重写（query rewriting）** （在搜索前扩展或修改查询）和**重新排序（reranking）** （在检索后调整结果）对于提高搜索质量也同样重要。这些技术可以显著增强任何底层搜索方法。像**检索增强生成（Retrieval-Augmented Generation, RAG）** 这样的现代应用严重依赖这些搜索基础知识，为语言模型提供相关**上下文（context）** 。  
  
许多团队面临的一个实际挑战是，他们的应用程序需要在一个与**主数据库（primary database）** 分离的系统中进行搜索（例如，Elasticsearch 和 Postgres）。在这种情况下，保持两个系统一致的负担就落在了开发人员身上。  
  
**原生支持词汇搜索和语义搜索（support both lexical and semantic search natively）** 的现代数据库引擎通过**直接在数据库行上运行检索方法（running retrieval methods directly on database rows）** 来提供帮助，从而消除了对单独的**索引同步管道（index-sync pipelines）** 的需求。  
    
#### [PolarDB 学习图谱](https://www.aliyun.com/database/openpolardb/activity "8642f60e04ed0c814bf9cb9677976bd4")
  
  
#### [PostgreSQL 解决方案集合](../201706/20170601_02.md "40cff096e9ed7122c512b35d8561d9c8")
  
  
#### [德哥 / digoal's Github - 公益是一辈子的事.](https://github.com/digoal/blog/blob/master/README.md "22709685feb7cab07d30f30387f0a9ae")
  
  
#### [About 德哥](https://github.com/digoal/blog/blob/master/me/readme.md "a37735981e7704886ffd590565582dd0")
  
  
![digoal's wechat](../pic/digoal_weixin.jpg "f7ad92eeba24523fd47a6e1a0e691b59")
  
