## 跟着 ParadeDB 学 AI 搜索: 2 什么是全文搜索？ (What is Full-Text Search?)      
            
### 作者            
digoal            
            
### 日期            
2025-12-08            
            
### 标签            
PostgreSQL , 搜索 , paradedb , tantivy , 语义搜索 , 关键词搜索 , ranking , 混合搜索 , RAG , RRF           
            
----            
            
## 背景       
看完 paradedb 的文档 , 我知道它也在朝着 AI 搜索数据库的方向发展.     
    
AI 搜索, 目前的共识需求是: 语义搜索 , 关键词搜索 , 标量搜索 , 混合搜索! ( 个人认为应该还要加上 图、GIS等多模态功能 )      
    
目前围绕AI 搜索需求在做的产品, 我大概总结一下:    
- PG 的插件: vectorchord + vectorchord-bm25 + pg_tokenizer    
- PG 商业发行版: 海量 vastbase 向量版、vexdb    
- PG 的插件(本文主角): paradedb    
- OceanBase SeekDB.    
- DuckDB: vss + fts     
    
好的, 话不多说, 下面就跟着 ParadeDB 文档来体系化学习一下AI 搜索    
    
https://www.paradedb.com/learn    
          
## 什么是全文搜索？ (What is Full-Text Search?)  
  
**全文搜索 (Full-Text Search, FTS)** 的设计目的是根据文档所包含的词语来查找它们，而不是仅仅依赖于结构化字段或元数据。它通过分析和**索引 (Indexing)** 语言，为文本检索带来了智能性，允许**查询 (Querying)** 返回按**相关性 (relevance)** 而非简单匹配排序的结果。  
  
这项能力将一个**数据存储库 (datastore)** 转换为一个**搜索引擎 (search engine)** 。全文搜索不再强迫用户记住确切的值或字段名称，而是允许他们用自然语言描述他们正在寻找的内容，并仍然能找到它。  
  
全文搜索通过两个核心组件来运行：**索引 (Indexing)** 和**查询 (Querying)** 。索引将原始文本转换为结构化、可搜索的数据，而查询则提供灵活的方式来检索和对相关文档进行排名。  
  
## 索引 (Indexing)  
  
**索引 (Indexing)** 是全文搜索性能的基础。索引没有将整个文档作为必须线性扫描的**不透明块 (opaque blocks)** 存储，而是将它们分解为更小的、可搜索的部分，并将其重建成针对检索优化的结构。  
  
### 文本分析管道 (Text Analysis Pipeline)  
  
索引过程始于**文本分析 (text analysis)** ，原始文本在此过程中被转换成计算机可以高效索引的形式。该**管道 (pipeline)** 通常包括：  
  
* **分词 (Tokenization)** ：将文本拆分成离散的**术语 (terms)** 或**标记 (tokens)** ，例如词语或短语。  
* **标准化 (Normalization)** ：将术语小写化、移除标点符号和**停用词 (stop words)** ，并且通常应用**词干提取 (stemming)** ，以便 `running`、`ran` 和 `run` 被视为相关。  
* **索引 (Indexing)** ：将每个标记与其包含该标记的文档一起存储在一个称为**倒排索引 (Inverted Index)** 的结构中。  
  
> 像 Elasticsearch、Solr、ParadeDB 和 PostgreSQL 的 `ts_vector` 这样的系统会自动管理整个管道，允许开发人员在不重新发明底层机制的情况下，为他们的应用程序添加高质量的搜索功能。  
  
### 倒排索引 (Inverted Indexes)  
  
全文搜索的基础是**倒排索引 (Inverted Index)** ，它是一种数据结构，通过颠倒通常的“文档到术语”关系，实现极快的查找。  
  
倒排索引不是回答“此文档中出现了哪些术语？”，而是用于回答“哪些文档包含此术语？”  
  
  
其核心结构是一个**字典 (dictionary)** ，其中每个**术语 (term)** 映射到一个**发表列表 (postings list)** ，该列表描述了包含该术语的每个文档。  
  
发表列表中的每个条目通常包括：  
  
* **文档ID (Document ID)**  
* **词频 (Term Frequency, TF)** （该术语在该文档中出现的频率）  
* 可选地，该术语出现的位置（用于实现**短语查询 (phrase queries)** 和**邻近查询 (proximity queries)** ）  
  
#### 示例：构建一个倒排索引  
  
考虑索引两个简单文档：  
  
| ID | Text |  
| :--- | :--- |  
| 1 | "PostgreSQL supports search" |  
| 2 | "Search engines use indexes" |  
  
在分词和标准化之后，**倒排索引**看起来如下（使用不带词干提取的英语分词器）：  
  
| Term (术语) | Postings List (发表列表) |  
| :--- | :--- |  
| postgresql | [(1, tf=1, pos=[0])] |  
| supports | [(1, tf=1, pos=[1])] |  
| search | [(1, tf=1, pos=[2]), (2, tf=1, pos=[0])] |  
| engines | [(2, tf=1, pos=[1])] |  
| indexes | [(2, tf=1, pos=[3])] |  
  
当您搜索 "search" 时，系统会查找该术语并找到文档 [1, 2]，而无需扫描任何文本。  
  
### 性能优势 (Performance Benefits)  
  
**倒排索引**提供了：  
  
* **快速检索 (Fast retrieval)** ： $O(1)$ 术语查找，随后是高效的发表列表**交集 (intersection)** 。  
* **空间效率 (Space efficiency)** ：每个独特的**词干提取后术语 (unique stemmed term)** 只存储一次，无论**语料库 (corpus)** 大小如何。  
* **灵活评分 (Flexible scoring)** ：丰富的统计数据支持先进的**排名算法 (ranking algorithms)** 。  
  
现代实现包括**压缩 (compression)** 、**跳表 (skip lists)** 和**索引分区 (index partitioning)** 等优化，以高效地处理大规模部署。  
  
## 查询 (Querying)  
  
一旦文本被**索引 (indexed)** ，**查询 (Querying)** 就提供了灵活的方式来检索和对相关文档进行排名。当用户提交查询时，用于索引的相同分析步骤会应用于他们的搜索术语，然后系统在索引中查找这些术语。  
  
现代搜索引擎提供强大的**查询构建器 API (query builder APIs)** ，允许开发人员以编程方式构建复杂的搜索查询，并将业务逻辑直接集成到他们的搜索操作中。这会将尽可能多的工作推送到**查询引擎 (query engine)** 中处理（在那里可以最高效地进行），因此客户端无需进行**后过滤 (post-filter)** 或**重新处理 (reprocess)** 结果。  
  
### 查询类型和处理 (Query Types and Processing)  
  
不同类型的查询以不同的方式使用**倒排索引 (Inverted Index)** ：  
  
* **布尔查询 (Boolean queries)** （例如 "PostgreSQL AND search"）使用发表列表的**集合交集 (set intersection)** 来查找符合逻辑条件的文档。  
* **短语查询 (Phrase queries)** 使用位置信息来确保术语连续出现或彼此**邻近 (proximity)** 。例如，您可以搜索 "search engines" 的精确匹配，或者搜索 "search" 位于 "indexes" 的五个词范围内的情况。  
* **排名查询 (Ranked queries)** 使用**词频 (term frequency)** 和**文档频率 (document frequency)** 等统计数据，应用像 **BM25** 这样的算法来首先给出最相关的结果。  
  
### 高级查询功能 (Advanced Query Features)  
  
**全文搜索 (FTS)** 提供的远不止是查找精确匹配的能力。它引入了一系列使搜索既灵活又宽容的功能：  
  
* **模糊匹配 (Fuzzy matching)** 可以纠正微小的错误和拼写错误，因此查询 `databse` 仍然会返回 `database`。  
* **布尔运算符 (Boolean operators)** 为高级用户提供了细粒度的控制，例如 `python AND (api OR web)` 这样的逻辑，从而过滤结果以匹配复杂的条件。  
* **字段加权 (Field weighting)** 承认文档的某些部分比其他部分更重要 —— 例如，在**标题 (title)** 中匹配通常比在**正文 (body text)** 中匹配具有更高的重要性。  
* **邻近查询 (Proximity queries)** 查找彼此位置相近的词语（例如，`dogs` 位于 `cats` 的 5 个词范围内）。  
* **分面 (Faceting)** 使用户能够通过类别或属性（如“品牌”、“价格范围”或“日期”）来过滤搜索结果，同时保持基于文本的**相关性评分 (relevance scoring)** 。  
  
## 全文搜索何时大放异彩 (When Full-Text Search Shines)  
  
当需要快速、直观地**查询 (query)** 大量**非结构化 (unstructured)** 或**半结构化 (semi-structured)** 文本时，**全文搜索 (FTS)** 变得至关重要。它在用户以语言（而非**模式/架构 (schema)** ）进行思考的场景中表现出色。  
  
一些常见的例子包括：  
  
**内容和通信搜索 (Content and Communication Search)**  
* **内容发现 (Content discovery)** ：跨文章、博客帖子或文档页面进行搜索。  
* **通信搜索 (Communication search)** ：导航聊天记录、电子邮件或支持工单。  
* **电子商务 (E-commerce)** ：用户通过描述、功能或品牌名称搜索的**产品目录 (Product catalogs)** 。  
  
**技术搜索 (Technical Search)**  
* **代码搜索 (Code search)** ：在**代码库 (codebases)** 中查找函数、变量或模式。  
* **日志搜索 (Log search)** ：分析应用程序日志、错误消息和系统事件以进行调试和**监控 (monitoring)** 。  
  
**人工智能和机器学习 (AI and Machine Learning)**  
* **检索增强生成 (Retrieval Augmented Generation, RAG)** ：为需要从**知识库 (knowledge bases)** 中查找相关上下文然后生成响应的 AI 系统提供支持。  
  
在所有这些工作负载中，用户不仅仅是在**过滤 (filtering)** ，他们是在**搜索 (searching)** 。他们概念上知道自己想找什么，但不清楚它确切存储在哪里。**全文搜索 (FTS)** 通过将文本转化为结构化、有意义的排名表示形式来弥合这一差距。  
  
## 全文搜索何时力有不逮 (When Full-Text Search Is Not Enough)  
  
虽然**全文搜索 (FTS)** 擅长**词汇匹配 (lexical matching)** ，但当用户按**意义 (meaning)** 而非**关键词 (keywords)** 进行搜索时，它存在局限性。全文搜索使用这些方法来捕获**语言变化 (linguistic variation)** ，但其焦点仍然是词汇：它匹配词语，而非含义。  
  
考虑以下传统全文搜索难以应对的场景：  
  
* **语义相似性 (Semantic similarity)** ：搜索 "automobile" 不会匹配关于 "cars" 的文档，除非配置了显式的**同义词 (synonyms)** 。  
* **跨语言搜索 (Cross-language search)** ：一种语言中的关键词不会匹配另一种语言中语义等效的内容。  
* **领域特定术语 (Domain-specific terminology)** ：技术概念在不同文档中的表达可能不同，但含义相同。  
  
对于这些用例，**向量搜索 (Vector Search)** 提供了一种补充方法。向量搜索将文本表示为捕获**语义含义 (semantic meaning)** 的**高维向量 (high-dimensional vectors)** ，从而允许基于**概念相似性 (conceptual similarity)** 而非精确关键词匹配进行搜索。  
  
许多现代搜索系统采用**混合方法 (hybrid approaches)** ，结合了全文搜索和向量搜索：  
  
* 全文搜索用于精确的关键词匹配和**布尔逻辑 (boolean logic)** 。  
* 向量搜索用于语义相似性和基于概念的检索。  
* **排名算法 (Ranking algorithms)** 融合这两种方法以实现最佳相关性。  
  
## 总结 (Summary)  
  
**全文搜索 (Full-Text Search)** 为**非结构化数据 (unstructured data)** 带来了词汇结构。通过分析、**索引 (indexing)** 和**排名 (ranking)** 文本，它使得信息可以通过自然语言而非僵硬的过滤器或精确匹配来查找。  
  
它仍然是用于大规模文本检索的最有效工具之一：快速、可靠，并针对**关键词相关性 (keyword relevance)** 进行了深度优化。它的成功在于弥合了人们思考信息的方式与计算机存储信息的方式之间的差距。  
       
#### [PolarDB 学习图谱](https://www.aliyun.com/database/openpolardb/activity "8642f60e04ed0c814bf9cb9677976bd4")
  
  
#### [PostgreSQL 解决方案集合](../201706/20170601_02.md "40cff096e9ed7122c512b35d8561d9c8")
  
  
#### [德哥 / digoal's Github - 公益是一辈子的事.](https://github.com/digoal/blog/blob/master/README.md "22709685feb7cab07d30f30387f0a9ae")
  
  
#### [About 德哥](https://github.com/digoal/blog/blob/master/me/readme.md "a37735981e7704886ffd590565582dd0")
  
  
![digoal's wechat](../pic/digoal_weixin.jpg "f7ad92eeba24523fd47a6e1a0e691b59")
  
