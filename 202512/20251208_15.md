## 跟着 ParadeDB 学 AI 搜索: 9 PostgreSQL 中的全文搜索 (Full-Text Search in PostgreSQL)  
      
### 作者      
digoal      
      
### 日期      
2025-12-08      
      
### 标签      
PostgreSQL , 搜索 , paradedb , tantivy , 语义搜索 , 关键词搜索 , ranking , 混合搜索 , RAG , RRF      
      
----      
      
## 背景      
看完 paradedb 的文档 , 我知道它也在朝着 AI 搜索数据库的方向发展.      
      
AI 搜索, 目前的共识需求是: 语义搜索 , 关键词搜索 , 标量搜索 , 混合搜索! ( 个人认为应该还要加上 图、GIS等多模态功能 )      
      
目前围绕AI 搜索需求在做的产品, 我大概总结一下:      
- PG 的插件: vectorchord + vectorchord-bm25 + pg_tokenizer      
- PG 商业发行版: 海量 vastbase 向量版、vexdb      
- PG 的插件(本文主角): paradedb      
- OceanBase SeekDB.      
- DuckDB: vss + fts      
      
好的, 话不多说, 下面就跟着 ParadeDB 文档来体系化学习一下AI 搜索      
      
https://www.paradedb.com/learn      
      
## PostgreSQL 中的全文搜索 (Full-Text Search in PostgreSQL)  
  
PostgreSQL 包含强大的**内置（built-in）** **全文搜索（full-text search）功能，可将数据库转化为一个搜索引擎。您无需依赖外部服务，就可以直接在 PostgreSQL 内部实现复杂的文本搜索，并使用管理应用程序数据的ACID 事务**（**ACID transactions**）、安全模型和运营基础设施。  
  
PostgreSQL 的全文搜索处理了从**文本分析**到**排名结果**的完整流程。它执行**词元化（tokenizes）文档、移除停用词（stop words）** 、应用**词干提取（stemming）** 、构建可搜索的**索引（indexes）** ，并根据 **相关性（relevance）** 对结果进行排名 —— 所有这些都具备您对 PostgreSQL 所期望的性能和可靠性。本文讨论它的功能，以及它的不足之处。  
  
> 我们喜欢使用 PostgreSQL 进行全文搜索，但我们构建 **ParadeDB** 是因为我们认为内置的全文搜索对于一个现代搜索应用程序来说是不够的。  
>   
> 这并不是说内置功能不优秀，但当您需要**流线型的开发体验**、**BM25 排名**（**BM25 ranking**）、强大的**分面（facets）** 、与 **Elasticsearch** 匹配的功能集，或更高的性能时，ParadeDB 是一个更好的选择。  
  
## 核心组件 (Core Components)  
  
PostgreSQL 的全文搜索围绕着协同工作以提供全面文本搜索功能的**专用数据类型**和**函数**而构建。这些组件结合起来用于存储和查询**文本向量（text vectors）** 。  
  
### 文本搜索数据类型 (Text Search Data Types)  
  
PostgreSQL 提供了两种用于全文搜索的**基本数据类型**。**`tsvector`** 类型将经过处理的、可搜索的文本表示为**去重词元（distinct tokens）和位置信息（position information）的有序列表**。**`tsquery`** 类型表示带有**布尔运算符（boolean operators）** 、**短语匹配（phrase matching）** 和**邻近度要求（proximity requirements）** 的搜索查询。  
  
这些类型处理了文本分析的复杂性，同时为索引和查询提供了一个简洁的接口。  
  
#### 理解 `tsvector` (Understanding tsvector)  
  
**`tsvector`** 将**原始文本（raw text）转换为一种结构化、可搜索的格式**：  
  
```sql  
-- Convert text to tsvector  
SELECT to_tsvector  
  ('english',  
   'PostgreSQL provides full-text search capabilities in database'  
  );  
```  
  
**结果：**  
  
```  
 'capabl':7  
 'databas':9  
 'full':4  
 'full-text':3  
 'postgresql':1  
 'provid':2  
 'search':6  
 'text':5  
```  
  
请注意结果是如何：  
  
  * 将单词 **标准化（Normalizes）** 为小写。  
  * 对单词进行**词干提取（Stems）** （"provides" → "provid"，"capabilities" → "capabl"）。  
  * 移除了**停用词**，例如 "in"。  
  * 记录了**位置信息**（`:1`, `:2` 等）。  
  * **拆分（Explodes）** 了带连字符的术语，例如 "full-text"，同时保留了原始部分。  
  
**`tsvector`** 的一个限制是它将**单行**的文本表示为**单个向量**。要组合多个文本字段，您通常需要将它们连接起来 (`title || ' ' || description || ' ' || body`)，形成一个 `tsvector`。这样做是可行的，但它**扁平化了字段边界**，因此您无法独立搜索或对字段进行排名。或者，您可以为每个字段存储单独的 `tsvector` 列，但这样每个字段都会被独立索引和评分，从而**分割了您的语料库（corpus）** 。  
  
> ParadeDB 使用的 **BM25 覆盖索引（covering index）避免了这种权衡：它可以在单个索引内维护字段级别的统计信息和权重**，同时仍能计算**全局文档统计信息**。  
  
#### 构建 `tsquery` (Building tsquery)  
  
**`tsquery`** 表示作用于 **`tsvector`** 类型的、带有 **布尔逻辑（boolean logic）** 的搜索条件：  
  
```sql  
-- Simple term query  
SELECT to_tsquery('english', 'postgresql');  
  
-- Boolean operators  
SELECT to_tsquery('english', 'postgresql & search');  
  
-- Phrase search (邻近查询，表示 "full" 和 "text" 紧挨着)  
SELECT to_tsquery('english', 'full <-> text');  
  
-- Prefix matching (前缀匹配)  
SELECT to_tsquery('english', 'post:*');  
```  
  
### 文本搜索配置 (Text Search Configurations)  
  
PostgreSQL 附带了针对多种语言的**预定义配置（predefined configurations）** ，每种配置都有相应的**词元化规则（tokenization rules）** 、**停用词列表（stop word lists）和词干提取算法（stemming algorithms）** 。您可以使用以下查询查看系统上可用的配置：  
  
```sql  
-- Available configurations  
SELECT cfgname FROM pg_ts_config;  
```  
  
常见的配置包括 `english`、`spanish`、`french`、`german` 和 `simple`（无词干提取）。您还可以为专业领域创建**自定义配置（custom configurations）** 。虽然像 Elasticsearch 这样的其他系统是基于 **过滤器链（filter chaining）** 运行的，但如果您想改变 Postgres 全文搜索的工作方式，您需要创建另一个启用不同选项的配置。  
  
  
## 索引性能 (Indexing for Performance)  
  
全文搜索的性能完全取决于正确的**索引（indexing）** 。在实践中，您几乎总是使用**函数式索引（functional indexes）** ，而不是将 `tsvector` 数据存储在列中。函数式索引避免了文本数据的重复，消除了同步触发器的需要，并提供了与 **物化列（materialized columns）** 相同的查询性能。  
  
PostgreSQL 支持两种用于文本搜索的索引类型，其中 **GIN 索引**是大多数应用程序的标准选择。  
  
### GIN 索引 (GIN Indexes)  
  
**GIN (Generalized Inverted Index)** 索引是全文搜索的首选方法。您无需添加单独的 `tsvector` 列，而是直接在文本处理函数上创建索引：  
  
```sql  
-- Create functional GIN index (recommended approach)  
CREATE INDEX idx_articles_search ON articles  
USING GIN(to_tsvector('english', title || ' ' || content));  
```  
  
这种方法相对于将 `tsvector` 存储在列中具有多项优势。您避免了在数据库中重复文本数据，从而节省了存储空间并减少了备份大小。无需使用**触发器（triggers）** 或其他**同步机制（synchronization mechanisms）** 来保持搜索数据与源文本同步。索引会自动反映底层文本列的任何更改。查询性能与使用物化 `tsvector` 列相似，因为 PostgreSQL 可以直接使用该索引。即使您确实将 `tsvector` 数据存储在列中，您仍然需要在该列上创建索引才能获得可接受的性能。  
  
GIN 索引擅长**快速查找**任何查询词条、**高效的布尔运算**，以及针对大型词汇表的**紧凑存储**。它们针对文本内容不经常更改的 **读取密集型（read-heavy）** 工作负载进行了优化。  
  
### GiST 索引 (GiST Indexes)  
  
**GiST (Generalized Search Tree)** 索引提供了另一种选择，它可能更适合特定的场景：  
  
```sql  
-- Create functional GiST index  
CREATE INDEX idx_articles_search_gist ON articles  
USING GiST(to_tsvector('english', title || ' ' || content));  
```  
  
当您需要**邻近查询（proximity queries）或短语查询（phrase queries）时，或者当更新频繁**（GiST 的更新速度比 GIN 快），或者当**索引大小**是一个问题时，GiST 索引表现更佳。然而，对于大多数全文搜索应用程序，GIN 索引提供了更好的**整体性能**。  
  
  
## 基本文本搜索操作 (Basic Text Search Operations)  
  
在设置好您的函数式索引后，您无需任何额外的设置或数据同步即可执行复杂的文本搜索。  
  
### 执行搜索 (Executing Searches)  
  
使用 **`@@` 运算符**将文本与搜索查询进行匹配：  
  
```sql  
-- Find articles about PostgreSQL  
SELECT title, content  
FROM articles  
WHERE to_tsvector('english', title || ' ' || content) @@  
      to_tsquery('english', 'postgresql');  
  
-- Boolean search  
SELECT title, content  
FROM articles  
WHERE to_tsvector('english', title || ' ' || content) @@  
      to_tsquery('english', 'postgresql & (search | query)');  
  
-- Phrase search  
SELECT title, content  
FROM articles  
WHERE to_tsvector('english', title || ' ' || content) @@  
      to_tsquery('english', 'full <-> text');  
```  
  
### 排名结果 (Ranking Results)  
  
PostgreSQL 提供了**排名函数（ranking functions）** ，用于根据 **相关性（relevance）** 对文档进行评分，但与现代搜索引擎相比，存在重要的限制：  
  
```sql  
-- Rank by relevance using ts_rank  
SELECT title, content,  
  ts_rank(to_tsvector('english', title || ' ' || content), query) as rank  
FROM articles, to_tsquery('english', 'postgresql & search') query  
WHERE to_tsvector('english', title || ' ' || content) @@ query  
ORDER BY rank DESC;  
```  
  
PostgreSQL 的 **`ts_rank`** 函数提供了**基本的**相关性评分，但它明显不如像 **Elasticsearch** 使用的 **BM25** 等现代排名算法复杂。`ts_rank` 函数**只考虑文档内的词条频率**，而**缺乏全局文档频率信息**（**global document frequency information**），后者可以表明词条在整个语料库中是罕见还是常见。这意味着常见词语没有被适当地降权，而稀有且可能更相关的词条没有获得适当的提升。  
  
PostgreSQL 也提供了 **`ts_rank_cd`**，它使用了 **覆盖密度算法（cover density algorithms）** 进行替代排名，但这些算法仍然不如 BM25 的综合相关性评分方法。对于搜索排名质量至关重要的应用程序，与专用搜索引擎相比，这是一个重大的限制。  
  
## 高级查询技巧 (Advanced Query Techniques)  
  
### 突出显示结果 (Highlighting Results)  
  
PostgreSQL 可以**突出显示（highlight）** 搜索结果中的匹配词条：  
  
```sql  
SELECT title,  
  ts_headline('english', content, query) as highlighted_content  
FROM articles, to_tsquery('english', 'postgresql & search') query  
WHERE search_vector @@ query;  
```  
  
### 多列搜索 (Multi-Column Search)  
  
使用不同的**权重（weights）** 跨多个文本字段进行搜索：  
  
```sql  
-- Weight title more heavily than content  
SELECT title, content,  
  ts_rank_cd(  
    setweight(to_tsvector('english', title), 'A') ||  
    setweight(to_tsvector('english', content), 'B'),  
    query  
  ) as rank  
FROM articles, to_tsquery('english', 'postgresql') query  
WHERE (  
  setweight(to_tsvector('english', title), 'A') ||  
  setweight(to_tsvector('english', content), 'B')  
) @@ query  
ORDER BY rank DESC;  
```  
  
### 模糊匹配 (Fuzzy Matching)  
  
可以添加 **`pg_trgm`** **扩展（extension）来处理拼写错误和变体，实现相似性搜索（similarity search）** ：  
  
```sql  
-- Enable pg_trgm extension for trigram similarity  
CREATE EXTENSION pg_trgm;  
  
-- Find similar terms  
SELECT word FROM dictionary  
WHERE similarity(word, 'postgresgl') > 0.3  
ORDER BY similarity(word, 'postgresgl') DESC;  
```  
  
注意pg_trgm对小于3个字符的模糊匹配效率较差, 可使用pg_bigm或pgroonga代替之.    
  
  
## 何时使用 PostgreSQL 全文搜索 (When to Use PostgreSQL Full-Text Search)  
  
当搜索需要与数据库操作**事务性（transactional）地结合在一起，并在整个应用程序中保持 ACID 保证时，PostgreSQL 的内置搜索表现出色。它对于拥有数百万而不是数十亿文档的应用程序性能良好，使其适用于大多数业务应用程序**。特定语言的配置适用于**多语言内容**，并且能够将搜索结果与其他表**连接（join）** ，从而简化了在其他架构中需要多个系统才能完成的复杂查询。  
  
管理**单个数据库系统**而不是独立的搜索基础设施的**操作简单性**，使得 PostgreSQL 全文搜索对于希望避免**分布式系统**复杂性的团队极具吸引力。PostgreSQL 全文搜索为大多数应用程序提供了出色的性能，同时保持了单个数据库系统的操作简单性。  
  
## 限制与替代方案 (Limitations and Alternatives)  
  
虽然 PostgreSQL 的全文搜索功能强大，但与专业搜索引擎相比仍存在限制。对于非常大的文档集合（数百万文档），**性能会下降**，并且该系统对**分面（faceting）** 、**模糊匹配（fuzzy matching）或复杂高亮（complex highlighting）的支持有限。与专用搜索引擎相比，排名算法提供的定制选项较少**，并且**实时分析**功能也不如专用搜索引擎提供的复杂。  
  
对于需要这些高级功能的应用程序，可以考虑使用**混合方法（hybrid approaches）** ，即使用 PostgreSQL 处理**事务性数据（transactional data）** ，并使用像 **Elasticsearch** 这样的**专用搜索引擎**。  
  
另一种选择是 **ParadeDB**，它使用一个**扩展（extension）** 将 Elasticsearch 的功能集和性能带到 Postgres 内部。  
  
## 总结 (Summary)  
  
PostgreSQL 的内置全文搜索将您的数据库转化为一个**有能力的搜索引擎**。借助 **`tsvector`**、**`tsquery`** 和适当的**索引**，您可以实现复杂的文本搜索，并将其与应用程序的数据和事务无缝集成。  
  
**SQL 的表达能力**与全文搜索功能的结合，使得 PostgreSQL 成为那些搜索功能很重要，但又不足以证明独立搜索基础设施复杂性合理性的应用程序的绝佳选择。  
      
#### [PolarDB 学习图谱](https://www.aliyun.com/database/openpolardb/activity "8642f60e04ed0c814bf9cb9677976bd4")
  
  
#### [PostgreSQL 解决方案集合](../201706/20170601_02.md "40cff096e9ed7122c512b35d8561d9c8")
  
  
#### [德哥 / digoal's Github - 公益是一辈子的事.](https://github.com/digoal/blog/blob/master/README.md "22709685feb7cab07d30f30387f0a9ae")
  
  
#### [About 德哥](https://github.com/digoal/blog/blob/master/me/readme.md "a37735981e7704886ffd590565582dd0")
  
  
![digoal's wechat](../pic/digoal_weixin.jpg "f7ad92eeba24523fd47a6e1a0e691b59")
  
