## 跟着 ParadeDB 学 AI 搜索: 10 在 PostgreSQL 中实现 BM25  
        
### 作者        
digoal        
        
### 日期        
2025-12-08        
        
### 标签        
PostgreSQL , 搜索 , paradedb , tantivy , 语义搜索 , 关键词搜索 , ranking , 混合搜索 , RAG , RRF        
        
----        
        
## 背景        
看完 paradedb 的文档 , 我知道它也在朝着 AI 搜索数据库的方向发展.        
        
AI 搜索, 目前的共识需求是: 语义搜索 , 关键词搜索 , 标量搜索 , 混合搜索! ( 个人认为应该还要加上 图、GIS等多模态功能 )        
        
目前围绕AI 搜索需求在做的产品, 我大概总结一下:        
- PG 的插件: vectorchord + vectorchord-bm25 + pg_tokenizer        
- PG 商业发行版: 海量 vastbase 向量版、vexdb        
- PG 的插件(本文主角): paradedb        
- OceanBase SeekDB.        
- DuckDB: vss + fts        
        
好的, 话不多说, 下面就跟着 ParadeDB 文档来体系化学习一下AI 搜索        
        
https://www.paradedb.com/learn        
        
## 在 PostgreSQL 中实现 BM25  
  
| 英文原文 (Original) | 中文译文 (Translation) |  
| :--- | :--- |  
| **PostgreSQL (Postgres)** | 一个强大的通用数据库 |  
| **BM25 (Best Matching 25)** | 最佳匹配25（一种概率性排序函数） |  
| **Full-Text Search** | 全文搜索 |  
| **Ranking** | 相关性排序 |  
| **Term Frequency (TF)** | 词频 |  
| **Inverse Document Frequency (IDF)** | 逆文档频率 |  
| **pg\_search** | ParadeDB 的开源扩展名 |  
  
  
**Postgres** 是一个强大的通用数据库：但其内置的**全文搜索**（Full-Text Search）功能存在局限性，尤其是在**相关性排序**（Ranking）方面。它支持基本的术语匹配，但缺乏对 **BM25** 的原生实现，而 **BM25** 是一种概率性**排序**函数，支撑着大多数现代搜索系统（包括 Elasticsearch）的核心。**BM25**（是 **Best Matching 25** 的缩写，通常也称为 **Okapi BM25**）通过平衡**词频**（Term Frequency, **TF**）、**文档稀有度**（即**逆文档频率**，Inverse Document Frequency, **IDF**）和长度归一化来衡量相关性，这种方法始终优于更简单或更复杂的排序方法。  
  
在本指南中，您将了解在 **Postgres** 数据库中实现 **BM25** 的几种方法。  
  
### BM25 如何工作？  
  
**BM25** 的目标是根据相关性对搜索查询的结果进行**排序**。  
  
为此，**BM25** 考虑了三个变量：  
  
(i) 文档中每个词的**词频**（**TF**）。  
(ii) **逆文档频率**（**IDF**），它量化并加权了每个词在所有文档中的稀有程度。  
(iii) 文档的长度。通过考虑文档的长度，**BM25** 可以优先考虑那些可能更集中于搜索查询的较短文档。  
  
**BM25** 会对以下情况给予更高的权重：(i) 较短的文档，(ii) 包含高频查询词的文档，以及 (iii) 在整个文档集中出现频率较低的词语（稀有词）。如果您对该算法的精确机制感到好奇，您可以在我们《搜索概念》系列中的 **BM25** 章节了解更多信息。  
  
## Postgres 支持全文搜索，但不支持 BM25  
  
尽管没有实现 **BM25**，**Postgres** 确实通过 `tsvector` 及其系列函数支持**全文搜索**。**Postgres** 开发者可以使用 `ts_rank` 来对文档进行相关性排序，但所有的评分方法并非都一样。内置的排序表现不如 **BM25**，因为它只考虑了文档内的**词频**和文档长度，而没有考虑**逆文档频率**来捕捉词语在整个语料库中的稀有度。此外，它也更慢，需要从集合中的每个 `tsvector` 读取才能从索引中返回排序结果（即使是对于 `LIMIT/topN` 查询）。  
  
## 在 Postgres 中实现 BM25 的途径  
  
当然，有志者事竟成，**Postgres** 爱好者们已经找到了几种添加 **BM25** 支持的方法，从纯 SQL 到专用的 **BM25** 扩展。让我们详细剖析其中的一些方法。  
  
### 仅使用 SQL 实现 BM25  
  
最基本（且不可扩展）的方法是在查询时仅使用 SQL。**BM25** 的三个变量 —— 文档长度、**词频**和 **IDF** —— 可以使用 `tsvector` 对象和 **Postgres** 收集的 `ts_stat` 数据手动计算，但这非常复杂且速度极慢。它可能适用于一个永不更改的静态语料库，但感觉更像是一个概念验证（proof-of-concept），而非生产就绪的方法。  
  
### 使用 PL/PGSQL 和辅助表实现 BM25  
  
实现 **BM25** 的一个更可用的途径是使用自定义的 **PL/PGSQL** 和辅助表（auxiliary tables）。由于每个术语占据一行，表查找（table lookups）减少到查询中每个术语查找一次。然后可以使用自定义函数对这些结果进行聚合。  
  
一个采用这种方法的库是 András Jankovics 的 `plpgsql_bm25` ( https://github.com/jankovicsandras/plpgsql_bm25 ) 。`plpgsql_bm25` 仅使用 SQL 和辅助表实现了 **BM25**。用于创建存储 **BM25** 记录表的函数签名如下所示：  
  
```sql  
bm25createindex(  
  tablename TEXT,  
  columnname TEXT,  
  algo TEXT DEFAULT '',  
  stopwordslanguage TEXT DEFAULT '')  
RETURNS VOID  
```  
  
不幸的是，这种方法仍然非常慢，并且在每次源数据更改后，这些表（及其索引）都需要更新，从而导致写入放大（write amplification）。  
  
### 扩展 Postgres 以支持 BM25 索引  
  
一个更具可扩展性的方法是使用 **Postgres** 的索引访问方法（Index Access Method, IAM）来创建在源表上的原生 **BM25** 索引。  
  
**ParadeDB** 使用这种方法在 Rust 中实现 **BM25** 索引，并通过开源的 `pg_search` 扩展将它们添加到 **PostgreSQL** 中。当索引添加到表时，它可以覆盖多个列，提供高级的**全文搜索**（Full-Text Search）开发者体验（DX），以及对非文本字段的快速列式查找（columnar lookups）和聚合。  
  
```sql  
CREATE INDEX search_idx ON mock_items  
USING bm25 (id, description, category, rating)  
WITH (key_field='id');  
```  
  
**BM25** 索引在磁盘上以 **LSM 树**（LSM tree）的形式布局，其中树中的每个段都包含一个**倒排索引**（inverted index）和一个**列式索引**（columnar index）。倒排索引和列式索引针对快速读取进行了优化，而 **LSM 树**则针对高频写入进行了优化。  
  
**ParadeDB** 用户可以使用自定义操作符和函数来访问**全文搜索**和 **BM25** 相关性**排序**。例如，一个使用匹配析取（match disjunction，查找匹配一个或多个术语的所有文档），按 **BM25** 分数排序，然后返回前 5 个结果的查询如下所示：  
  
```sql  
SELECT id, paradedb.score(id)  
FROM mock_items  
WHERE description ||| 'running shoes'  
ORDER BY paradedb.score(id)  
LIMIT 5;  
```  
  
在大多数情况下，**ParadeDB** 的性能与 Elasticsearch 相似，即使在大型数据集上也能在毫秒级返回结果。  
  
  
## 在 Postgres 中支持 BM25 有哪些好处？  
  
将 **BM25** 直接引入 **Postgres** 具有两大主要效果：它提高了**相关性排序**（Ranking）质量并简化了系统设计。  
  
**Postgres** 内置的**全文搜索** —— 基于 `tsvector`、`tsquery` 和 `ts_rank` —— 虽然可用但很初级。它的评分函数仅使用**词频**和字段重要性的线性加权，但它忽略了**逆文档频率**（**IDF**），也没有应用文档长度归一化。  
  
在 **Postgres** 内部运行 **BM25** 也消除了对独立搜索引擎以及用于保持同步的 **ETL** 流程的需求。不存在索引过时（stale indexes）的风险、没有重复的基础设施，并且写入数据和可搜索数据之间没有延迟。对表的每次更改都会立即更新 **BM25** 索引，使搜索结果与事实来源（source of truth）保持**事务一致性**（transactionally consistent）。  
  
最后，由于 **BM25** 作为原生索引访问方法（index access method）运行，它参与到 **Postgres** 的规划器（planner）和事务模型中。查询受益于缓存、并行化和可预测的性能特征：这是外部搜索引擎难以轻易保证的。  
  
### Postgres 中的 BM25 入门  
  
**Postgres** 原生不支持 **BM25**，但正如我们所见，有多种方法可以将其引入数据库，从基于 SQL 的原型到像 **ParadeDB** 的 `pg_search` 这样的完整扩展。每种方法都在简单性、性能和维护工作量之间进行权衡，但它们都拥有一个共同的目标：在 **Postgres** 内部实现更好、更有意义的搜索结果。  
      
#### [PolarDB 学习图谱](https://www.aliyun.com/database/openpolardb/activity "8642f60e04ed0c814bf9cb9677976bd4")
  
  
#### [PostgreSQL 解决方案集合](../201706/20170601_02.md "40cff096e9ed7122c512b35d8561d9c8")
  
  
#### [德哥 / digoal's Github - 公益是一辈子的事.](https://github.com/digoal/blog/blob/master/README.md "22709685feb7cab07d30f30387f0a9ae")
  
  
#### [About 德哥](https://github.com/digoal/blog/blob/master/me/readme.md "a37735981e7704886ffd590565582dd0")
  
  
![digoal's wechat](../pic/digoal_weixin.jpg "f7ad92eeba24523fd47a6e1a0e691b59")
  
