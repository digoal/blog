## 跟着 ParadeDB 学 AI 搜索: 11 Tantivy 简介 (Introduction to Tantivy)  
          
### 作者          
digoal          
          
### 日期          
2025-12-08          
          
### 标签          
PostgreSQL , 搜索 , paradedb , tantivy , 语义搜索 , 关键词搜索 , ranking , 混合搜索 , RAG , RRF          
          
----          
          
## 背景          
看完 paradedb 的文档 , 我知道它也在朝着 AI 搜索数据库的方向发展.          
          
AI 搜索, 目前的共识需求是: 语义搜索 , 关键词搜索 , 标量搜索 , 混合搜索! ( 个人认为应该还要加上 图、GIS等多模态功能 )          
          
目前围绕AI 搜索需求在做的产品, 我大概总结一下:          
- PG 的插件: vectorchord + vectorchord-bm25 + pg_tokenizer          
- PG 商业发行版: 海量 vastbase 向量版、vexdb          
- PG 的插件(本文主角): paradedb          
- OceanBase SeekDB.          
- DuckDB: vss + fts          
          
好的, 话不多说, 下面就跟着 ParadeDB 文档来体系化学习一下AI 搜索          
          
https://www.paradedb.com/learn          
          
## Tantivy 简介 (Introduction to Tantivy)  
  
**Tantivy** 是一个用 **Rust** 编写的**快速** **全文搜索 (Full-Text Search)** 库，它以现代性能优化重新构想了 Apache Lucene 的设计。像 Lucene 一样，Tantivy 是一个您可以直接嵌入到应用程序中的**库 (Library)** ，而不是作为一个独立服务运行的**搜索引擎 (Search Engine)** 。可以把它看作是 Lucene 核心原则的现代、基于 Rust 的演进。  
  
该项目源于其创建者 Paul Masurel 对搜索引擎长达十年的痴迷，以及他发现“Rust 以令人惊叹的优雅解决了我在 C++ 或 Java 中经历过的所有痛点。”这个最初的 **Rust 学习练习 (Rust learning exercise)** 现已发展成为一个生产就绪的搜索库，它挑战了**实现强大搜索功能需要复杂基础设施**的假设。  
  
Tantivy 遵循 Lucene 的基本架构和算法，包括 **BM25 评分 (BM25 scoring)** 和相似的**索引策略 (indexing strategies)** ，但它利用了 Rust 的**内存安全 (memory safety)** 和**性能特性 (performance characteristics)** ，以及一些**创新优化 (innovative optimizations)** ，突破了现代硬件可能性的界限。其结果是一个启动时间不到 10 毫秒的搜索库，在基准测试中运行速度大约是 Lucene 的两倍，同时提供同等的搜索功能。  
  
  
## Tantivy 的工作原理 (How Tantivy Works)  
  
像 Lucene 一样，Tantivy 遵循**基于 Schema 的方法 (schema-based approach)** ，您需要在事前定义可搜索数据的**结构 (structure)** 和**类型 (types)** 。这允许该库构建**专业化索引 (specialized indexes)** ，针对不同类型的查询进行优化，包括用于文本搜索的**倒排索引 (inverted indexes)** ，以及用于**分面 (faceting)** 和**点查询 (point lookup queries)** 的**列式快速字段 (columnar fast fields)** 。  
  
### 分段架构 (The Segmented Architecture)  
  
Tantivy 将索引组织成多个小的“ **段 (segments)** ”，而不是维护一个庞大的整体索引结构。这种**分段方法 (segmented approach)** 实现了几个关键能力：  
  
  * **并发索引 (Concurrent Indexing):** 多个线程可以同时索引文档而不会互相阻塞。  
  * **内存管理 (Memory Management):** 可以索引大型数据集，而无需将所有内容加载到 RAM 中。  
  * **增量更新 (Incremental Updates):** 新文档会创建新的段，避免代价高昂的**完整索引重建 (full index rebuilds)** 。  
  
每个段都作为一个**独立的、不可变 (independent, immutable)** 的单元运行，其中包含自己的**倒排索引 (inverted indexes)** 、**文档存储 (document storage)** 和**元数据 (metadata)** 。在搜索操作期间，Tantivy **并行查询 (queries in parallel)** 所有段并**合并结果 (merges results)** ，同时后台进程会定期将较小的段**合并 (merge)** 为较大的段以实现最佳性能。  
  
### 搜索与检索 (Search and Retrieval)  
  
搜索操作通过将查询解析为针对倒排索引和列式快速字段的**执行计划 (execution plans)** 来工作。Tantivy 使用 **BM25 评分 (BM25 scoring)** 进行**相关性排序 (relevance ranking)** ，并支持**布尔查询 (boolean queries)** 、**短语匹配 (phrase matching)** 和**模糊搜索 (fuzzy search)** 。该库利用**有限状态传感器 (Finite State Transducers, FSTs)** 来实现高效的**词项字典存储 (term dictionary storage)** ，并实现了复杂的**整数压缩技术 (integer compression techniques)** 以最小化内存占用。  
  
结果以**相关性顺序 (relevance order)** 返回，并具有最小的**内存分配开销 (memory allocation overhead)** ，这得益于 Rust 的**零成本抽象 (zero-cost abstractions)** 和整个搜索管道中仔细的内存管理。  
  
## 关键特性 (Key Features)  
  
Tantivy 包括了您对现代搜索库期望的核心功能：  
  
**文本分析 (Text Analysis):**  
* 具有语言支持的**可配置分词管道 (Configurable tokenization pipeline)**  
* **词形还原 (Stemming)** 以匹配单词变体 (如 running, runs, ran)  
* **停用词移除 (Stop word removal)** 和自定义文本处理  
* 常见语言的内置配置  
* 能够通过新的**分词器 (tokenizers)** 和行为进行扩展 (例如: Lindera Tantivy)  
  
**查询能力 (Query Capabilities):**  
* **BM25 相关性评分 (BM25 relevance scoring)** 用于结果排名  
* **模糊搜索 (Fuzzy search)** 用于处理拼写错误和变体  
* 带有**邻近匹配 (proximity matching)** 的**短语查询 (Phrase queries)**  
* **布尔逻辑 (Boolean logic)** (AND, OR, NOT) 组合多个词项和字段  
* 针对数字和日期字段的**范围查询 (Range queries)**  
* **分面搜索 (Faceted search)** 用于过滤和聚合  
  
**性能特性 (Performance Features):**  
* **快速字段 (Fast fields)** ，以**列式格式 (columnar format)** 存储关联数据，实现高效排序和聚合，无需完整文档检索  
* **压缩文档存储 (Compressed document storage)** 以节省空间  
* **多线程索引 (Multithreaded indexing)** ，可配置内存使用  
  
  
## 何时选择 Tantivy (When to Choose Tantivy)  
  
当您需要**搜索功能直接嵌入到您的应用程序中**时，Tantivy 表现出色。它通常用于桌面应用程序、命令行工具和**运行单独搜索基础设施不切实际 (managing separate search infrastructure isn't practical)** 的 Web 应用程序中。  
  
**单进程应用程序 (Single-Process Applications):** 桌面软件、CLI 工具和单服务器 Web 应用程序受益于 Tantivy 的**嵌入式 (embedded)** 特性。搜索索引与您的应用程序数据并存，消除了**网络延迟 (network latency)** 和**基础设施复杂性 (infrastructure complexity)** 。  
  
**资源受限环境 (Resource-Constrained Environments):** **边缘计算 (Edge computing)** 、**物联网设备 (IoT devices)** 以及内存有限的环境受益于 Tantivy 的效率。该库的**最小资源要求 (minimal resource requirements)** 使复杂的搜索在运行 Elasticsearch 不切实际的情况下成为可能。  
  
**开发和测试 (Development and Testing):** 嵌入式方法简化了开发工作流程。您的**测试套件 (test suite)** 针对与生产相同的搜索实现运行，无需外部服务或复杂的测试设置。  
  
**实时搜索要求 (Real-Time Search Requirements):** 需要在数据更改后**立即 (immediate)** 搜索可用性的应用程序受益于 Tantivy 的快速索引。新文档在**几毫秒内 (within milliseconds)** 变得可搜索，而不是需要单独的批量处理。  
  
库(library)方法意味着**搜索可用性 (search availability)** 与您的应用程序绑定，没有单独的服务需要管理、监控或保持同步。这也简化了开发，因为您在测试期间无需协调多个服务。  
  
  
## Tantivy 生态系统 (The Tantivy Ecosystem)  
  
如果您需要的不仅仅是库，而是一个**完整的搜索引擎 (complete search engine)** ，那么有几个项目构建在 Tantivy 之上以提供更高级别的功能。正如 Lucene 作为 Elasticsearch 和 Solr 等搜索服务器的基础一样，Tantivy 也已成为专业搜索解决方案的基础。  
  
**Quickwit** 基于 Tantivy 构建，创建了一个专为**日志管理 (log management)** 和**可观测性数据 (observability data)** 设计的**分布式搜索引擎 (distributed search engine)** 。在 Elasticsearch 可能难以应对日志数据的**体量 (volume)** 和**速度 (velocity)** 的情况下，Quickwit 利用 Tantivy 的效率加上**云原生架构 (cloud-native architecture)** 来处理大规模的日志摄取和搜索工作负载。它特别适合需要搜索**数 PB 级时间序列数据 (petabytes of time-series data)** 的应用程序。  
  
**ParadeDB** 采取了不同的方法，将 Tantivy 作为**扩展 (extension)** 直接嵌入到 **PostgreSQL** 中。这使您无需离开现有的数据库基础设施，即可获得现代搜索功能，包括 BM25 评分和高级文本分析。ParadeDB 弥合了传统 SQL 数据库和现代搜索引擎之间的差距，让您可以将复杂的搜索查询与常规数据库操作一起运行。  
  
这些生态系统项目展示了 Tantivy 作为构建完整搜索解决方案基础的灵活性。  
  
  
  
## 入门 (Getting Started)  
  
典型的 Tantivy 集成遵循一个简单的模式：定义 **Schema**、创建**索引 (index)** 、添加**文档 (documents)** 和**搜索 (search)** 。以下是最小实现的代码示例：  
  
```rust  
use tantivy::*;  
  
// 定义 schema 并创建索引  
let mut schema_builder = Schema::builder();  
let title = schema_builder.add_text_field("title", TEXT | STORED);  
let content = schema_builder.add_text_field("content", TEXT);  
let schema = schema_builder.build();  
let index = Index::create_in_ram(schema);  
  
// 添加文档  
let mut index_writer = index.writer(50_000_000)?;  
  
index_writer.add_document(doc!(  
    title => "Sample Document",  
    content => "This is sample content for searching."  
))?;  
  
index_writer.commit()?;  
  
// 搜索  
let reader = index.reader()?;  
let searcher = reader.searcher();  
let query_parser = QueryParser::for_index(&index, vec![title, content]);  
let query = query_parser.parse_query("sample")?;  
let top_docs = searcher.search(&query, &TopDocs::with_limit(10))?;  
```  
  
该示例使用**内存中索引 (in-memory index)** 以简化，但生产应用程序通常使用**基于磁盘的索引 (disk-based indexes)** 以实现持久性。`writer(50_000_000)` 调用分配 50MB 作为**索引缓冲区 (indexing buffer)** ，Tantivy 的内存管理通过其**自定义分配策略 (custom allocation strategies)** 确保该空间得到高效利用。更多示例请参见 **Tantivy 文档 (Tantivy documentation)** 。  
  
  
## 总结 (Summary)  
  
Tantivy 代表了我们思考搜索基础设施方式的**根本性转变 (fundamental shift)** 。它源于一位开发者对 Rust 潜力的探索，现已发展成为一个生产就绪的库，挑战了性能、简单性和功能之间的传统**权衡 (trade-offs)** 。  
  
通过用**现代系统编程原则 (modern systems programming principles)** (并且没有 **JVM**) 重新构想 Lucene 久经考验的架构，Tantivy 证明了您不必在强大的搜索功能和操作简单性之间做出选择。作为独立的库以及 Quickwit 和 ParadeDB 等项目的基础，Tantivy 正在**重塑 (reshaping)** 搜索技术的可能性。  
  
-----  
  
# 附录1: 同一个token是不是可能存在于不同的段中? 如果段特别多, 搜索该token是不是需要等所有段搜索结束? 然后汇聚所有结果进行ranking?  
  
## 回答  
  
是的，您的理解非常准确。  
  
## 🔍 Token 与 段 (Segment) 的关系  
  
### 1. 同一个 Token 是否存在于不同段中？  
  
**答案是：是的。**  
  
在一个基于 **段 (Segment)** 的搜索架构（如 Tantivy 或 Lucene）中，同一个 **词项 (Token)** 完全可能存在于不同的段中。  
  
* **写入过程：** 当文档被索引时，它们被写入新的（或当前的）**段** 。  
* **重复出现：** 如果您在时间 $T_1$ 索引了一个包含词项 “Tantivy” 的文档 A（写入了 **段 1**），然后在时间 $T_2$ 索引了另一个包含相同词项 “Tantivy” 的文档 B（写入了 **段 2**），那么词项 “Tantivy” 就会出现在 **段 1** 和 **段 2** 各自的**倒排索引 (Inverted Index)** 中。  
* **不可变性：** 一旦一个段被创建，它是**不可变**的。因此，新的文档总是创建新的段，直到后台的**合并 (Merging)** 过程将它们组合起来。  
  
## ⚡ 搜索与结果汇聚 (Aggregation)  
  
### 2. 搜索 Token 是否需要等所有段搜索结束？  
  
**答案是：是的，为了进行全局的准确排序和汇聚结果。**  
  
搜索操作的流程是高度并行的，但最终结果需要全局汇聚：  
  
* **并行查询 (Parallel Query):** 当您执行查询时，Tantivy 会**同时**向所有现有的**段**发送该查询。这是为了最大化搜索速度。  
* **局部评分 (Local Scoring):** 每个段都会独立地计算其内部匹配文档的**相关性分数 (Relevance Score)** （例如使用 BM25 算法）。  
* **全局汇聚与排序 (Global Aggregation and Ranking):** 为了确定最终的 **Top N** 结果，搜索引擎必须收集所有段返回的**局部匹配文档列表及其分数**，然后在全局范围内对这些分数进行统一比较和排序。  
* **必需的等待：** 只有在所有段的局部搜索都完成后，系统才能保证找到**全局最相关**的文档，并将其返回给用户。因此，从用户的角度看，搜索操作必须等待所有段的结果。  
  
**简而言之：** 搜索在所有段上**并行进行**，但**结果的最终排序和呈现**需要等待所有并行的子任务完成。  
  
-----  
  
## deepwiki 基于 paradedb 代码的回答  
  
是的，同一个token可以存在于不同的段中。搜索时需要遍历所有相关段，但系统通过并行化和优化策略来缓解性能问题。  
  
  
### Token在段中的分布  
  
在Tantivy的LSM树结构中，同一个token确实可能存在于不同的段中。每个段都有自己的倒排索引，当新数据写入时会创建新段，而旧段中的token仍然保留  。  
  
### 搜索执行机制  
  
搜索过程确实需要查询多个段：  
  
1. **段加载**: `load_metas`函数会根据MVCC可见性规则加载所有相关段    
  
2. **搜索执行**: `search_segments`函数为每个段创建独立的搜索迭代器    
  
3. **结果汇聚**: `MultiSegmentSearchResults`结构负责管理来自多个段的结果    
  
### 性能优化策略  
  
系统采用多种策略优化性能：  
  
1. **并行搜索**: `segments_to_query`函数支持并行工作负载分配，多个worker可以同时处理不同段    
  
2. **段合并**: 后台合并进程会将小段合并成大段，减少段数量    
  
3. **目标段数控制**: 可以通过`target_segment_count`配置优化段数量与并行度的平衡    
  
### 性能考虑  
  
虽然多段搜索确实存在开销，但通过上述优化策略，系统能够有效管理性能。段数量应与CPU核心数和并行worker数相匹配以获得最佳性能  。  
  
## Notes  
  
- 段的可见性通过MVCC规则控制，确保事务一致性  
- 可变段在读取时才进行索引，可能影响读取性能  
- 合并策略可配置以平衡写入和读取性能  
    
#### [PolarDB 学习图谱](https://www.aliyun.com/database/openpolardb/activity "8642f60e04ed0c814bf9cb9677976bd4")
  
  
#### [PostgreSQL 解决方案集合](../201706/20170601_02.md "40cff096e9ed7122c512b35d8561d9c8")
  
  
#### [德哥 / digoal's Github - 公益是一辈子的事.](https://github.com/digoal/blog/blob/master/README.md "22709685feb7cab07d30f30387f0a9ae")
  
  
#### [About 德哥](https://github.com/digoal/blog/blob/master/me/readme.md "a37735981e7704886ffd590565582dd0")
  
  
![digoal's wechat](../pic/digoal_weixin.jpg "f7ad92eeba24523fd47a6e1a0e691b59")
  
