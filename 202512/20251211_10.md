## 大学生数据库实践课: 11.4 vectorchord向量索引       
                          
### 作者                          
digoal                          
                          
### 日期                          
2025-12-11                          
                          
### 标签                          
PostgreSQL , DuckDB , 语义搜索 , 向量搜索 , 关键词检索 , 全文检索 , 标量检索 , 混合搜索 , 多模态搜索 , 重排序 , embedding , document split , ORC , 大模型 , 多模态大模型 , Dify , 压力测试 , 索引优化 , 倒排向量索引 , Ivfflat , 图向量索引 , HNSW , DiskANN , 量化 , rabitq , sbq , 二值量化 , bm25 , 相关性 , 相似性 , 召回率 , pgbench , 数据集 , ann-benchmarks , 图搜索 , PGQ , 递归 , 深度优先 , 广度优先 , 最短路径 , N度关系 , LLM , Ollama                          
                          
----                          
                          
## 背景                          
            
vectorchord deepwiki:        
  
https://deepwiki.com/search/-1vectorchord_74e5118c-4406-4309-8491-104772c4605f?mode=fast      
        
  
面向大学生通俗讲解以下内容:    
1、vectorchord 的优势讲解    
2、vectorchord ivf 索引原理    
3、vectorchord 图 索引原理    
4、vectorchord ivf 索引使用示例    
5、vectorchord 图 索引使用示例    
6、vectorchord ivf 索引优化实践    
7、vectorchord 图 索引优化实践       
8、RaBitQ 在ivF和图索引中的设计原理  
9、vectorchord 在提升性能、召回率方面使用了哪些技术?  
          
-----     
  
# VectorChord 优势详解  
  
VectorChord 是一个 PostgreSQL 扩展，专为高性能、可扩展的向量相似性搜索而设计。以下是它的核心优势：  
  
## 🚀 性能优势  
  
**查询速度提升 5 倍**：相比 pgvector 的 HNSW 实现，VectorChord 的查询速度最高提升 5 倍  。  
  
**插入吞吐量提升 16 倍**：数据插入性能比传统方案提升 16 倍  。  
  
**索引构建速度提升 16 倍**：构建索引的速度比 pgvector 快 16 倍  。  
  
## 💰 成本效益  
  
**极致性价比**：存储 400,000 个向量仅需 1 美元，比 Pinecone 便宜 6 倍，比 pgvector/pgvecto.rs 便宜 26 倍  。  
  
**内存效率**：仅需 32GB 内存即可查询 1 亿个 768 维向量，在 35ms 延迟内达到 95% 召回率  。  
  
## 🔧 技术特性  
  
**无缝兼容**：完全兼容 pgvector 的数据类型和语法，可以直接替换使用，无需修改现有代码  。  
  
**外部索引构建**：支持在 GPU 上进行 K-means 聚类，大幅加速索引构建过程  。  
  
**RaBitQ 压缩技术**：使用创新的 RaBitQ 算法进行向量量化，在保持搜索质量的同时大幅减少存储空间  。  
  
**长向量支持**：支持高达 60,000 维的向量，远超 pgvector 的 16,000 维限制  。  
  
## 📈 扩展性与可靠性  
  
**水平扩展**：基于水平扩展架构，可轻松扩展到 10,000+ QPS，支持 500 万到 1 亿向量的查询  。  
  
**生产验证**：已在关键生产环境中部署，可靠处理超过 30 亿个向量  。  
  
## 🛠️ 使用便捷性  
  
**Docker 快速部署**：提供官方 Docker 镜像，几条命令即可启动  。  
  
**简单 SQL 语法**：使用标准 SQL 语法进行向量搜索，学习成本低  。  
  
## Notes  
  
VectorChord 是 pgvecto.rs 的继任者，提供了更好的稳定性和性能  。它支持两种索引类型：`vchordrq`（倒排文件索引）和 `vchordg`（基于图的索引），可根据不同场景选择最适合的索引方式  。  
  
  
-----    
  
# VectorChord IVF 索引原理详解  
  
## 核心思想：分而治之  
  
IVF（Inverted File，倒排文件）索引的核心思想是"分而治之"。想象一下，你要在一个巨大的图书馆里找相似的书，与其一本一本地翻阅，不如先把书按类别分到不同的书架上，找的时候只去最相关的几个书架查找。  
  
## 🏗️ 索引构建过程  
  
### 1. K-means 聚类：创建"书架"  
  
VectorChord 首先使用 K-means 算法对所有向量进行聚类，创建一组质心（centroids）  。这些质心就像是图书馆的不同"书架"。  
  
```sql  
CREATE INDEX ON items USING vchordrq (embedding vector_l2_ops)  
WITH (options = $$  
residual_quantization = true  
[build.internal]  
lists = [33]  -- 创建33个"书架"  
spherical_centroids = false  
kmeans_dimension = 2  
kmeans_algorithm.hierarchical = {}  
$$);  
```  
  
### 2. 向量分配：书籍上架  
  
每个向量会被分配到距离最近的质心对应的倒排列表中  。这个过程就像把每本书放到最合适的书架上。  
  
### 3. 残差量化：压缩存储  
  
VectorChord 支持残差量化技术  ，存储向量与质心的差值而非原始向量，大幅减少存储空间。  
  
## 🔍 查询过程  
  
### 1. 质心选择：确定目标书架  
  
查询时，系统首先计算查询向量与所有质心的距离，选择最近的 `n` 个质心（通过 `probes` 参数控制）  。  
  
```sql  
SET vchordrq.probes = '16';  -- 只搜索最近的16个"书架"  
```  
  
### 2. 候选筛选：快速浏览  
  
在选中的倒排列表中，使用量化后的向量进行快速距离计算，找出候选结果  。  
  
### 3. 精确重排：仔细比对  
  
最后使用原始向量对候选结果进行精确的距离计算和排序  。  
  
## ⚡ 性能优化技术  
  
### 1. 外部构建：GPU 加速  
  
VectorChord 支持在外部（如 GPU）进行 K-means 聚类  ，大幅加速索引构建过程。  
  
### 2. 随机投影：降维处理  
  
对向量进行随机投影处理  ，在保持距离关系的同时减少计算复杂度。  
  
### 3. 并行构建：多线程加速  
  
支持并行构建索引  ，充分利用多核 CPU 资源。  
  
## 📊 关键参数调优  
  
- **lists**：聚类数量，通常设为 `4*sqrt(n)` 到 `16*sqrt(n)`    
- **probes**：搜索的聚类数量，越大召回率越高但速度越慢  
- **epsilon**：重排序扩展因子，控制候选集大小    
  
## Notes  
  
IVF 索引特别适合大规模数据集（百万到十亿级别）的近似最近邻搜索。通过合理配置参数，可以在召回率和性能之间找到最佳平衡点。VectorChord 的实现还支持多种距离度量（L2、内积、余弦）和向量类型（float32、float16、量化向量）  。  
  
  
  
  
  
-----    
  
# IVFFlat 分区优化原理详解  
  
## 核心思想：智能分区减少搜索范围  
  
IVFFlat 的分区优化本质上是"先分类，再搜索"的策略。就像在大型商场找商品，不是逐个货架查看，而是先去服务台问清楚商品在哪个区域，然后只搜索相关区域。  
  
## 🎯 分区机制详解  
  
### 1. K-means 聚类分区  
  
VectorChord 使用 K-means 算法将向量空间划分为多个区域（称为 "lists" 或分区）  。每个分区由一个质心（centroid）代表：  
  
```rust  
// 根据数据量选择不同的K-means策略  
pub fn lloyd_k_means<'a>(  
    pool: &'a rayon::ThreadPool,  
    d: usize,  
    samples: SquareMut<'a>,  
    c: usize,  // 分区数量  
    seed: [u8; 32],  
    is_spherical: bool,  
) -> Box<dyn KMeans + 'a>  
```  
  
### 2. 层次化分区优化  
  
对于大规模数据，VectorChord 采用层次化分区策略  ：  
  
```rust  
// 先粗分，再细分  
fn index(  
    partitions: &[Box<dyn KMeans + '_>],  
    coarse_centroids: &Square,  // 粗粒度质心  
    offsets: &[usize],  
) -> impl Fn(&[f32]) -> (f32, usize) + Sync  
```  
  
这种两层的分区结构：  
- **第一层**：将数据粗分为几个大区域  
- **第二层**：在每个大区域内再细分  
  
### 3. 智能分区分配  
  
使用 Modified Webster 方法分配分区数量，避免某些分区过空或过满  ：  
  
```rust  
fn modified_webster_method(n: usize, weight: &[usize]) -> Vec<usize> {  
    // 根据权重动态分配分区数量  
    let quotient = weight[index] as f64 / (seats[index] as f64 + 0.5);  
}  
```  
  
## ⚡ 查询优化原理  
  
### 1. 选择性搜索  
  
查询时只搜索最近的 `probes` 个分区，而不是全部分区  ：  
  
```rust  
pub fn flat_index(centroids: &Square) -> impl Fn(&[f32]) -> (f32, usize) + Sync {  
    move |sample| {  
        let mut result = (f32::INFINITY, 0);  
        for (i, centroid) in centroids.into_iter().enumerate() {  
            let dis = f32::reduce_sum_of_d2(sample, centroid);  
            if dis <= result.0 {  
                result = (dis, i);  // 找到最近的质心  
            }  
        }  
        result  
    }  
}  
```  
  
### 2. 并行计算优化  
  
使用 Rayon 并行计算加速距离计算  ：  
  
```rust  
this.pool.install(|| {  
    targets  
        .par_iter_mut()  
        .zip(samples.par_iter_mut())  
        .for_each(|(target, sample)| {  
            *target = index(sample).1;  // 并行分配到最近分区  
        });  
});  
```  
  
## 📊 关键优化参数  
  
### 1. 分区数量（lists）  
  
- 过少：每个分区包含过多向量，搜索效率低  
- 过多：管理开销大，可能产生空分区  
- 推荐：`4*sqrt(n)` 到 `16*sqrt(n)`    
  
### 2. 搜索分区数（probes）  
  
- 控制查询时检查的分区数量  
- 越大召回率越高，但查询时间越长  
- 典型值：10-100  
  
### 3. 构建线程数  
  
- 并行构建索引的线程数    
- 影响索引构建速度，不影响查询性能  
  
## 🔄 实际应用示例  
  
```python  
# 配置分区优化参数  
metric_ops, ivf_config = get_ivf_ops_config(  
    metric="l2",  
    workers=8,           # 构建线程数  
    k=100,              # 分区数量  
)  
```  
  
## Notes  
  
IVFFlat 的分区优化通过减少搜索空间实现加速，核心是平衡分区粒度和搜索范围。层次化分区进一步优化了大规模数据的处理效率。实际使用中需要根据数据规模和查询模式调整参数以达到最佳性能  。  
  
  
  
  
-----    
  
  
# VectorChord 图索引原理详解  
  
## 核心思想：构建向量世界的"社交网络"  
  
图索引（vchordg）的核心思想是构建一个向量之间的"社交网络"。想象一下，每个人（向量）都有一些朋友（相邻向量），相似的人会成为朋友，通过朋友的朋友可以找到更多相似的人。这个网络结构让我们能够快速找到最相似的人。  
  
## 🕸️ HNSW 层次化图结构  
  
### 1. 多层网络架构  
  
VectorChord 使用 HNSW（Hierarchical Navigable Small World）算法，构建一个层次化的图结构  ：  
  
```rust  
pub struct VchordgIndexOptions {  
    pub m: u32,              // 每层最大连接数（默认32）  
    pub alpha: Vec<f32>,     // 层级参数（默认[1.0, 1.2]）  
    pub ef_construction: u32, // 构建时的搜索宽度（默认64）  
    pub beam_construction: u32, // 构建时的束搜索宽度（默认1）  
}  
```  
  
这个结构就像一个多层社交网络：  
- **顶层**：少量"超级连接者"，连接距离很远的向量  
- **中间层**：中等数量的"活跃用户"  
- **底层**：所有向量，密集连接  
  
### 2. 图的初始化  
  
构建索引时，首先创建三个关键页面  ：  
  
```rust  
// 页面0：存储元数据  
let mut meta_guard = index.extend(Opaque { next: u32::MAX, link: 1 }, false);  
// 页面1：存储顶点信息  
let vertex_guard = index.extend(Opaque { next: u32::MAX, link: 2 }, true);  
// 页面2：存储向量数据  
let vector_guard = index.extend(Opaque { next: u32::MAX, link: u32::MAX }, false);  
```  
  
## 🔗 图构建过程  
  
### 1. 向量插入与连接  
  
新向量插入时，系统会：  
1. 从顶层开始搜索，找到最近的入口点  
2. 逐层向下，在每层找到最近的候选者  
3. 在底层建立精确连接    
  
```rust  
// 从入口点开始搜索  
let start = if start.into_inner().is_none() {  
    // 如果没有入口点，设置当前点为入口  
    *dst = OptionPointer::some(t);  
    return;  
} else {  
    start  
};  
  
// 预处理查询向量  
let lut = O::Vector::preprocess(vector);  
let mut visited = Visited::new();  
let mut candidates = Candidates::new(beam as usize, prefetch_vectors);  
```  
  
### 2. 动态连接策略  
  
每个向量最多连接 `m` 个邻居（默认32个）  。连接策略基于：  
- **距离优先**：优先连接距离最近的向量  
- **多样性保证**：避免所有向量都连接到同一个热门向量  
- **层级控制**：高层连接少但跨度大，底层连接多但距离近  
  
## 🔍 搜索过程  
  
### 1. 贪心搜索算法  
  
查询时使用贪心搜索策略  ：  
  
```rust  
SearchOptions {  
    ef_search: gucs::vchordg_ef_search(),      // 搜索宽度（默认64）  
    beam_search: gucs::vchordg_beam_search(),  // 束搜索大小（默认1）  
    max_scan_tuples: gucs::vchordg_max_scan_tuples(),  
    io_search: gucs::vchordg_io_search(),  
    io_rerank: gucs::vchordg_io_rerank(),  
}  
```  
  
搜索过程就像在社交网络中找人：  
1. **从顶层开始**：找到几个可能的目标区域  
2. **逐层细化**：每层都缩小搜索范围  
3. **底层精确搜索**：在最后一层找到最相似的结果  
  
### 2. 候选集管理  
  
使用优先队列管理候选者，始终保持最有希望的 `ef_search` 个候选者（默认64个）  。  
  
## ⚡ 性能优化技术  
  
### 1. 并行构建  
  
支持 PostgreSQL 17+ 的并行索引构建  ：  
  
```rust  
unsafe fn parallel_build(  
    index_relation: pgrx::pg_sys::Relation,  
    heap_relation: pgrx::pg_sys::Relation,  
    index_info: *mut pgrx::pg_sys::IndexInfo,  
    // ... 其他参数  
) {  
    // 多个进程并行构建图结构  
    let scan = unsafe { pgrx::pg_sys::table_beginscan_parallel(heap_relation, tablescandesc) };  
    // ...  
}  
```  
  
### 2. 内存优化  
  
- **延迟加载**：只在需要时加载向量数据  
- **缓存友好**：数据结构设计考虑 CPU 缓存局部性  
- **预取机制**：提前加载可能需要的数据  
  
## 📊 关键参数调优  
  
| 参数 | 默认值 | 作用 | 调优建议 |  
|------|--------|------|----------|  
| `m` | 32 | 每层最大连接数 | 数据量大时可增加，但会增加内存使用 |  
| `ef_construction` | 64 | 构建时搜索宽度 | 值越大图质量越好，但构建越慢 |  
| `ef_search` | 64 | 查询时搜索宽度 | 值越大召回率越高，但查询越慢 |  
| `alpha` | [1.0, 1.2] | 层级参数 | 控制不同层的连接密度 |  
  
## 🆚 与 IVF 索引对比  
  
| 特性 | vchordg（图索引） | vchordrq（IVF索引） |  
|------|-------------------|---------------------|  
| **召回率** | 更高（>99%） | 可调节（90-99%） |  
| **构建速度** | 较快 | 需要聚类，较慢 |  
| **内存使用** | 较高 | 较低（量化压缩） |  
| **适用场景** | 中等规模（<100M） | 大规模（100M-1B） |  
| **动态更新** | 支持 | 需要重建 |  
  
## Notes  
  
图索引特别适合对召回率要求极高的场景，如推荐系统、语义搜索等。它通过构建向量间的"社交网络"实现了高效的近似最近邻搜索，在保证高精度的同时提供了良好的查询性能  。  
  
  
  
-----    
  
# VectorChord IVF 索引使用示例  
  
## 🚀 快速开始示例  
  
### 1. 基础环境准备  
  
首先启动 VectorChord 数据库并连接  ：  
  
```bash  
# 启动 Docker 容器  
docker run \  
  --name vectorchord-demo \  
  -e POSTGRES_PASSWORD=mysecretpassword \  
  -p 5432:5432 \  
  -d ghcr.io/tensorchord/vchord-postgres:pg18-v1.0.0  
  
# 连接数据库  
psql -h localhost -p 5432 -U postgres  
```  
  
### 2. 创建扩展和数据表  
  
```sql  
-- 创建 VectorChord 扩展（会自动加载 pgvector）  
CREATE EXTENSION IF NOT EXISTS vchord CASCADE;  
  
-- 创建包含向量列的表  
CREATE TABLE documents (  
    id bigserial PRIMARY KEY,  
    title TEXT,  
    content TEXT,  
    embedding vector(768)  -- 768维向量  
);  
```  
  
### 3. 插入示例数据  
  
```sql  
-- 插入一些示例向量  
INSERT INTO documents (title, content, embedding) VALUES  
    ('机器学习基础', '这是关于机器学习的基础教程',   
     (SELECT ARRAY(SELECT random() FROM generate_series(1, 768))::real[])),  
    ('深度学习入门', '深度学习的入门指南',   
     (SELECT ARRAY(SELECT random() FROM generate_series(1, 768))::real[]));  
  
-- 批量插入更多数据  
INSERT INTO documents (title, content, embedding)  
SELECT   
    '文档 ' || i,  
    '内容 ' || i,  
    (SELECT ARRAY(SELECT random() FROM generate_series(1, 768))::real[])  
FROM generate_series(3, 10000) i;  
```  
  
## 📊 创建 IVF 索引  
  
### 1. 基础索引创建  
  
```sql  
-- 使用默认参数创建 IVF 索引  
CREATE INDEX documents_embedding_idx   
ON documents   
USING vchordrq (embedding vector_l2_ops);  
```  
  
### 2. 自定义参数创建索引  
  
```sql  
-- 使用自定义参数创建索引  
CREATE INDEX documents_embedding_idx   
ON documents   
USING vchordrq (embedding vector_l2_ops)  
WITH (options = $$  
residual_quantization = true  
[build.internal]  
lists = ￼              -- 聚类数量  
build_threads = 8          -- 构建线程数  
spherical_centroids = false  
kmeans_dimension = 2  
kmeans_algorithm.hierarchical = {}  
$$);  
```  
  
### 3. 不同距离度量的索引  
  
```sql  
-- L2 距离索引（欧几里得距离）  
CREATE INDEX idx_l2 ON items USING vchordrq (embedding vector_l2_ops)  
WITH (options = $$residual_quantization = true [build.internal] lists = [33]$$);  
  
-- 内积索引  
CREATE INDEX idx_ip ON items USING vchordrq (embedding vector_ip_ops)  
WITH (options = $$residual_quantization = false [build.internal] lists = [33] spherical_centroids = true$$);  
  
-- 余弦距离索引  
CREATE INDEX idx_cosine ON items USING vchordrq (embedding vector_cosine_ops)  
WITH (options = $$residual_quantization = false [build.internal] lists = [33] spherical_centroids = true$$);  
```  
  
## 🔍 查询示例  
  
### 1. 基础相似性搜索  
  
```sql  
-- 查找最相似的10个文档  
SELECT id, title, embedding <-> '[0.1, 0.2, 0.3, ...]' AS distance  
FROM documents  
ORDER BY embedding <-> '[0.1, 0.2, 0.3, ...]'  
LIMIT 10;  
```  
  
### 2. 配置查询参数  
  
```sql  
-- 设置搜索的聚类数量（影响召回率和速度）  
SET vchordrq.probes = '16';  -- 搜索最近的16个聚类  
  
-- 设置重排序扩展因子（影响候选集大小）  
SET vchordrq.epsilon = 1.9;  -- 扩展90%的候选集  
  
-- 执行查询  
SELECT * FROM documents   
ORDER BY embedding <-> '[0.5, 0.5, 0.5]'   
LIMIT 10;  
```  
  
### 3. 范围查询  
  
```sql  
-- 查找距离小于0.5的所有向量  
SELECT * FROM documents   
WHERE embedding <<->> sphere('[0.1, 0.2, 0.3, ...]', 0.5);  
  
-- 结合 k-NN 和范围查询  
SELECT * FROM documents   
WHERE embedding <<->> sphere('[0.1, 0.2, 0.3, ...]', 1.0)  
ORDER BY embedding <-> '[0.1, 0.2, 0.3, ...]'  
LIMIT 10;  
```  
  
## ⚡ 性能优化示例  
  
### 1. 预热索引  
  
```sql  
-- 将索引加载到内存缓存中  
SELECT vchordrq_prewarm('documents_embedding_idx'::regclass, 0);  
```  
  
### 2. 评估召回率  
  
```sql  
-- 评估查询的召回率  
SELECT * FROM vchordrq_evaluate_query_recall(  
    query => $$SELECT ctid FROM documents ORDER BY embedding <-> '[0.5, 0.25, 1.0]' LIMIT 10$$  
);  
```  
  
### 3. 批量操作示例  
  
```sql  
-- 创建量化表以节省存储空间  
CREATE TABLE documents_quantized (  
    id bigserial PRIMARY KEY,  
    title TEXT,  
    embedding_q rabitq8  -- 8位量化向量  
);  
  
-- 量化向量  
INSERT INTO documents_quantized (title, embedding_q)  
SELECT title, quantize_to_rabitq8(embedding)  
FROM documents;  
  
-- 在量化向量上创建索引  
CREATE INDEX documents_quantized_idx   
ON documents_quantized   
USING vchordrq (embedding_q rabitq8_l2_ops);  
```  
  
## 🛠️ Python 脚本示例  
  
### 1. 外部构建索引  
  
```python  
# 使用 Python 脚本进行大规模数据集的索引构建  
import asyncio  
from scripts.index import build_index, get_ivf_ops_config  
  
# 配置索引参数  
metric_ops, ivf_config = get_ivf_ops_config(  
    metric="l2",  
    workers=8,      # 构建线程数  
    k=100,         # 聚类数量  
)  
  
# 异步构建索引  
async def main():  
    conn = await asyncpg.connect("postgresql://postgres:password@localhost/postgres")  
    finish = asyncio.Event()  
      
    # 启动索引构建  
    build_task = asyncio.create_task(  
        build_index(conn, "documents", 8, metric_ops, ivf_config, finish)  
    )  
      
    # 监控构建进度  
    monitor_task = asyncio.create_task(monitor_index_build(conn, finish))  
      
    await build_task  
    await monitor_task  
  
asyncio.run(main())  
```  
  
## 📈 实际应用场景  
  
### 1. 文档检索系统  
  
```sql  
-- 创建文档表  
CREATE TABLE articles (  
    id bigserial PRIMARY KEY,  
    title TEXT,  
    abstract TEXT,  
    embedding vector(768)  
);  
  
-- 创建索引  
CREATE INDEX articles_embedding_idx   
ON articles   
USING vchordrq (embedding vector_cosine_ops)  
WITH (options = $$residual_quantization = false [build.internal] lists = [200]$$);  
  
-- 搜索相关文章  
WITH query_vector AS (  
    SELECT embedding FROM articles WHERE title = '深度学习入门' LIMIT 1  
)  
SELECT a.title, a.abstract,   
       a.embedding <=> q.embedding AS similarity  
FROM articles a, query_vector q  
WHERE a.id != (SELECT id FROM articles WHERE title = '深度学习入门' LIMIT 1)  
ORDER BY a.embedding <=> q.embedding  
LIMIT 10;  
```  
  
### 2. 图像相似性搜索  
  
```sql  
-- 创建图像特征表  
CREATE TABLE images (  
    id bigserial PRIMARY KEY,  
    filename TEXT,  
    feature_vector vector(512)  
);  
  
-- 创建索引（适合大规模图像库）  
CREATE INDEX images_feature_idx   
ON images   
USING vchordrq (feature_vector vector_l2_ops)  
WITH (options = $$residual_quantization = true [build.internal] lists = [500]$$);  
  
-- 查找相似图像  
SELECT i.filename, i.feature_vector <-> query.feature AS distance  
FROM images i,   
     (SELECT '[0.1, 0.2, ...]'::vector(512) AS feature) query  
ORDER BY i.feature_vector <-> query.feature  
LIMIT 20;  
```  
  
## Notes  
  
IVF 索引特别适合大规模数据集（百万到十亿级别）的近似最近邻搜索  。通过调整 `lists`、`probes` 和 `epsilon` 参数，可以在召回率和性能之间找到最佳平衡点  。对于超大规模数据集，建议使用外部构建工具来加速索引创建过程  。  
  
  
  
  
-----    
  
# VectorChord 图索引使用示例  
  
## 🚀 快速开始示例  
  
### 1. 基础环境准备  
  
首先启动 VectorChord 数据库并连接  ：  
  
```bash  
# 启动 Docker 容器  
docker run \  
  --name vectorchord-demo \  
  -e POSTGRES_PASSWORD=mysecretpassword \  
  -p 5432:5432 \  
  -d ghcr.io/tensorchord/vchord-postgres:pg18-v1.0.0  
  
# 连接数据库  
psql -h localhost -p 5432 -U postgres  
```  
  
### 2. 创建扩展和数据表  
  
```sql  
-- 创建 VectorChord 扩展（会自动加载 pgvector）  
CREATE EXTENSION IF NOT EXISTS vchord CASCADE;  
  
-- 创建包含向量列的表  
CREATE TABLE products (  
    id bigserial PRIMARY KEY,  
    name TEXT,  
    description TEXT,  
    embedding vector(768)  -- 768维向量  
);  
```  
  
### 3. 插入示例数据  
  
```sql  
-- 插入一些示例向量  
INSERT INTO products (name, description, embedding) VALUES  
    ('智能手机', '最新款5G智能手机',   
     (SELECT ARRAY(SELECT random() FROM generate_series(1, 768))::real[])),  
    ('笔记本电脑', '高性能办公笔记本',   
     (SELECT ARRAY(SELECT random() FROM generate_series(1, 768))::real[]));  
  
-- 批量插入更多数据  
INSERT INTO products (name, description, embedding)  
SELECT   
    '产品 ' || i,  
    '描述 ' || i,  
    (SELECT ARRAY(SELECT random() FROM generate_series(1, 768))::real[])  
FROM generate_series(3, 10000) i;  
```  
  
## 📊 创建图索引  
  
### 1. 基础图索引创建  
  
```sql  
-- 使用默认参数创建图索引  
CREATE INDEX products_embedding_idx   
ON products   
USING vchordg (embedding vector_l2_ops);  
```  
  
### 2. 自定义参数创建索引  
  
```sql  
-- 使用自定义参数创建图索引  
CREATE INDEX products_embedding_idx   
ON products   
USING vchordg (embedding vector_l2_ops)  
WITH (options = $$  
m = 32                    -- 每层最大连接数  
alpha = [1.0, 1.2]       -- 层级参数  
ef_construction = 64     -- 构建时搜索宽度  
beam_construction = 1    -- 构建时束搜索宽度  
$$);  
```  
  
### 3. 不同距离度量的索引  
  
```sql  
-- L2 距离索引（欧几里得距离）  
CREATE INDEX idx_l2 ON products USING vchordg (embedding vector_l2_ops);  
  
-- 内积索引  
CREATE INDEX idx_ip ON products USING vchordg (embedding vector_ip_ops);  
  
-- 余弦距离索引  
CREATE INDEX idx_cosine ON products USING vchordg (embedding vector_cosine_ops);  
```  
  
## 🔍 查询示例  
  
### 1. 基础相似性搜索  
  
```sql  
-- 查找最相似的10个产品  
SELECT id, name, embedding <-> '[0.1, 0.2, 0.3, ...]' AS distance  
FROM products  
ORDER BY embedding <-> '[0.1, 0.2, 0.3, ...]'  
LIMIT 10;  
```  
  
### 2. 配置查询参数  
  
```sql  
-- 设置搜索宽度（影响召回率和速度）  
SET vchordg.ef_search = 64;  -- 候选集大小  
  
-- 设置束搜索大小  
SET vchordg.beam_search = 1;  -- 并行搜索路径数  
  
-- 执行查询  
SELECT * FROM products   
ORDER BY embedding <-> '[0.5, 0.5, 0.5]'   
LIMIT 10;  
```  
  
### 3. 范围查询  
  
```sql  
-- 查找距离小于0.5的所有向量  
SELECT * FROM products   
WHERE embedding <<->> sphere('[0.1, 0.2, 0.3, ...]', 0.5);  
  
-- 结合 k-NN 和范围查询  
SELECT * FROM products   
WHERE embedding <<->> sphere('[0.1, 0.2, 0.3, ...]', 1.0)  
ORDER BY embedding <-> '[0.1, 0.2, 0.3, ...]'  
LIMIT 10;  
```  
  
## ⚡ 性能优化示例  
  
### 1. 预热索引  
  
```sql  
-- 将图索引加载到内存缓存中  
SELECT vchordg_prewarm('products_embedding_idx'::regclass);  
```  
  
### 2. 动态调整查询参数  
  
```sql  
-- 高精度搜索（召回率优先）  
SET vchordg.ef_search = 128;  
SET vchordg.beam_search = 4;  
  
-- 快速搜索（速度优先）  
SET vchordg.ef_search = 32;  
SET vchordg.beam_search = 1;  
```  
  
### 3. 监控查询性能  
  
```sql  
-- 查看查询执行计划  
EXPLAIN (ANALYZE, BUFFERS)   
SELECT * FROM products   
ORDER BY embedding <-> '[0.1, 0.2, 0.3]'   
LIMIT 10;  
```  
  
## 📈 实际应用场景  
  
### 1. 推荐系统  
  
```sql  
-- 创建用户行为表  
CREATE TABLE user_interactions (  
    id bigserial PRIMARY KEY,  
    user_id INTEGER,  
    item_id INTEGER,  
    embedding vector(768),  
    timestamp TIMESTAMP  
);  
  
-- 创建图索引  
CREATE INDEX user_interactions_embedding_idx   
ON user_interactions   
USING vchordg (embedding vector_cosine_ops)  
WITH (options = $$  
m = 48  
ef_construction = 128  
$$);  
  
-- 为用户推荐相似商品  
WITH user_profile AS (  
    SELECT embedding FROM user_interactions   
    WHERE user_id = 123   
    ORDER BY timestamp DESC   
    LIMIT 10  
)  
SELECT i.item_id, i.embedding <=> u.embedding AS similarity  
FROM user_interactions i, user_profile u  
WHERE i.user_id != 123  
ORDER BY i.embedding <=> u.embedding  
LIMIT 20;  
```  
  
### 2. 语义搜索  
  
```sql  
-- 创建文档表  
CREATE TABLE articles (  
    id bigserial PRIMARY KEY,  
    title TEXT,  
    content TEXT,  
    embedding vector(768)  
);  
  
-- 创建图索引（高召回率配置）  
CREATE INDEX articles_embedding_idx   
ON articles   
USING vchordg (embedding vector_cosine_ops)  
WITH (options = $$  
m = 64  
ef_construction = 256  
alpha = [1.0, 1.2, 1.4]  
$$);  
  
-- 语义搜索  
SET vchordg.ef_search = 128;  
  
SELECT title, content,   
       embedding <=> query_vector AS similarity  
FROM articles,   
     (SELECT '[0.1, 0.2, ...]'::vector(768) AS embedding) query_vector  
ORDER BY embedding <=> query_vector  
LIMIT 10;  
```  
  
### 3. 图像相似性搜索  
  
```sql  
-- 创建图像特征表  
CREATE TABLE images (  
    id bigserial PRIMARY KEY,  
    filename TEXT,  
    feature_vector vector(512)  
);  
  
-- 创建图索引  
CREATE INDEX images_feature_idx   
ON images   
USING vchordg (feature_vector vector_l2_ops)  
WITH (options = $$  
m = 32  
ef_construction = 64  
$$);  
  
-- 查找相似图像  
SELECT i.filename, i.feature_vector <-> query.feature AS distance  
FROM images i,   
     (SELECT '[0.1, 0.2, ...]'::vector(512) AS feature) query  
ORDER BY i.feature_vector <-> query.feature  
LIMIT 20;  
```  
  
## 📊 参数调优指南  
  
| 参数 | 默认值 | 作用 | 调优建议 |  
|------|--------|------|----------|  
| `m` | 32 | 每层最大连接数 | 数据量大时增加到48-64 |  
| `ef_construction` | 64 | 构建时搜索宽度 | 高质量索引设为128-256 |  
| `ef_search` | 64 | 查询时搜索宽度 | 高召回率设为128-256 |  
| `beam_search` | 1 | 束搜索大小 | 多核CPU可设为2-4 |  
  
## Notes  
  
图索引（vchordg）特别适合对召回率要求极高的场景，如推荐系统、语义搜索等  。它通过构建向量间的"社交网络"实现了高效的近似最近邻搜索，在保证高精度的同时提供了良好的查询性能  。图索引支持多种向量类型（vector、halfvec、rabitq8）和距离度量（L2、内积、余弦）  。  
  
  
  
  
-----    
  
问题: 按hnsw的图结构, 图的层级是动态的, 那么alpha = [1.0, 1.2] 代表什么含义? 仅2层? 如果是这样和hnsw动态层级就矛盾了.  
  
# alpha 参数在 HNSW 图索引中的含义  
  
## 核心解释  
  
`alpha = [1.0, 1.2]` **不代表只有 2 层**，而是控制 HNSW 图中不同层级连接密度的参数数组。HNSW 的层数仍然是动态的，根据数据分布和插入顺序自动确定。  
  
## alpha 参数的实际作用  
  
### 1. 参数定义和验证  
  
在 `VchordgIndexOptions` 中，alpha 被定义为一个浮点数数组  ：  
  
```rust  
pub alpha: Vec<f32>,  
```  
  
验证规则要求：  
- alpha 必须是升序排列  
- 每个值必须在 1.0 到 2.0 之间  
- 第一个值必须是 1.0    
  
### 2. 在剪枝算法中的使用  
  
alpha 参数被传递给剪枝函数，用于控制邻居选择策略  ：  
  
```rust  
let outs = crate::prune::prune(  
    |x, y| O::distance(x.as_borrowed(), y.as_borrowed()),  
    (pointers_u.to_vec(), u),  
    trace.into_iter(),  
    m,  
    &alpha,  // 这里使用 alpha 参数  
    |(_, u)| *u,  
    O::DISTANCE == DistanceKind::L2S,  
);  
```  
  
### 3. 层级控制机制  
  
alpha 数组中的每个值对应一个"层级阈值"：  
- **1.0**：基础层（最底层）的距离阈值  
- **1.2**：上一层的距离阈值  
- 更多值（如果配置）会对应更高层的阈值  
  
当向量在不同层级间选择邻居时，会使用对应的 alpha 值来调整距离判断的严格程度。  
  
## 为什么不是固定层数  
  
HNSW 的动态层级机制体现在：  
  
1. **插入时动态分配层级**：每个向量插入时会随机分配到一个层级（基于概率分布）  
2. **alpha 只控制连接密度**：不限制最大层数，只影响每层的连接策略  
3. **实际层数由数据决定**：随着数据增长，可能会出现更多层  
  
## 配置示例  
  
```sql  
-- 默认配置（2个阈值）  
CREATE INDEX idx ON items USING vchordg (embedding vector_l2_ops)  
WITH (options = $$alpha = [1.0, 1.2]$$);  
  
-- 更多层级控制（3个阈值）  
CREATE INDEX idx ON items USING vchordg (embedding vector_l2_ops)  
WITH (options = $$alpha = [1.0, 1.2, 1.4]$$);  
```  
  
## Notes  
  
alpha 参数是 VectorChord 对 HNSW 算法的一个重要优化，通过不同层级的距离阈值调整，可以在保持搜索质量的同时优化图的连接结构。这与标准 HNSW 实现中的固定连接数策略有所不同，提供了更灵活的层级控制机制  。  
  
  
问题: `alpha = [1.0, 1.2]`时 , 超过第二层的更高层级将使用1.2这个值吗?  
  
  
# alpha 参数在更高层级的使用方式  
  
当 `alpha = [1.0, 1.2]` 时，**超过第二层的更高层级会使用 1.2 这个值**。  
  
## 实现机制  
  
### 1. alpha 数组的索引策略  
  
从代码中可以看到，alpha 参数被传递给剪枝函数  ：  
  
```rust  
let outs = crate::prune::prune(  
    |x, y| O::distance(x.as_borrowed(), y.as_borrowed()),  
    (pointers_u.to_vec(), u),  
    trace.into_iter(),  
    m,  
    &alpha,  // alpha 参数传递  
    |(_, u)| *u,  
    O::DISTANCE == DistanceKind::L2S,  
);  
```  
  
### 2. 层级与 alpha 值的映射关系  
  
根据 alpha 参数的定义和使用方式  ：  
  
- **第 0 层（最底层）** ：使用 `alpha[0] = 1.0`  
- **第 1 层**：使用 `alpha[1] = 1.2`    
- **第 2 层及更高层**：使用 `alpha[last] = 1.2`（数组最后一个值）  
  
这种设计意味着 alpha 数组中的值会被"循环使用"或"取最后一个值"来处理更高的层级。  
  
### 3. 验证规则支持  
  
alpha 参数的验证规则  也支持这种解释：  
- alpha 必须是升序排列  
- 第一个值必须是 1.0  
- 可以有 1-8 个值  
  
如果更高层级不使用 1.2，那么配置更多 alpha 值就没有意义了。  
  
## 实际影响  
  
这种设计让用户可以：  
1. **精细控制低层**：通过设置多个 alpha 值精确控制前几层的连接密度  
2. **简化高层配置**：所有更高层级统一使用最后一个 alpha 值，避免配置过于复杂  
  
例如：  
- `alpha = [1.0, 1.2]`：底层用 1.0，其他所有层用 1.2  
- `alpha = [1.0, 1.1, 1.2, 1.3]`：前 4 层分别用不同值，第 5 层及以上都用 1.3  
  
## Notes  
  
这种实现方式是 VectorChord 对标准 HNSW 算法的优化，既保持了动态层级的灵活性，又提供了可配置的层级控制机制  。用户可以根据数据特性调整 alpha 参数来优化不同层级的连接策略。  
  
  
-----    
  
# VectorChord IVF 索引优化实践  
  
## 🎯 核心优化理念  
  
IVF 索引优化的核心是在**召回率**和**查询速度**之间找到最佳平衡点。就像在图书馆找书，你可以选择快速浏览几个相关书架（速度快但可能遗漏），或者仔细检查更多书架（找到更多但耗时）。  
  
## 📊 关键参数调优实践  
  
### 1. probes 参数优化  
  
`probes` 控制搜索时检查的聚类数量，是最重要的性能调优参数  ：  
  
```sql  
-- 保守设置：速度快，召回率较低  
SET vchordrq.probes = '10';  
  
-- 平衡设置：推荐默认值  
SET vchordrq.probes = '100';  
  
-- 激进设置：高召回率，速度较慢  
SET vchordrq.probes = '500';  
```  
  
**实践建议**：  
- 数据量小（<100万）：probes = 10-50  
- 数据量中等（100万-1000万）：probes = 50-200  
- 数据量大（>1000万）：probes = 200-500  
  
### 2. epsilon 参数优化  
  
`epsilon` 控制重排序时的候选集扩展因子  ：  
  
```sql  
-- 默认值：扩展90%的候选集  
SET vchordrq.epsilon = 1.9;  
  
-- 保守设置：较少扩展，速度快  
SET vchordrq.epsilon = 1.5;  
  
-- 激进设置：更多扩展，高召回率  
SET vchordrq.epsilon = 2.5;  
```  
  
### 3. 索引构建参数优化  
  
创建索引时的关键参数  ：  
  
```sql  
CREATE INDEX ON items USING vchordrq (embedding vector_l2_ops)  
WITH (options = $$  
residual_quantization = true  
[build.internal]  
lists = ￼              -- 聚类数量  
build_threads = 8          -- 构建线程数  
spherical_centroids = false  
kmeans_dimension = 2  
kmeans_algorithm.hierarchical = {}  
$$);  
```  
  
**聚类数量（lists）选择**：  
- 公式：`4*sqrt(n)` 到 `16*sqrt(n)`（n为向量数量）  
- 100万向量：lists = 400-1600  
- 1000万向量：lists = 1265-5060  
  
## ⚡ 性能优化技巧  
  
### 1. 预热索引  
  
将索引加载到内存缓存中，避免冷启动延迟  ：  
  
```sql  
-- 预热所有层级  
SELECT vchordrq_prewarm('your_index_name'::regclass, 0);  
  
-- 仅预热顶层（节省内存）  
SELECT vchordrq_prewarm('your_index_name'::regclass, 1);  
```  
  
### 2. I/O 策略优化  
  
根据 PostgreSQL 版本选择合适的 I/O 策略  ：  
  
```sql  
-- PostgreSQL 13-16：使用预取缓冲区  
SET vchordrq.io_search = 'prefetch_buffer';  
SET vchordrq.io_rerank = 'prefetch_buffer';  
  
-- PostgreSQL 17+：使用流式读取  
SET vchordrq.io_search = 'read_stream';  
SET vchordrq.io_rerank = 'read_stream';  
```  
  
### 3. 批量查询优化  
  
在基准测试中使用的优化配置  ：  
  
```python  
# 性能调优设置  
conn.execute("SET jit=false")  
conn.execute("SET effective_io_concurrency=200")  
conn.execute(f"SET vchordrq.probes={nprob}")  
conn.execute(f"SET vchordrq.epsilon={epsilon}")  
```  
  
## 📈 召回率评估实践  
  
### 1. 评估查询召回率  
  
使用内置函数评估查询质量  ：  
  
```sql  
-- 评估单个查询的召回率  
SELECT * FROM vchordrq_evaluate_query_recall(  
    query => $$SELECT ctid FROM documents ORDER BY embedding <-> '[0.5, 0.25, 1.0]' LIMIT 10$$  
);  
  
-- 使用精确搜索作为基准  
SELECT * FROM vchordrq_evaluate_query_recall(  
    query => $$SELECT ctid FROM documents ORDER BY embedding <-> '[0.5, 0.25, 1.0]' LIMIT 10$$,  
    exact_search => true  
);  
```  
  
### 2. 批量召回率测试  
  
测试文件中的召回率验证示例  ：  
  
```sql  
-- 设置测试参数  
SET vchordrq.epsilon = 0.8;  
SET vchordrq.probes = '1';  
  
-- 执行召回率测试  
SELECT * FROM vchordrq_evaluate_query_recall(  
    query=>$$SELECT ctid FROM t ORDER BY val <-> '[0.5, 0.25, 1.0]' LIMIT 10$$  
);  
```  
  
## 🛠️ 实际应用优化案例  
  
### 1. 文档检索系统优化  
  
```sql  
-- 创建优化的文档索引  
CREATE INDEX documents_embedding_idx   
ON documents   
USING vchordrq (embedding vector_cosine_ops)  
WITH (options = $$  
residual_quantization = false  
[build.internal]  
lists = [200]  
build_threads = 16  
spherical_centroids = true  
kmeans_algorithm.hierarchical = {}  
$$);  
  
-- 查询时动态调整参数  
SET vchordrq.probes = '100';  
SET vchordrq.epsilon = 1.9;  
  
-- 预热索引  
SELECT vchordrq_prewarm('documents_embedding_idx'::regclass, 0);  
```  
  
### 2. 高并发场景优化  
  
```sql  
-- 限制扫描元组数，防止查询过慢  
SET vchordrq.max_scan_tuples = 10000;  
  
-- 使用较小的 probes 值保证响应速度  
SET vchordrq.probes = '50';  
  
-- 降低 epsilon 值减少计算量  
SET vchordrq.epsilon = 1.5;  
```  
  
## 📊 性能监控与调优  
  
### 1. 查询执行计划分析  
  
```sql  
-- 查看查询执行计划  
EXPLAIN (ANALYZE, BUFFERS)   
SELECT * FROM documents   
ORDER BY embedding <-> '[0.1, 0.2, 0.3]'   
LIMIT 10;  
```  
  
### 2. 参数调优流程  
  
1. **基准测试**：使用默认参数测试基础性能  
2. **逐步调整**：每次只调整一个参数  
3. **召回率验证**：确保召回率满足业务需求  
4. **性能对比**：记录调整前后的查询时间  
  
## Notes  
  
IVF 索引优化是一个需要根据具体场景不断调整的过程。建议在生产环境中使用查询采样功能来监控实际查询的召回率  。对于超大规模数据集（>1亿向量），建议使用外部构建工具来优化索引创建过程  。  
  
  
-----    
  
# VectorChord 图索引优化实践  
  
## 🎯 核心优化理念  
  
图索引优化的核心是在**召回率**和**查询速度**之间找到最佳平衡点。就像在社交网络中找人，你可以选择快速查看几个好友的朋友圈（速度快但可能遗漏），或者深入挖掘多级好友关系（找到更多但耗时）。  
  
## 📊 关键参数调优实践  
  
### 1. ef_search 参数优化  
  
`ef_search` 控制搜索时的候选集大小，是最重要的性能调优参数  ：  
  
```sql  
-- 保守设置：速度快，召回率较低  
SET vchordg.ef_search = 32;  
  
-- 平衡设置：推荐默认值  
SET vchordg.ef_search = 64;  
  
-- 激进设置：高召回率，速度较慢  
SET vchordg.ef_search = 128;  
```  
  
**实践建议**：  
- 数据量小（<100万）：ef_search = 32-64  
- 数据量中等（100万-1000万）：ef_search = 64-128  
- 数据量大（>1000万）：ef_search = 128-256  
  
### 2. beam_search 参数优化  
  
`beam_search` 控制并行搜索路径数  ：  
  
```sql  
-- 单路径搜索（默认）  
SET vchordg.beam_search = 1;  
  
-- 多路径并行搜索  
SET vchordg.beam_search = 4;  
```  
  
### 3. 索引构建参数优化  
  
创建索引时的关键参数  ：  
  
```sql  
CREATE INDEX products_embedding_idx   
ON products   
USING vchordg (embedding vector_l2_ops)  
WITH (options = $$  
m = 32                    -- 每层最大连接数  
alpha = [1.0, 1.2]       -- 层级参数  
ef_construction = 64     -- 构建时搜索宽度  
beam_construction = 1    -- 构建时束搜索宽度  
$$);  
```  
  
**参数选择建议**：  
- `m`：数据量大时增加到48-64，但会增加内存使用  
- `ef_construction`：高质量索引设为128-256  
- `alpha`：根据数据分布调整层级连接密度  
  
## ⚡ 性能优化技巧  
  
### 1. 预热索引  
  
将图索引加载到内存缓存中，避免冷启动延迟  ：  
  
```sql  
-- 预热图索引  
SELECT vchordg_prewarm('products_embedding_idx'::regclass);  
```  
  
### 2. I/O 策略优化  
  
根据 PostgreSQL 版本选择合适的 I/O 策略  ：  
  
```sql  
-- PostgreSQL 13-16：使用预取缓冲区  
SET vchordg.io_search = 'prefetch_buffer';  
SET vchordg.io_rerank = 'prefetch_buffer';  
  
-- PostgreSQL 17+：使用流式读取  
SET vchordg.io_search = 'read_stream';  
SET vchordg.io_rerank = 'read_stream';  
```  
  
### 3. 查询限制优化  
  
限制最大扫描元组数，防止查询过慢  ：  
  
```sql  
-- 限制扫描元组数  
SET vchordg.max_scan_tuples = 10000;  
```  
  
## 📈 实际应用优化案例  
  
### 1. 推荐系统优化  
  
```sql  
-- 创建高召回率的推荐索引  
CREATE INDEX user_interactions_embedding_idx   
ON user_interactions   
USING vchordg (embedding vector_cosine_ops)  
WITH (options = $$  
m = 48  
ef_construction = 128  
alpha = [1.0, 1.2, 1.4]  
$$);  
  
-- 查询时动态调整参数  
SET vchordg.ef_search = 128;  
SET vchordg.beam_search = 2;  
  
-- 预热索引  
SELECT vchordg_prewarm('user_interactions_embedding_idx'::regclass);  
```  
  
### 2. 高并发场景优化  
  
```sql  
-- 快速响应配置  
SET vchordg.ef_search = 32;  
SET vchordg.beam_search = 1;  
SET vchordg.max_scan_tuples = 5000;  
```  
  
### 3. 大规模数据集优化  
  
```sql  
-- 创建适合大规模数据的索引  
CREATE INDEX large_dataset_idx   
ON large_table   
USING vchordg (embedding vector_l2_ops)  
WITH (options = $$  
m = 64  
ef_construction = 256  
alpha = [1.0, 1.1, 1.2, 1.3]  
$$);  
  
-- 查询配置  
SET vchordg.ef_search = 256;  
SET vchordg.beam_search = 4;  
```  
  
## 📊 性能监控与调优  
  
### 1. 查询执行计划分析  
  
```sql  
-- 查看查询执行计划  
EXPLAIN (ANALYZE, BUFFERS)   
SELECT * FROM products   
ORDER BY embedding <-> '[0.1, 0.2, 0.3]'   
LIMIT 10;  
```  
  
### 2. 参数调优流程  
  
1. **基准测试**：使用默认参数测试基础性能  
2. **逐步调整**：每次只调整一个参数  
3. **性能对比**：记录调整前后的查询时间  
4. **召回率验证**：确保结果质量满足需求  
  
### 3. 搜索选项配置  
  
查询时的搜索选项配置  ：  
  
```rust  
SearchOptions {  
    ef_search: gucs::vchordg_ef_search(),      // 搜索宽度  
    beam_search: gucs::vchordg_beam_search(),  // 束搜索大小  
    max_scan_tuples: gucs::vchordg_max_scan_tuples(),  
    io_search: gucs::vchordg_io_search(),  
    io_rerank: gucs::vchordg_io_rerank(),  
}  
```  
  
## 🔄 动态参数调整  
  
### 1. 会话级参数设置  
  
```sql  
-- 为当前会话设置参数  
SET LOCAL vchordg.ef_search = 128;  
SET LOCAL vchordg.beam_search = 2;  
  
-- 执行查询  
SELECT * FROM products   
ORDER BY embedding <-> query_vector   
LIMIT 10;  
```  
  
### 2. 事务级参数设置  
  
```sql  
BEGIN;  
SET vchordg.ef_search = 64;  
-- 执行多个查询  
SELECT * FROM products WHERE category = 'electronics' ORDER BY embedding <-> query_vector LIMIT 5;  
SELECT * FROM products WHERE category = 'books' ORDER BY embedding <-> query_vector LIMIT 5;  
COMMIT;  
```  
  
## Notes  
  
图索引优化是一个需要根据具体场景不断调整的过程。建议在生产环境中根据查询模式和数据特性动态调整参数  。对于对召回率要求极高的场景，可以适当增加 `ef_search` 和 `beam_search` 值；对于对响应时间要求严格的场景，则应该降低这些参数值  。  
  
  
  
-----    
  
# RaBitQ 在 IVF 和图索引中的设计原理  
  
## 🎯 RaBitQ 核心思想：智能压缩的艺术  
  
RaBitQ（Rotation-based Binary Quantization）是一种创新的向量量化算法，就像把高清图片压缩成小尺寸文件但保持关键特征一样。它通过旋转变换将高维向量映射到低维空间，然后用 8 位整数表示，实现 4 倍压缩率  。  
  
## 📊 RaBitQ 量化原理  
  
### 1. 旋转变换  
  
RaBitQ 首先对向量进行随机旋转变换  ：  
  
```rust  
let rotated = rabitq::rotate::rotate(sample);  
let sample = rotated.as_slice();  
```  
  
旋转的目的是让向量的各个维度更加独立，便于后续量化。  
  
### 2. 量化编码  
  
将旋转后的向量量化为 8 位整数  ：  
  
```rust  
fn code(bits: Bits, vector: Self::Borrowed<'_>) -> rabitq::bits::Code {  
    let scale = vector.sum_of_x2().sqrt() / vector.norm_of_lattice();  
    let mut result = Vec::with_capacity(vector.dims() as _);  
    for c in vector.code().iter().copied() {  
        let base = -0.5 * ((1 << 8) - 1) as f32;  
        result.push((base + c as f32) * scale);  
    }  
    rabitq::bits::code(bits, &result)  
}  
```  
  
## 🏗️ RaBitQ 在 IVF 索引中的设计  
  
### 1. 残差量化优化  
  
在 IVF 索引中，RaBitQ 与残差量化结合使用  ：  
  
```rust  
pub residual_quantization: bool,  
```  
  
残差量化存储向量与质心的差值而非原始向量，进一步压缩存储空间。  
  
### 2. 聚类过程中的旋转  
  
在 K-means 聚类前对所有向量进行旋转  ：  
  
```rust  
pool.install(|| {  
    samples.par_iter_mut().for_each(|sample| {  
        rabitq::rotate::rotate_inplace(sample);  
    });  
});  
```  
  
### 3. 构建后的反向旋转  
  
索引构建完成后，对质心进行反向旋转以恢复原始空间  ：  
  
```rust  
for structure in structures.iter_mut() {  
    for centroid in structure.centroids.iter_mut() {  
        rabitq::rotate::rotate_inplace(centroid);  
    }  
}  
```  
  
## 🕸️ RaBitQ 在图索引中的设计  
  
### 1. 向量元数据存储  
  
在图索引中，RaBitQ 向量存储额外的元数据用于距离计算  ：  
  
```rust  
fn unpack(vector: Self::Borrowed<'_>) -> (&[Self::Element], Self::Metadata) {  
    (  
        vector.code(),  
        [  
            vector.sum_of_x2(),  
            vector.norm_of_lattice(),  
            vector.sum_of_code(),  
            vector.sum_of_abs_x(),  
        ],  
    )  
}  
```  
  
### 2. 预处理优化  
  
图索引使用预处理查找表加速距离计算  ：  
  
```rust  
fn preprocess(vector: Self::Borrowed<'_>) -> rabitq::bits::binary::BinaryLut {  
    let scale = vector.sum_of_x2().sqrt() / vector.norm_of_lattice();  
    let mut result = Vec::with_capacity(vector.dims() as _);  
    for c in vector.code().iter().copied() {  
        let base = -0.5 * ((1 << 8) - 1) as f32;  
        result.push((base + c as f32) * scale);  
    }  
    rabitq::bits::binary::preprocess(&result)  
}  
```  
  
### 3. 向量分割处理  
  
对于长向量，图索引支持分割存储  ：  
  
```rust  
fn split(  
    vector: Self::Borrowed<'_>,  
    m: usize,  
) -> (Vec<&[Self::Element]>, (&[Self::Element], Self::Metadata)) {  
    // 将长向量分割成多个块  
}  
```  
  
## 🔄 两种索引的对比  
  
| 特性 | IVF 索引中的 RaBitQ | 图索引中的 RaBitQ |  
|------|-------------------|-------------------|  
| **压缩策略** | 残差量化 | 直接量化 |  
| **旋转时机** | 聚类前旋转，构建后反向旋转 | 查询时动态旋转 |  
| **元数据** | 简单存储 | 丰富的距离计算元数据 |  
| **适用场景** | 超大规模数据（>100M） | 中等规模数据（<100M） |  
  
## 💡 设计优势  
  
### 1. 理论保证  
  
RaBitQ 提供理论误差界，确保量化后的距离计算有可靠性保证  。  
  
### 2. 自适应重排序  
  
VectorChord 支持自主重排序，在量化搜索后使用原始向量精确计算，保持搜索质量  。  
  
### 3. 多类型支持  
  
支持 `vector`、`halfvec` 和 `rabitq8` 三种类型的相互转换  。  
  
## Notes  
  
RaBitQ 是 VectorChord 实现高性能向量搜索的核心技术之一。在 IVF 索引中，它主要用于存储压缩；在图索引中，它通过预处理和元数据优化实现快速距离计算。两种设计都体现了"压缩存储，精确计算"的理念  。  
  
  
  
-----    
  
# VectorChord 性能与召回率提升技术详解  
  
VectorChord 通过多项创新技术实现了性能和召回率的双重提升，让向量搜索既快速又准确。  
  
## 🚀 性能提升核心技术  
  
### 1. RaBitQ 智能量化压缩  
RaBitQ（Rotation-based Binary Quantization）通过旋转变换将向量压缩为8位整数，实现4倍存储压缩  。这就像把高清照片压缩成小尺寸文件，但保持关键特征不变。  
  
### 2. 外部GPU加速构建  
支持在外部（如GPU）进行K-means聚类，大幅加速索引构建  。对于大规模数据集，构建速度提升16倍  。  
  
### 3. 并行处理优化  
- **并行构建**：PostgreSQL 17+ 支持并行索引构建    
- **SIMD加速**：使用CPU向量指令加速距离计算  
- **多线程处理**：构建时可配置多个工作线程    
  
### 4. 智能I/O策略  
根据PostgreSQL版本选择最优I/O策略  ：  
- PostgreSQL 13-16：使用预取缓冲区（prefetch_buffer）  
- PostgreSQL 17+：使用流式读取（read_stream）  
  
## 🎯 召回率保障技术  
  
### 1. 自主重排序机制  
在量化搜索后使用原始向量进行精确距离计算，确保搜索质量  。这是"快速筛选，精确重排"的两阶段策略。  
  
### 2. 动态参数调优  
提供丰富的参数控制召回率与性能的平衡：  
- **IVF索引**：`probes`控制搜索聚类数，`epsilon`控制候选集扩展    
- **图索引**：`ef_search`控制搜索宽度，`beam_search`控制并行路径    
  
### 3. 层次化搜索策略  
- **IVF分区**：通过K-means聚类减少搜索范围    
- **HNSW图结构**：构建多层"社交网络"，逐层细化搜索    
  
### 4. 查询采样与评估  
内置查询采样功能，实时监控实际查询的召回率  。  
  
## 💡 创新优化技术  
  
### 1. 残差量化  
存储向量与质心的差值而非原始向量，进一步压缩存储空间  。  
  
### 2. 预热机制  
将索引加载到内存缓存，避免冷启动延迟  。  
  
### 3. 多距离度量支持  
支持L2距离、内积、余弦相似度等多种距离度量，适应不同应用场景  。  
  
### 4. 长向量支持  
支持高达60,000维的向量，远超pgvector的16,000维限制  。  
  
## 📊 实际效果  
  
通过这些技术的组合，VectorChord实现了：  
- **查询速度提升5倍**：相比pgvector的HNSW实现    
- **32GB内存查询1亿向量**：35ms延迟达到95%召回率    
- **成本降低26倍**：相比pgvector/pgvecto.rs的存储成本    
  
## Notes  
  
VectorChord的技术创新体现在"压缩存储，精确计算"的设计理念上。通过RaBitQ量化、并行处理、智能I/O等技术提升性能，同时通过自主重排序、动态调优、层次化搜索等技术保障召回率。这种平衡设计使得VectorChord能够在保持高精度的同时实现卓越的性能表现  。  
    
#### [PolarDB 学习图谱](https://www.aliyun.com/database/openpolardb/activity "8642f60e04ed0c814bf9cb9677976bd4")
  
  
#### [PostgreSQL 解决方案集合](../201706/20170601_02.md "40cff096e9ed7122c512b35d8561d9c8")
  
  
#### [德哥 / digoal's Github - 公益是一辈子的事.](https://github.com/digoal/blog/blob/master/README.md "22709685feb7cab07d30f30387f0a9ae")
  
  
#### [About 德哥](https://github.com/digoal/blog/blob/master/me/readme.md "a37735981e7704886ffd590565582dd0")
  
  
![digoal's wechat](../pic/digoal_weixin.jpg "f7ad92eeba24523fd47a6e1a0e691b59")
  
