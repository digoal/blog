## 大学生数据库实践课: 18 PGQ 图式搜索       
              
### 作者              
digoal              
              
### 日期              
2025-12-11              
              
### 标签              
PostgreSQL , DuckDB , 语义搜索 , 向量搜索 , 关键词检索 , 全文检索 , 标量检索 , 混合搜索 , 多模态搜索 , 重排序 , embedding , document split , ORC , 大模型 , 多模态大模型 , Dify , 压力测试 , 索引优化 , 倒排向量索引 , Ivfflat , 图向量索引 , HNSW , DiskANN , 量化 , rabitq , sbq , 二值量化 , bm25 , 相关性 , 相似性 , 召回率 , pgbench , 数据集 , ann-benchmarks , 图搜索 , PGQ , 递归 , 深度优先 , 广度优先 , 最短路径 , N度关系 , LLM , Ollama              
              
----              
              
## 背景              
              
duckpgq deepwiki:      
  
https://deepwiki.com/search/-1_33fb296a-5774-4787-a4af-9a633d5e8305?mode=fast       
        
    
- [《使用 DuckDB 图查询(PGQ)揭示金融犯罪》](../202510/20251023_13.md)    
- [《图数据库赛道没了 | SQL:PGQ标准出炉, 还不懂PGQ图式查询用法? 用DuckDB将PGQ一次整明白》](../202507/20250727_01.md)    
  
面向大学生通俗讲解以下内容:    
1、什么是属性图    
2、属性图语法详解    
3、表示属性图特征的统计信息有哪些?   
4、详细介绍每种统计信息的应用场景, 获取方法. 例如连通性? 聚集性?   
5、属性图可以用来挖掘数据的哪些特征信息? 例如最短路径, 共同好友, N度关系, 以及更多其他   
6、详细讲解每一种特征信息以及使用示例!  
7、详细介绍广度优先、深度优先    
8、duckdb-pgq 相比其他图数据库的优势及劣势    
9、属性图搜索性能优化技巧   
10、综合示例   
  
  
  
-----      
  
# 什么是属性图  
  
属性图是一种用于表示和查询关联数据的数学模型，它将数据组织为**顶点**（Vertex，代表实体）和**边**（Edge，代表关系）的结构  。  
  
## 核心概念  
  
### 1. 顶点表（Vertex Tables）  
顶点表代表图中的节点，每个顶点表对应一个关系型表，表中的每一行对应一个图顶点  。  
  
```sql  
CREATE TABLE Student(id BIGINT, name VARCHAR);  
-- 这个表将成为图中的"学生"顶点  
```  
  
### 2. 边表（Edge Tables）  
边表表示顶点之间的关系，通过外键约束连接两个顶点表  。  
  
```sql  
CREATE TABLE know(src BIGINT, dst BIGINT, createDate BIGINT);  
-- 这个表表示学生之间的"认识"关系  
```  
  
### 3. 标签（Labels）  
标签为顶点和边提供语义标识，使得我们可以按类型查询特定的顶点或边  。  
  
### 4. 属性（Properties）  
属性是顶点和边携带的数据，对应底层关系表中的列  。  
  
## 实际示例  
  
以下是一个完整的属性图定义示例  ：  
  
```sql  
CREATE PROPERTY GRAPH pg  
VERTEX TABLES (  
    Student PROPERTIES (id, name) LABEL Person,  
    School LABEL SCHOOL  
)  
EDGE TABLES (  
    know    SOURCE KEY (src) REFERENCES Student (id)  
            DESTINATION KEY (dst) REFERENCES Student (id)  
            LABEL Knows,  
    studyAt SOURCE KEY (personId) REFERENCES Student (id)  
            DESTINATION KEY (SchoolId) REFERENCES School (id)  
            LABEL StudyAt  
);  
```  
  
## 关键特点  
  
1. **逻辑映射层**：DuckPGQ在现有关系数据上创建逻辑图层，无需数据迁移或复制    
  
2. **模式支持**：支持完整的目录和模式限定，可以创建跨数据库的属性图    
  
3. **持久化存储**：属性图定义存储在`__duckpgq_internal`系统表中，支持跨会话持久化    
  
## 查询示例  
  
创建属性图后，可以使用图模式匹配进行查询  ：  
  
```sql  
SELECT * FROM GRAPH_TABLE (pg  
    MATCH (a:Person)-[s:StudyAt]->(b:School)  
    WHERE a.name = 'Daniel'  
    COLUMNS (a.name as name, b.name as school)  
);  
```  
  
## Notes  
  
属性图模型在DuckPGQ中的实现遵循SQL/PGQ标准，它将关系数据库的表结构映射为图结构，使得用户可以在不改变现有数据存储的情况下执行图查询。这种设计特别适合需要在关系数据上进行图分析的场景，如社交网络分析、推荐系统等。  
  
  
  
  
-----      
  
# 属性图语法详解  
  
属性图语法基于SQL/PGQ标准，主要包括创建属性图和查询属性图两大部分。  
  
## 基本创建语法  
  
### CREATE PROPERTY GRAPH 语句  
  
```sql  
CREATE PROPERTY GRAPH graph_name  
VERTEX TABLES (vertex_table_definitions)  
EDGE TABLES (edge_table_definitions);  
```  
  
这是创建属性图的基本模板  。  
  
### 顶点表定义  
  
顶点表定义包含表名、属性列表和标签：  
  
```sql  
VERTEX TABLES (  
    Student PROPERTIES (id, name) LABEL Person,  
    School LABEL SCHOOL  
)  
```  
  
- `PROPERTIES (id, name)`：指定要包含的属性列    
- `LABEL Person`：为顶点指定语义标签  
- 如果不指定 `PROPERTIES`，则包含所有列    
  
### 边表定义  
  
边表定义需要指定源顶点、目标顶点和连接关系：  
  
```sql  
EDGE TABLES (  
    know    SOURCE KEY (src) REFERENCES Student (id)  
            DESTINATION KEY (dst) REFERENCES Student (id)  
            PROPERTIES (createDate) LABEL Knows,  
    studyAt SOURCE KEY (personId) REFERENCES Student (id)  
            DESTINATION KEY (SchoolId) REFERENCES School (id)  
            LABEL StudyAt  
)  
```  
  
- `SOURCE KEY (src)`：指定源顶点的外键列    
- `DESTINATION KEY (dst)`：指定目标顶点的外键列  
- `REFERENCES Student (id)`：引用顶点表的主键  
- `PROPERTIES (createDate)`：指定边要包含的属性  
- `LABEL Knows`：为边指定语义标签  
  
## 高级语法特性  
  
### 子标签支持  
  
可以使用 `IN` 子句创建基于列值的子标签：  
  
```sql  
School LABEL School IN School_kind (Hogeschool, University)  
```  
  
这会根据 `School_kind` 列的值创建不同的子标签  。  
  
### 表别名  
  
可以为表指定别名以便引用：  
  
```sql  
School as school_alias PROPERTIES (school_id, school_name) LABEL School  
```  
  
### 跨数据库支持  
  
支持完整的目录和模式限定：  
  
```sql  
CREATE PROPERTY GRAPH external_graph  
VERTEX TABLES (  
    test_schema.Person,  
    test_schema.Company  
)  
EDGE TABLES (  
    test_schema.WorksAt SOURCE KEY (personId) REFERENCES test_schema.Person (id)  
                        DESTINATION KEY (company_id) REFERENCES test_schema.Company (id)  
                        LABEL works_at  
);  
```    
  
## 查询语法  
  
### GRAPH_TABLE 基本查询  
  
```sql  
FROM GRAPH_TABLE (graph_name  
    MATCH (pattern)  
    COLUMNS (column_list)  
)  
```  
  
### 模式匹配语法  
  
#### 基本模式  
```sql  
MATCH (a:Person)-[s:StudyAt]->(b:School)  
```  
- `(a:Person)`：匹配标签为 Person 的顶点，变量名为 a  
- `[s:StudyAt]`：匹配标签为 StudyAt 的边，变量名为 s  
- `->`：表示边的方向  
  
#### 条件过滤  
```sql  
MATCH (a:Person WHERE a.name = 'Daniel')-[s:StudyAt]->(b:School)  
```  
  
#### 复杂模式  
```sql  
MATCH (a2:Person)-[s2:StudyAt]->(b:School)<-[s:StudyAt]-(a:Person)  
```  
表示查找在同一所学校学习的两个人  。  
  
### 列选择语法  
  
```sql  
COLUMNS (a.name as name, b.name as school)  
```  
  
可以选择顶点和边的属性，并指定别名  。  
  
## 完整示例  
  
```sql  
-- 创建表  
CREATE TABLE Student(id BIGINT, name VARCHAR);  
CREATE TABLE know(src BIGINT, dst BIGINT, createDate BIGINT);  
CREATE TABLE School(name VARCHAR, Id BIGINT, Kind VARCHAR);  
CREATE TABLE StudyAt(personId BIGINT, schoolId BIGINT);  
  
-- 创建属性图  
CREATE PROPERTY GRAPH pg  
VERTEX TABLES (  
    Student PROPERTIES (id, name) LABEL Person,  
    School LABEL SCHOOL  
)  
EDGE TABLES (  
    know    SOURCE KEY (src) REFERENCES Student (id)  
            DESTINATION KEY (dst) REFERENCES Student (id)  
            PROPERTIES (createDate) LABEL Knows,  
    studyAt SOURCE KEY (personId) REFERENCES Student (id)  
            DESTINATION KEY (SchoolId) REFERENCES School (id)  
            LABEL StudyAt  
);  
  
-- 查询示例  
SELECT a.name, b.school   
FROM GRAPH_TABLE (pg  
    MATCH (a:Person)-[s:StudyAt]->(b:School)  
    WHERE a.name = 'Daniel'  
    COLUMNS (a.name as name, b.name as school)  
) study;  
```    
  
## 管理语法  
  
### 创建或替换  
```sql  
CREATE OR REPLACE PROPERTY GRAPH graph_name ...  
```    
  
### 条件创建  
```sql  
CREATE PROPERTY GRAPH IF NOT EXISTS graph_name ...  
```    
  
### 删除属性图  
```sql  
DROP PROPERTY GRAPH graph_name;  
```    
  
### 描述属性图  
```sql  
DESCRIBE PROPERTY GRAPH graph_name;  
```    
  
## Notes  
  
属性图语法的设计遵循SQL标准，使得熟悉SQL的开发者可以快速上手。语法的关键在于理解如何将关系表映射为图结构，以及如何使用模式匹配进行图查询。在实际应用中，建议先设计好关系表结构，然后通过属性图语法创建逻辑图层进行图分析。  
  
  
  
  
-----      
  
# 属性图特征统计信息  
  
属性图的统计信息帮助你了解图的结构特征，就像人口普查帮你了解一个城市的基本情况一样。DuckPGQ通过`SUMMARIZE PROPERTY GRAPH`命令提供全面的图统计分析  。  
  
## 基本统计指标  
  
### 顶点表统计  
- **顶点数量** (`vertex_count`)：图中节点的总数    
- **表名** (`table_name`)：对应的底层数据表名称  
- **是否为顶点表** (`is_vertex_table`)：标识这是顶点表而非边表  
  
### 边表统计  
- **边数量** (`edge_count`)：图中连接的总数    
- **源表和目标表**：边连接的两个顶点表名称    
  
## 连接性分析  
  
### 唯一节点统计  
- **唯一源节点数** (`unique_source_count`)：作为起点的不同节点数量    
- **唯一目标节点数** (`unique_destination_count`)：作为终点的不同节点数量  
  
### 孤立节点检测  
- **孤立源节点** (`isolated_sources`)：只有出边没有入边的节点    
- **孤立目标节点** (`isolated_destinations`)：只有入边没有出边的节点  
  
## 度分布统计  
  
### 入度统计（指向节点的边数）  
- **平均入度** (`avg_in_degree`)：所有节点入度的平均值    
- **最小/最大入度** (`min_in_degree`, `max_in_degree`)：入度的范围  
- **四分位数** (`q25_in_degree`, `q50_in_degree`, `q75_in_degree`)：入度分布的25%、50%、75%分位点  
  
### 出度统计（从节点出发的边数）  
- **平均出度** (`avg_out_degree`)：所有节点出度的平均值    
- **最小/最大出度** (`min_out_degree`, `max_out_degree`)：出度的范围  
- **四分位数** (`q25_out_degree`, `q50_out_degree`, `q75_out_degree`)：出度分布的分位点  
  
## 实际应用示例  
  
```sql  
-- 查看属性图的统计信息  
FROM summarize_property_graph('social_network') ORDER BY table_name;  
```  
  
输出结果示例  ：  
```  
Person                    1    NULL    NULL    50    NULL    NULL    NULL    NULL    NULL    NULL    NULL    NULL    NULL    NULL    NULL    NULL    NULL    NULL    NULL    NULL    NULL  
Person_knows_person       0    Person  Person  NULL  83     28     29     22     21     2.86    1      10     1      2      3      2.96    1      13     1      2      4  
```  
  
## 统计信息的意义  
  
这些统计信息帮助你：  
1. **了解图规模**：通过顶点数和边数了解图的总体大小  
2. **分析连接模式**：通过度分布了解网络的连接特征  
3. **发现异常节点**：通过孤立节点统计找出网络中的"孤岛"  
4. **优化查询性能**：了解图结构有助于选择合适的查询策略  
  
## Notes  
  
统计信息通过复杂的SQL查询生成，使用CTE（公共表表达式）计算度分布和聚合统计  。这些信息对于图分析、社交网络研究、推荐系统优化等应用场景具有重要价值。  
  
  
-----      
  
# 属性图统计信息的应用场景与获取方法  
  
## 连通性分析  
  
### 什么是连通性？  
连通性就像地图上的道路网络，告诉你哪些地方可以互相到达。在社交网络中，它表示信息能否从一个用户传递到另一个用户。  
  
### 应用场景  
1. **社交网络分析**：发现社交圈子和孤立用户  
2. **疫情传播预测**：识别可能的传播路径  
3. **网络可靠性评估**：找出网络中的关键连接点  
  
### 获取方法  
  
#### 弱连通分量分析  
```sql  
-- 找出图中的所有连通分量  
SELECT id, componentId   
FROM weakly_connected_component(social_network, person, knows);  
```  
  
这会返回每个节点所属的连通分量ID  。相同ID的节点属于同一个连通区域。  
  
#### 实际示例  
在一个学生社交网络中：  
```sql  
-- 创建测试数据  
CREATE TABLE Student(id BIGINT, name VARCHAR);  
INSERT INTO Student VALUES (0, 'Alice'), (1, 'Bob'), (2, 'Charlie'), (3, 'David'), (4, 'Eve');  
  
CREATE TABLE know(src BIGINT, dst BIGINT);  
INSERT INTO know VALUES (0, 1), (1, 2), (2, 3); -- Alice-Bob-Charlie-David 形成一个链  
-- Eve 是孤立的  
  
-- 分析连通性  
SELECT id, componentId FROM weakly_connected_component(pg, student, know);  
```  
结果会显示Alice、Bob、Charlie、David属于同一个连通分量，而Eve独自一个  。  
  
## 聚集性分析  
  
### 什么是聚集性？  
聚集性衡量你的朋友们之间也是朋友的程度，就像朋友圈的"紧密程度"。高聚集性意味着群体内部联系紧密。  
  
### 应用场景  
1. **推荐系统**：推荐朋友的朋友  
2. **社区发现**：识别紧密的社交群体  
3. **异常检测**：发现行为异常的节点  
  
### 获取方法  
  
#### 局部聚集系数  
```sql  
-- 计算每个节点的聚集系数  
SELECT id, local_clustering_coefficient   
FROM local_clustering_coefficient(social_network, person, knows);  
```  
  
返回值范围是0.0到1.0，1.0表示该节点的所有邻居都互相连接  。  
  
#### 实际示例  
```sql  
-- 测试数据：5个学生的友谊关系  
CREATE TABLE VariedStudent(id BIGINT, name VARCHAR);  
INSERT INTO VariedStudent VALUES (0, 'Alice'), (1, 'Bob'), (2, 'Charlie'), (3, 'Dave'), (4, 'Eve'), (5, 'Frank');  
  
CREATE TABLE VariedKnow(src BIGINT, dst BIGINT);  
INSERT INTO VariedKnow VALUES (0,1), (0,2), (0,3), (1,2), (2,3), (3,4), (4,5);  
  
-- 计算聚集系数  
SELECT id, local_clustering_coefficient   
FROM local_clustering_coefficient(varied_pg, variedstudent, variedknow);  
```  
  
结果显示：  
- Alice (0): 0.67 - 她的朋友Bob、Charlie、Dave之间有一定联系  
- Bob (1): 1.0 - 他的所有朋友都互相认识（形成三角形）    
  
## 中心性分析  
  
### 什么是中心性？  
中心性衡量节点在网络中的"重要性"，就像社交网络中的"网红"或交通网络中的"枢纽站"。  
  
### 应用场景  
1. **影响力营销**：找到关键意见领袖  
2. **疫苗分配**：优先保护重要节点  
3. **搜索引擎排名**：确定网页重要性  
  
### 获取方法  
  
#### PageRank算法  
```sql  
-- 计算每个节点的PageRank值  
SELECT vertex_id, pagerank_score   
FROM pagerank(social_network, person, knows);  
```  
  
PageRank使用迭代算法，阻尼因子为0.85，收敛阈值为1e-6  。  
  
## 度分布分析  
  
### 什么是度分布？  
度分布统计网络中每个节点连接数的分布情况，帮助了解网络的整体结构特征。  
  
### 应用场景  
1. **网络建模**：判断网络类型（随机网络、无标度网络等）  
2. **资源分配**：根据节点度数分配资源  
3. **负载均衡**：避免高度节点过载  
  
### 获取方法  
  
#### 综合统计信息  
```sql  
-- 获取完整的图统计信息  
FROM summarize_property_graph('social_network') ORDER BY table_name;  
```  
  
这会返回包括度分布在内的全面统计  ：  
- 平均入度/出度  
- 最小/最大度数  
- 四分位数分布  
  
## 实际应用案例  
  
### 社交网络分析  
```sql  
-- 1. 找出最活跃的用户（高度数）  
SELECT id, avg_in_degree + avg_out_degree as total_connections  
FROM summarize_property_graph('social_network')  
WHERE is_vertex_table = 1;  
  
-- 2. 发现紧密的社交圈（高聚集性）  
SELECT id, local_clustering_coefficient  
FROM local_clustering_coefficient('social_network', 'person', 'friendship')  
WHERE local_clustering_coefficient > 0.7;  
  
-- 3. 找出网络中的关键人物（高PageRank）  
SELECT vertex_id, pagerank_score  
FROM pagerank('social_network', 'person', 'friendship')  
ORDER BY pagerank_score DESC  
LIMIT 10;  
```  
  
### 网络健康检查  
```sql  
-- 检查网络连通性  
SELECT   
    COUNT(DISTINCT componentId) as num_components,  
    COUNT(*) as total_vertices  
FROM weakly_connected_component('network', 'router', 'connection');  
  
-- 找出孤立节点  
SELECT id  
FROM weakly_connected_component('network', 'router', 'connection')  
GROUP BY componentId  
HAVING COUNT(*) = 1;  
```  
  
## Notes  
  
这些统计信息通过CSR（压缩稀疏行）数据结构高效计算  。聚集系数计算使用位图优化邻居查找  ，而连通性分析使用并查集算法  。这些算法都经过优化，可以处理大规模图数据。  
  
  
  
-----      
  
# 属性图数据挖掘特征  
  
属性图就像一张巨大的社交网络地图，可以帮你发现数据中隐藏的各种关系模式。以下是主要的挖掘特征：  
  
## 最短路径分析  
  
### 应用场景  
- **社交网络**：找到两个人之间的最短联系链  
- **物流规划**：确定最优配送路线  
- **知识图谱**：查找概念间的最短关联  
  
### 实现方法  
```sql  
-- 查找两个用户之间的最短路径  
FROM GRAPH_TABLE(social_network  
    MATCH p = ANY SHORTEST (a:Person WHERE a.id = 0)-[f:follows]->*(b:Person WHERE b.id = 100)  
    COLUMNS (element_id(p) as path, path_length(p), vertices(p))  
);  
```  
  
返回路径ID、路径长度和经过的节点列表  。  
  
## N度关系挖掘  
  
### 什么是N度关系？  
就像"朋友的朋友"是2度关系，"朋友的朋友的朋友"是3度关系。  
  
### 路径量词语法  
```sql  
-- 1到3度关系  
MATCH (a:Person)-[f:follows]->{1,3}(b:Person)  
  
-- 最多2度关系（包括0度，即自己）  
MATCH (a:Person)-[f:follows]->{0,2}(b:Person)  
  
-- 至少1度关系（Kleene plus）  
MATCH (a:Person)-[f:follows]->+(b:Person)  
  
-- 任意长度（Kleene star）  
MATCH (a:Person)-[f:follows]->*(b:Person)  
```  
  
### 实际示例  
```sql  
-- 查找用户1到3度内的所有关注对象  
FROM GRAPH_TABLE(bluesky   
    MATCH (a:account WHERE a.did='did:plc:7qqkrwwec4qeujs6hthlgpbe')-[f:follows]->{1,3}(b:account)  
    COLUMNS (a.did as a_id, b.did as b_id)  
) ORDER BY a_id, b_id LIMIT 10;  
```    
  
## 共同好友发现  
  
### 查询模式  
通过双向模式匹配找到共同连接：  
  
```sql  
-- 找出两个用户的共同好友  
FROM GRAPH_TABLE(social_network  
    MATCH (person1:Person)-[knows1:Knows]->(mutual:Person)<-[knows2:Knows]-(person2:Person)  
    WHERE person1.id = 0 AND person2.id = 1  
    COLUMNS (mutual.name as mutual_friend)  
);  
```  
  
### 同校关系发现  
```sql  
-- 找出在同一所学校学习的两个人  
FROM GRAPH_TABLE(pg  
    MATCH (a2:Person)-[s2:StudyAt]->(b:School)<-[s:StudyAt]-(a:Person)  
    WHERE a.name = 'Daniel' AND a.id <> a2.id  
    COLUMNS (a.name as name, b.name as school, a2.name as classmate)  
);  
```    
  
## 连通性分析  
  
### 发现社交圈子  
```sql  
-- 找出图中的所有连通分量（社交圈子）  
SELECT id, componentId   
FROM weakly_connected_component(social_network, person, knows);  
```  
  
相同componentId的节点属于同一个连通区域  。  
  
### 孤立节点检测  
```sql  
-- 找出孤立的节点（没有连接的节点）  
SELECT id   
FROM weakly_connected_component(network, router, connection)  
GROUP BY componentId   
HAVING COUNT(*) = 1;  
```  
  
## 聚集性分析  
  
### 衡量群体紧密程度  
```sql  
-- 计算每个节点的聚集系数  
SELECT id, local_clustering_coefficient   
FROM local_clustering_coefficient(social_network, person, knows);  
```  
  
返回值0.0-1.0，1.0表示该节点的所有邻居都互相连接  。  
  
## 高级路径特征  
  
### 无向路径搜索  
```sql  
-- 在无向图中查找最短路径  
FROM GRAPH_TABLE(pg  
    MATCH o = ANY SHORTEST (a:Student WHERE a.id = 0)-[e:know]-*(b:Student)  
    COLUMNS (a.id as a_id, b.id as b_id, path_length(o))  
);  
```    
  
### 复杂路径模式  
```sql  
-- 多跳路径查找  
FROM GRAPH_TABLE(snb  
    MATCH o = ANY SHORTEST   
        (p4:Person WHERE p4.rowid = 0)-[w3:knows]->(p:Person)-[w:knows]->{1,3}(p2:Person)-[w2:knows]->(p3:Person)  
    COLUMNS (p3.id, element_id(o), path_length(o), vertices(o), edges(o))  
);  
```    
  
## 实际应用案例  
  
### 推荐系统  
```sql  
-- 基于二度关系推荐好友  
SELECT DISTINCT b2.id as recommended_friend  
FROM GRAPH_TABLE(social_network  
    MATCH (me:Person)-[f1:follows]->(friend:Person)-[f2:follows]->(b2:Person)  
    WHERE me.id = :user_id AND NOT EXISTS(  
        MATCH (me)-[f3:follows]->(b2)  
    )  
    COLUMNS (b2.id)  
) LIMIT 10;  
```  
  
### 影响力分析  
```sql  
-- 找出在多个圈子中都有连接的关键节点  
SELECT p.id, COUNT(DISTINCT componentId) as circle_count  
FROM weakly_connected_component(social_network, person, knows) wcc  
JOIN person p ON wcc.id = p.id  
GROUP BY p.id  
HAVING COUNT(DISTINCT componentId) > 1  
ORDER BY circle_count DESC;  
```  
  
## Notes  
  
属性图查询通过CSR（压缩稀疏行）数据结构优化性能  。路径查找使用专门的算法实现，支持有向和无向图  。这些功能使得属性图成为挖掘复杂关系数据的强大工具。  
  
  
  
-----      
  
# 属性图数据挖掘特征详解  
  
属性图提供了强大的数据挖掘能力，可以揭示网络中隐藏的各种关系模式。下面详细介绍每种特征信息的原理、应用场景和使用示例。  
  
## 1. 最短路径分析  
  
### 原理与定义  
最短路径查找图中两个节点之间的最短连接路径，使用广度优先搜索(BFS)算法实现  。  
  
### 应用场景  
- **社交网络**：六度人脉理论，找到两人间的最短联系链  
- **交通网络**：导航系统中的最优路线规划  
- **知识图谱**：概念间的最短关联路径  
  
### 使用示例  
  
#### 基本最短路径  
```sql  
-- 查找两个用户间的最短路径  
FROM GRAPH_TABLE(social_network  
    MATCH p = ANY SHORTEST (a:Person WHERE a.id = 0)-[f:follows]->*(b:Person WHERE b.id = 100)  
    COLUMNS (element_id(p) as path, path_length(p), vertices(p))  
);  
```  
  
#### 带路径长度限制  
```sql  
-- 1到3度内的最短路径  
FROM GRAPH_TABLE(social_network  
    MATCH p = ANY SHORTEST (a:Person)-[f:follows]->{1,3}(b:Person)  
    COLUMNS (path_length(p), element_id(p))  
);  
```  
  
#### 无向图最短路径  
```sql  
-- 在无向图中查找最短路径  
FROM GRAPH_TABLE(pg  
    MATCH o = ANY SHORTEST (a:Student WHERE a.id = 0)-[e:know]-*(b:Student)  
    COLUMNS (a.id as a_id, b.id as b_id, path_length(o))  
);  
```    
  
### 实现细节  
最短路径函数使用SIMD风格的并行处理，最多同时处理64个搜索请求，使用位集数据结构优化性能  。  
  
## 2. N度关系挖掘  
  
### 原理与定义  
N度关系指通过N个中间节点建立的联系，使用路径量词指定跳数范围。  
  
### 路径量词语法  
```sql  
-- 精确N度  
MATCH (a)-[e]->{3}(b)  -- 恰好3跳  
  
-- 范围N度    
MATCH (a)-[e]->{1,3}(b)  -- 1到3跳  
  
-- Kleene量词  
MATCH (a)-[e]->+(b)      -- 至少1跳  
MATCH (a)-[e]->*(b)      -- 任意长度（包括0跳）  
```  
  
### 使用示例  
  
#### 社交网络N度关系  
```sql  
-- 查找用户1到3度内的所有关注对象  
FROM GRAPH_TABLE(bluesky   
    MATCH (a:account WHERE a.did='did:plc:7qqkrwwec4qeujs6hthlgpbe')-[f:follows]->{1,3}(b:account)  
    COLUMNS (a.did as a_id, b.did as b_id)  
) ORDER BY a_id, b_id LIMIT 10;  
```    
  
#### 复杂路径模式  
```sql  
-- 多跳路径查找  
FROM GRAPH_TABLE(snb  
    MATCH o = ANY SHORTEST   
        (p4:Person WHERE p4.rowid = 0)-[w3:knows]->(p:Person)-[w:knows]->{1,3}(p2:Person)-[w2:knows]->(p3:Person)  
    COLUMNS (p3.id, element_id(o), path_length(o), vertices(o), edges(o))  
);  
```    
  
## 3. 共同好友发现  
  
### 原理与定义  
通过双向模式匹配找到两个节点的共同邻居，揭示社交网络中的三角关系。  
  
### 使用示例  
  
#### 基本共同好友  
```sql  
-- 找出两个用户的共同好友  
FROM GRAPH_TABLE(social_network  
    MATCH (person1:Person)-[knows1:Knows]->(mutual:Person)<-[knows2:Knows]-(person2:Person)  
    WHERE person1.id = 0 AND person2.id = 1  
    COLUMNS (mutual.name as mutual_friend)  
);  
```  
  
#### 同校关系发现  
```sql  
-- 找出在同一所学校学习的两个人  
FROM GRAPH_TABLE(pg  
    MATCH (a2:Person)-[s2:StudyAt]->(b:School)<-[s:StudyAt]-(a:Person)  
    WHERE a.name = 'Daniel' AND a.id <> a2.id  
    COLUMNS (a.name as name, b.name as school, a2.name as classmate)  
);  
```    
  
#### 推荐系统应用  
```sql  
-- 基于二度关系推荐好友  
SELECT DISTINCT b2.id as recommended_friend  
FROM GRAPH_TABLE(social_network  
    MATCH (me:Person)-[f1:follows]->(friend:Person)-[f2:follows]->(b2:Person)  
    WHERE me.id = :user_id AND NOT EXISTS(  
        MATCH (me)-[f3:follows]->(b2)  
    )  
    COLUMNS (b2.id)  
) LIMIT 10;  
```  
  
## 4. 连通性分析  
  
### 原理与定义  
使用并查集(Union-Find)算法识别图中的连通分量，相同分量内的节点可以互相到达  。  
  
### 应用场景  
- **社交网络**：发现独立的社交圈子  
- **网络拓扑**：检测网络分区  
- **生物网络**：识别功能模块  
  
### 使用示例  
  
#### 基本连通分量分析  
```sql  
-- 找出图中的所有连通分量  
SELECT id, componentId   
FROM weakly_connected_component(social_network, person, knows);  
```    
  
#### 孤立节点检测  
```sql  
-- 找出孤立的节点（没有连接的节点）  
SELECT id   
FROM weakly_connected_component(network, router, connection)  
GROUP BY componentId   
HAVING COUNT(*) = 1;  
```  
  
#### 连通分量统计  
```sql  
-- 统计每个连通分量的大小  
SELECT componentId, COUNT(*) as size  
FROM weakly_connected_component(social_network, person, knows)  
GROUP BY componentId  
ORDER BY size DESC;  
```  
  
### 实现细节  
使用路径压缩的并查集算法，时间复杂度接近O(α(n))，其中α是反阿克曼函数  。  
  
## 5. 聚集性分析  
  
### 原理与定义  
局部聚集系数衡量节点的邻居之间连接的紧密程度，计算公式为：  
```  
C(v) = (2 * 三角形数量) / (度数 * (度数 - 1))  
```  
  
### 应用场景  
- **社交网络**：识别紧密的朋友圈  
- **推荐系统**：发现潜在连接  
- **异常检测**：识别行为异常节点  
  
### 使用示例  
  
#### 计算聚集系数  
```sql  
-- 计算每个节点的聚集系数  
SELECT id, local_clustering_coefficient   
FROM local_clustering_coefficient(social_network, person, knows);  
```    
  
#### 高聚集性节点发现  
```sql  
-- 找出聚集系数大于0.7的节点  
SELECT id, local_clustering_coefficient  
FROM local_clustering_coefficient(social_network, person, knows)  
WHERE local_clustering_coefficient > 0.7;  
```  
  
#### 实际数据示例  
```sql  
-- 测试数据：5个学生的友谊关系  
CREATE TABLE VariedStudent(id BIGINT, name VARCHAR);  
INSERT INTO VariedStudent VALUES (0, 'Alice'), (1, 'Bob'), (2, 'Charlie'), (3, 'Dave'), (4, 'Eve'), (5, 'Frank');  
  
CREATE TABLE VariedKnow(src BIGINT, dst BIGINT);  
INSERT INTO VariedKnow VALUES (0,1), (0,2), (0,3), (1,2), (2,3), (3,4), (4,5);  
  
-- 计算聚集系数  
SELECT id, local_clustering_coefficient   
FROM local_clustering_coefficient(varied_pg, variedstudent, variedknow);  
```  
结果显示：  
- Alice (0): 0.67 - 她的朋友Bob、Charlie、Dave之间有一定联系  
- Bob (1): 1.0 - 他的所有朋友都互相认识（形成三角形）    
  
### 实现细节  
使用位图数据结构优化邻居查找，对于度数小于2的节点直接返回0.0  。  
  
## 6. 中心性分析  
  
### 原理与定义  
PageRank算法衡量节点的重要性，基于随机游走模型，使用迭代幂法计算  。  
  
### 应用场景  
- **搜索引擎**：网页排名  
- **社交网络**：识别影响力人物  
- **推荐系统**：权重分配  
  
### 使用示例  
  
#### PageRank计算  
```sql  
-- 计算每个节点的PageRank值  
SELECT vertex_id, pagerank_score   
FROM pagerank(social_network, person, knows);  
```  
  
#### 重要节点发现  
```sql  
-- 找出PageRank最高的前10个节点  
SELECT vertex_id, pagerank_score  
FROM pagerank(social_network, person, knows)  
ORDER BY pagerank_score DESC  
LIMIT 10;  
```  
  
#### 实际数据示例  
```sql  
-- Bluesky社交网络的PageRank分析  
from pagerank(bluesky, account, follows) limit 10;  
```  
结果示例：  
```  
did:plc:rsfoi33e4iya2rd7jw52nfmo  0.0001775254576762574  
did:plc:btsulrw4wcqdai23fkl5qwm5  0.0002686321909810804  
did:plc:z72i7hdynmk6r22z27h6tvur  0.0008689709539525615  
```    
  
### 实现细节  
PageRank使用阻尼因子0.85，收敛阈值1e-6，状态在首次计算后缓存以供后续查询使用  。  
  
## 7. 可达性分析  
  
### 原理与定义  
测试一个节点是否可以到达另一个节点，使用自适应BFS算法优化性能  。  
  
### 使用示例  
  
#### 基本可达性测试  
```sql  
-- 测试节点5是否可以到达节点20  
SELECT reachability(csr_id, false, 1000, 5, 20) AS is_reachable;  
```  
  
#### 自适应模式  
```sql  
-- 使用自适应算法选择最优策略  
SELECT reachability(csr_id, true, 1000, 5, 20) AS is_reachable;  
```  
  
## 8. 综合应用案例  
  
### 社交网络分析平台  
```sql  
-- 1. 网络概览  
SELECT   
    COUNT(DISTINCT componentId) as num_communities,  
    COUNT(*) as total_users,  
    AVG(local_clustering_coefficient) as avg_clustering  
FROM weakly_connected_component(social_network, person, knows) wcc  
JOIN local_clustering_coefficient(social_network, person, knows) lcc ON wcc.id = lcc.id;  
  
-- 2. 影响力人物分析  
SELECT   
    p.id,  
    pr.pagerank_score,  
    lcc.local_clustering_coefficient,  
    (SELECT COUNT(*) FROM GRAPH_TABLE(social_network   
        MATCH (p)-[f:follows]->(other) COLUMNS (1)) as follower_count  
FROM person p  
JOIN pagerank(social_network, person, knows) pr ON p.id = pr.vertex_id  
JOIN local_clustering_coefficient(social_network, person, knows) lcc ON p.id = lcc.id  
ORDER BY pr.pagerank_score DESC  
LIMIT 10;  
  
-- 3. 社区发现  
SELECT componentId, COUNT(*) as community_size  
FROM weakly_connected_component(social_network, person, knows)  
GROUP BY componentId  
ORDER BY community_size DESC;  
```  
  
### 推荐系统  
```sql  
-- 基于多维度的好友推荐  
WITH user_profile AS (  
    SELECT   
        id,  
        local_clustering_coefficient as clustering,  
        pagerank_score as influence  
    FROM local_clustering_coefficient(social_network, person, knows) lcc  
    JOIN pagerank(social_network, person, knows) pr ON lcc.id = pr.vertex_id  
    WHERE id = :target_user_id  
),  
potential_friends AS (  
    SELECT DISTINCT b2.id as candidate_id  
    FROM GRAPH_TABLE(social_network  
        MATCH (me:Person WHERE me.id = :target_user_id)-[f1:follows]->(friend:Person)-[f2:follows]->(b2:Person)  
        WHERE NOT EXISTS(MATCH (me)-[f3:follows]->(b2))  
        COLUMNS (b2.id)  
    )  
)  
SELECT   
    pf.candidate_id,  
    lcc.local_clustering_coefficient,  
    pr.pagerank_score,  
    path_length(sp.path) as distance  
FROM potential_friends pf  
JOIN local_clustering_coefficient(social_network, person, knows) lcc ON pf.candidate_id = lcc.id  
JOIN pagerank(social_network, person, knows) pr ON pf.candidate_id = pr.vertex_id  
CROSS JOIN (  
    SELECT element_id(p) as path, path_length(p)  
    FROM GRAPH_TABLE(social_network  
        MATCH p = ANY SHORTEST (a:Person WHERE a.id = :target_user_id)-[f:follows]->*(b:Person WHERE b.id = pf.candidate_id)  
        COLUMNS (element_id(p), path_length(p))  
    )  
) sp  
ORDER BY (lcc.local_clustering_coefficient * 0.3 + pr.pagerank_score * 0.7) DESC  
LIMIT 10;  
```  
  
## Notes  
  
这些图挖掘特征通过CSR（压缩稀疏行）数据结构高效实现，支持大规模图数据分析  。算法经过专门优化，如聚集系数使用位图加速邻居查找，连通性分析使用路径压缩等  。这些功能使得属性图成为挖掘复杂关系数据的强大工具，适用于社交网络分析、推荐系统、知识图谱等多种应用场景。  
  
  
  
-----      
  
# 广度优先与深度优先搜索详解  
  
## 核心概念对比  
  
广度优先搜索（BFS）和深度优先搜索（DFS）是图遍历的两种基本策略，就像探索迷宫的两种不同方法。  
  
### 广度优先搜索（BFS）  
**核心思想**：像水波纹一样逐层扩散，先访问距离起点最近的节点，再访问稍远的节点。  
  
**实现特点**：  
- 使用队列数据结构  
- 保证找到最短路径（在无权图中）  
- 适合寻找最短路径、连通分量等    
  
### 深度优先搜索（DFS）  
**核心思想**：像走迷宫一样一条路走到黑，遇到死胡同再回退。  
  
**实现特点**：  
- 使用栈或递归  
- 内存占用相对较少  
- 适合拓扑排序、检测环等  
  
## DuckPGQ中的BFS实现  
  
### 1. 可达性分析中的BFS  
  
```cpp  
static int16_t InitialiseBfs(idx_t curr_batch, idx_t size, data_ptr_t src_data,   
                             const SelectionVector *src_sel, const ValidityMask &src_validity,  
                             vector<std::bitset<LANE_LIMIT>> &seen,  
                             vector<std::bitset<LANE_LIMIT>> &visit,  
                             vector<std::bitset<LANE_LIMIT>> &visit_next,  
                             unordered_map<int64_t, pair<int16_t, vector<idx_t>>> &lane_map)  
```  
  
这个函数初始化BFS搜索，使用位集数据结构来跟踪已访问和待访问的节点  。  
  
### 2. SIMD并行BFS  
  
```cpp  
static bool BfsWithoutArrayVariant(bool exit_early, CSR *csr, int64_t input_size,  
                                   vector<std::bitset<LANE_LIMIT>> &seen,  
                                   vector<std::bitset<LANE_LIMIT>> &visit,  
                                   vector<std::bitset<LANE_LIMIT>> &visit_next,  
                                   vector<int64_t> &visit_list)  
```  
  
实现了SIMD风格的并行BFS，可以同时处理多个搜索请求  。  
  
### 3. 自适应BFS策略  
  
系统支持三种BFS模式：  
- **NO_ARRAY模式**：基础BFS实现  
- **ARRAY模式**：使用数组优化，适合访问节点较少的情况  
- **INTERMEDIATE模式**：临时状态模式，平衡性能和内存使用    
  
## 最短路径中的BFS应用  
  
### 迭代BFS实现  
  
```cpp  
static bool IterativeLength(int64_t v_size, int64_t *V, vector<int64_t> &E,  
                            vector<std::bitset<LANE_LIMIT>> &seen,  
                            vector<std::bitset<LANE_LIMIT>> &visit,  
                            vector<std::bitset<LANE_LIMIT>> &next)  
```  
  
这个函数实现了BFS的每一次迭代，维护三个位集：已访问、当前访问、下一层访问  。  
  
### 双向BFS优化  
  
```cpp  
static bool IterativeLengthBidirectional(int64_t v_size, int64_t *V, vector<int64_t> &E,  
                                         vector<std::bitset<LANE_LIMIT>> &seen,  
                                         vector<std::bitset<LANE_LIMIT>> &visit,  
                                         vector<std::bitset<LANE_LIMIT>> &next)  
```  
  
从起点和终点同时进行BFS，当两个搜索相遇时停止，大幅提升性能  。  
  
## 实际应用示例  
  
### 1. 基础可达性查询  
  
```sql  
-- 测试节点5是否可以到达节点20  
SELECT reachability(csr_id, false, 1000, 5, 20) AS is_reachable;  
```  
  
### 2. 最短路径查询  
  
```sql  
-- 查找两个用户间的最短路径  
FROM GRAPH_TABLE(social_network  
    MATCH p = ANY SHORTEST (a:Person WHERE a.id = 0)-[f:follows]->*(b:Person WHERE b.id = 100)  
    COLUMNS (element_id(p) as path, path_length(p), vertices(p))  
);  
```    
  
### 3. 无向图路径搜索  
  
```sql  
-- 在无向图中查找最短路径  
FROM GRAPH_TABLE(pg  
    MATCH o = ANY SHORTEST (a:Student WHERE a.id = 0)-[e:know]-*(b:Student)  
    COLUMNS (a.id as a_id, b.id as b_id, path_length(o))  
);  
```    
  
## 性能优化技术  
  
### 1. CSR数据结构  
使用压缩稀疏行格式存储图，大幅减少内存使用和提高缓存效率  。  
  
### 2. 位集并行处理  
使用`std::bitset<LANE_LIMIT>`同时处理64个搜索请求，实现SIMD并行  。  
  
### 3. 早期退出机制  
当找到目标节点时立即停止搜索，避免不必要的计算  。  
  
## 算法选择指南  
  
| 场景 | 推荐算法 | 原因 |  
|------|----------|------|  
| 最短路径 | BFS | 保证找到最短路径 |  
| 连通性检测 | BFS/DFS | 都可以，BFS更适合并行 |  
| 拓扑排序 | DFS | DFS天然适合 |  
| 内存受限 | DFS | DFS通常内存占用更少 |  
| 并行处理 | BFS | BFS更容易并行化 |  
  
## Notes  
  
DuckPGQ的实现主要专注于BFS算法，因为图查询场景中最短路径和可达性分析更常见。BFS实现采用了多种优化技术，包括SIMD并行、双向搜索和自适应策略，能够高效处理大规模图数据  。虽然DFS在代码库中没有直接实现，但理解两种算法的差异有助于选择合适的图分析方法。  
  
  
  
-----      
  
# DuckDB-PGQ 相比其他图数据库的优势及劣势  
  
## 核心优势  
  
### 1. **基于成熟的关系数据库**  
DuckPGQ构建在DuckDB之上，继承了其高性能分析引擎的优势  。这意味着：  
- 无需学习全新的数据库系统  
- 可以同时使用SQL和图查询  
- 享受DuckDB的列式存储优化  
  
### 2. **零数据迁移成本**  
DuckPGQ在现有关系数据上创建逻辑图层，无需复制或迁移数据  。这对比传统图数据库需要ETL过程是巨大优势。  
  
### 3. **SQL/PGQ标准兼容**  
遵循国际标准，语法规范，学习成本低  。查询示例：  
```sql  
FROM GRAPH_TABLE(social_network  
    MATCH (a:Person)-[f:follows]->*(b:Person)  
    COLUMNS (a.name, b.name)  
);  
```  
  
### 4. **高性能算法实现**  
- 使用CSR数据结构优化图遍历    
- SIMD并行处理，同时处理64个搜索请求    
- 双向BFS优化最短路径搜索    
  
### 5. **易于部署**  
作为DuckDB社区扩展，安装简单  ：  
```sql  
install duckpgq from community;  
load duckpgq;  
```  
  
## 主要劣势  
  
### 1. **功能相对有限**  
相比Neo4j等成熟图数据库，DuckPGQ功能还在发展中：  
- 缺少图数据修改语言（GQL）  
- 事务支持有限  
- 图算法库不够丰富  
  
### 2. **性能特化**  
主要针对分析场景优化，对于高频写入的实时图应用可能不是最佳选择。  
  
### 3. **生态系统较小**  
- 社区相对较小  
- 工具链不如传统图数据库完善  
- 学习资源相对较少  
  
### 4. **内存限制**  
基于DuckDB的内存管理机制，超大规模图数据可能受限于内存大小。  
  
## 适用场景对比  
  
| 场景 | DuckPGQ | 传统图数据库 |  
|------|---------|-------------|  
| 数据分析 | ✅ 优势明显 | ⚠️ 需要ETL |  
| 实时写入 | ⚠️ 一般 | ✅ 优势明显 |  
| 混合工作负载 | ✅ SQL+图查询 | ❌ 需要多系统 |  
| 快速原型 | ✅ 部署简单 | ⚠️ 配置复杂 |  
| 生产环境 | ⚠️ 发展中 | ✅ 成熟稳定 |  
  
## 实际选择建议  
  
### 选择DuckPGQ当：  
- 已有关系数据需要图分析  
- 主要进行批量分析而非实时查询  
- 团队熟悉SQL，学习成本敏感  
- 需要快速验证图分析想法  
  
### 选择传统图数据库当：  
- 需要完整的图数据库功能  
- 有大量实时写入需求  
- 需要成熟的生产环境支持  
- 图数据是主要而非次要数据模型  
  
## Notes  
  
DuckPGQ作为研究项目，正在快速发展中  。它的设计理念是"让图查询触手可及"，特别适合已有关系数据的组织进行图分析探索。随着SQL/PGQ标准的普及，DuckPGQ这类基于SQL的图解决方案可能会获得更多关注。  
  
  
  
-----      
  
# 属性图搜索性能优化技巧  
  
属性图搜索性能优化就像给搜索引擎装上涡轮增压，让查询速度飞起来。以下是DuckPGQ中的核心优化技巧：  
  
## 核心优化技术  
  
### 1. **SIMD并行处理**  
使用位集同时处理多个搜索请求，就像同时处理64个不同的导航任务  。  
  
```cpp  
vector<std::bitset<LANE_LIMIT>> seen(v_size);  
vector<std::bitset<LANE_LIMIT>> visit1(v_size);  
vector<std::bitset<LANE_LIMIT>> visit2(v_size);  
```  
  
### 2. **双向BFS搜索**  
从起点和终点同时搜索，就像两队人马从两端同时修路，在中间汇合  。  
  
```cpp  
std::bitset<LANE_LIMIT> InterSectFronteers(int64_t v_size,   
                                          vector<std::bitset<LANE_LIMIT>> &src_seen,  
                                          vector<std::bitset<LANE_LIMIT>> &dst_seen)  
```  
  
### 3. **CSR数据结构**  
使用压缩稀疏行格式存储图数据，大幅减少内存占用  。  
  
### 4. **自适应算法选择**  
根据图的特征自动选择最优算法  。  
  
## 详细优化技巧  
  
### SIMD并行优化  
  
#### 原理  
使用`std::bitset<LANE_LIMIT>`（LANE_LIMIT=512）同时处理多个搜索请求  。  
  
#### 实现示例  
```cpp  
// 同时处理64个搜索任务  
for (int64_t lane = 0; lane < LANE_LIMIT; lane++) {  
    lane_to_num[lane] = -1; // 初始化所有通道  
    while (started_searches < args.size()) {  
        // 将搜索任务分配到空闲通道  
        visit1[src_data[src_pos]][lane] = true;  
        lane_to_num[lane] = search_num;  
        active++;  
        break;  
    }  
}  
```    
  
#### 性能提升  
- 单次处理64个请求  
- 减少函数调用开销  
- 提高CPU缓存利用率  
  
### 双向BFS优化  
  
#### 算法流程  
1. 从起点开始正向搜索  
2. 从终点开始反向搜索  
3. 检测两个搜索前沿的交集  
4. 当找到交集时停止    
  
#### 性能优势  
搜索空间从O(b^d)降低到O(b^(d/2))，其中b是分支因子，d是路径长度。  
  
#### 实际应用  
```sql  
-- 自动使用双向BFS的最短路径查询  
FROM GRAPH_TABLE(social_network  
    MATCH p = ANY SHORTEST (a:Person)-[f:follows]->*(b:Person)  
    COLUMNS (path_length(p))  
);  
```  
  
### CSR数据结构优化  
  
#### 存储格式  
- **顶点数组**：存储每个顶点的邻接边起始位置  
- **边数组**：连续存储所有目标顶点  
- **权重数组**：存储边权重（可选）    
  
#### 内存优势  
- 消除指针开销  
- 提高缓存局部性  
- 支持顺序访问  
  
### 早期退出机制  
  
#### 实现原理  
当找到目标节点时立即停止搜索，避免不必要的遍历  。  
  
```cpp  
// 检测已完成的通道  
for (int64_t lane = 0; lane < LANE_LIMIT; lane++) {  
    if ((iter & 1) ? visit2[dst_data[dst_pos]][lane] : visit1[dst_data[dst_pos]][lane]) {  
        result_data[search_num] = iter; // 找到路径，立即返回  
        lane_to_num[lane] = -1;  
        active--;  
    }  
}  
```  
  
### 自适应策略选择  
  
#### 三种模式  
1. **NO_ARRAY**：基础BFS，适合小规模搜索  
2. **ARRAY**：数组优化，适合访问节点较少的情况  
3. **INTERMEDIATE**：平衡模式，中等规模搜索    
  
#### 选择依据  
- 图的规模  
- 搜索距离  
- 内存限制  
  
## 实际优化案例  
  
### 社交网络查询优化  
  
#### 原始查询  
```sql  
-- 可能遍历整个网络  
SELECT * FROM GRAPH_TABLE(social_network  
    MATCH (a:Person)-[f:follows]->*(b:Person)  
    WHERE a.id = 0 AND b.id = 1000  
);  
```  
  
#### 优化版本  
```sql  
-- 使用路径限制和早期退出  
FROM GRAPH_TABLE(social_network  
    MATCH p = ANY SHORTEST (a:Person WHERE a.id = 0)-[f:follows]->{1,5}(b:Person WHERE b.id = 1000)  
    COLUMNS (path_length(p), vertices(p))  
);  
```  
  
### 批量查询优化  
  
#### 使用SIMD并行  
```sql  
-- 同时处理多个源-目标对  
SELECT reachability(csr_id, true, 1000, src_id, dst_id)  
FROM (VALUES (0,100), (1,200), (2,300)) AS t(src_id, dst_id);  
```  
  
### 内存管理优化  
  
#### CSR生命周期管理  
```cpp  
// 查询结束后自动清理CSR  
duckpgq_state->csr_to_delete.insert(info.csr_id);  
```  
  
  
## 性能测试建议  
  
### 测试指标  
1. **查询响应时间**：单个查询的执行时间  
2. **吞吐量**：单位时间内处理的查询数  
3. **内存使用**：峰值内存占用  
4. **扩展性**：不同图规模下的性能表现  
  
### 优化验证  
```sql  
-- 使用EXPLAIN分析查询计划  
EXPLAIN FROM GRAPH_TABLE(social_network  
    MATCH p = ANY SHORTEST (a:Person)-[f:follows]->*(b:Person)  
    COLUMNS (path_length(p))  
);  
```    
  
## 最佳实践总结  
  
1. **合理使用路径量词**：避免无限制的`*`搜索  
2. **批量处理查询**：利用SIMD并行能力  
3. **选择合适算法**：根据场景选择单向或双向BFS  
4. **监控内存使用**：及时清理不需要的CSR结构  
5. **利用索引**：在顶点ID上创建适当的索引  
  
## Notes  
  
这些优化技术使得DuckPGQ能够在关系数据库上实现接近原生图数据库的性能  。关键在于充分利用现代CPU的并行计算能力和缓存优化，同时通过智能算法选择减少不必要的计算开销。  
  
  
  
-----      
  
# 属性图综合示例：校园社交网络分析  
  
下面我们通过一个完整的校园社交网络案例，展示属性图从创建到高级分析的全过程。  
  
## 场景设定  
假设我们要分析一个大学校园的社交网络，包括学生信息、学生之间的友谊关系，以及学生就读的学校信息。  
  
## 第一步：创建基础数据表  
  
```sql  
-- 创建学生表  
CREATE TABLE Student(id BIGINT, name VARCHAR);  
INSERT INTO Student VALUES   
    (0, 'Daniel'),   
    (1, 'Tavneet'),   
    (2, 'Gabor'),   
    (3, 'Peter'),   
    (4, 'David');  
  
-- 创建友谊关系表  
CREATE TABLE know(src BIGINT, dst BIGINT, createDate BIGINT);  
INSERT INTO know VALUES   
    (0,1, 10), (0,2, 11), (0,3, 12), (3,0, 13),   
    (1,2, 14), (1,3, 15), (2,3, 16), (4,3, 17);  
  
-- 创建学校表  
CREATE TABLE School(name VARCHAR, Id BIGINT, Kind VARCHAR);  
INSERT INTO School VALUES   
    ('VU', 0, 'University'),   
    ('UVA', 1, 'University');  
  
-- 创建就读关系表  
CREATE TABLE StudyAt(personId BIGINT, schoolId BIGINT);  
INSERT INTO StudyAt VALUES   
    (0, 0), (1, 0), (2, 1), (3, 1), (4, 1);  
```    
  
## 第二步：创建属性图  
  
```sql  
CREATE PROPERTY GRAPH campus_network  
VERTEX TABLES (  
    Student PROPERTIES (id, name) LABEL Person,  
    School LABEL SCHOOL  
)  
EDGE TABLES (  
    know    SOURCE KEY (src) REFERENCES Student (id)  
            DESTINATION KEY (dst) REFERENCES Student (id)  
            LABEL Knows,  
    studyAt SOURCE KEY (personId) REFERENCES Student (id)  
            DESTINATION KEY (SchoolId) REFERENCES School (id)  
            LABEL StudyAt  
);  
```    
  
## 第三步：基础图查询  
  
### 查询1：查找Daniel的学校信息  
  
```sql  
SELECT study.name, study.school  
FROM GRAPH_TABLE (campus_network  
    MATCH (a:Person)-[s:StudyAt]->(b:School)  
    WHERE a.name = 'Daniel'  
    COLUMNS (a.name as name, b.name as school)  
) study;  
```    
  
**结果**：  
```  
Daniel  VU  
```  
  
### 查询2：查找Daniel的同学  
  
```sql  
SELECT study.name, study.school, study.know_name  
FROM GRAPH_TABLE (campus_network  
    MATCH (a2:Person)-[s2:StudyAt]->(b:School)<-[s:StudyAt]-(a:Person)  
    WHERE a.name = 'Daniel' and a.id <> a2.id  
    COLUMNS (a.name as name, b.name as school, a2.name as know_name)  
) study;  
```    
  
**结果**：  
```  
Daniel  VU  Tavneet  
```  
  
### 查询3：查找所有友谊关系  
  
```sql  
SELECT a_name, b_name  
FROM GRAPH_TABLE (campus_network  
    MATCH (a:Person)-[k:Knows]->(b:Person)  
    COLUMNS (a.name as a_name, b.name as b_name)  
) study;  
```    
  
## 第四步：高级图分析  
  
### 分析1：最短路径分析  
  
```sql  
-- 查找Daniel到其他所有人的最短路径  
FROM GRAPH_TABLE(campus_network  
    MATCH p = ANY SHORTEST (a:Person WHERE a.name = 'Daniel')-[k:Knows]->*(b:Person)  
    COLUMNS (element_id(p) as path, path_length(p), a.name as from_name, b.name as to_name)  
);  
```  
  
### 分析2：社交圈发现  
  
```sql  
-- 使用连通分量分析发现社交圈子  
SELECT id, componentId   
FROM weakly_connected_component(campus_network, Person, Knows);  
```  
  
### 分析3：影响力分析  
  
```sql  
-- 计算每个学生的PageRank值  
SELECT vertex_id, pagerank_score   
FROM pagerank(campus_network, Person, Knows)  
ORDER BY pagerank_score DESC;  
```  
  
### 分析4：聚集性分析  
  
```sql  
-- 计算每个学生的聚集系数  
SELECT s.id, s.name, lcc.local_clustering_coefficient  
FROM local_clustering_coefficient(campus_network, Person, Knows) lcc  
JOIN Student s ON s.id = lcc.id  
ORDER BY lcc.local_clustering_coefficient DESC;  
```    
  
## 第五步：综合业务分析  
  
### 业务场景1：推荐系统  
  
```sql  
-- 为Daniel推荐朋友的朋友  
WITH friends_of_friends AS (  
    SELECT DISTINCT b2.id as recommended_id, b2.name as recommended_name  
    FROM GRAPH_TABLE(campus_network  
        MATCH (me:Person WHERE me.name = 'Daniel')-[k1:Knows]->(friend:Person)-[k2:Knows]->(b2:Person)  
        WHERE NOT EXISTS(  
            MATCH (me)-[k3:Knows]->(b2)  
        )  
        COLUMNS (b2.id, b2.name)  
    )  
)  
SELECT recommended_name,   
       lcc.local_clustering_coefficient as social_influence  
FROM friends_of_friends fof  
JOIN local_clustering_coefficient(campus_network, Person, Knows) lcc ON fof.recommended_id = lcc.id  
ORDER BY social_influence DESC;  
```  
  
### 业务场景2：校园影响力分析  
  
```sql  
-- 综合分析校园社交网络  
WITH influence_metrics AS (  
    SELECT   
        p.id,  
        p.name,  
        pr.pagerank_score as network_importance,  
        lcc.local_clustering_coefficient as social_cohesion,  
        (SELECT COUNT(*) FROM GRAPH_TABLE(campus_network   
            MATCH (p)-[k:Knows]->(other) COLUMNS (1)) as friend_count  
    FROM Person p  
    JOIN pagerank(campus_network, Person, Knows) pr ON p.id = pr.vertex_id  
    JOIN local_clustering_coefficient(campus_network, Person, Knows) lcc ON p.id = lcc.id  
)  
SELECT name,   
       network_importance,  
       social_cohesion,  
       friend_count,  
       (network_importance * 0.5 + social_cohesion * 0.3 + friend_count * 0.2) as overall_score  
FROM influence_metrics  
ORDER BY overall_score DESC;  
```  
  
## 第六步：性能优化实践  
  
### 优化1：使用路径限制  
  
```sql  
-- 限制搜索深度，提高性能  
FROM GRAPH_TABLE(campus_network  
    MATCH p = ANY SHORTEST (a:Person)-[k:Knows]->{1,3}(b:Person)  
    COLUMNS (path_length(p), a.name, b.name)  
);  
```    
  
### 优化2：批量查询  
  
```sql  
-- 同时处理多个最短路径查询  
SELECT   
    src_id, dst_id,   
    path_length(sp.path) as distance  
FROM (VALUES   
    (0, 1), (0, 2), (0, 3), (1, 2), (1, 3)  
) AS queries(src_id, dst_id)  
CROSS JOIN (  
    SELECT element_id(p) as path, path_length(p)  
    FROM GRAPH_TABLE(campus_network  
        MATCH p = ANY SHORTEST (a:Person WHERE a.id = queries.src_id)-[k:Knows]->*(b:Person WHERE b.id = queries.dst_id)  
        COLUMNS (element_id(p), path_length(p))  
    )  
) sp;  
```  
  
## 第七步：清理资源  
  
```sql  
-- 删除属性图  
DROP PROPERTY GRAPH campus_network;  
```    
  
## 实际应用价值  
  
这个综合示例展示了属性图在以下场景中的应用：  
  
1. **教育管理**：分析学生社交网络，优化班级分配  
2. **推荐系统**：基于社交关系推荐课程、活动或朋友  
3. **校园安全**：识别孤立学生，及时提供帮助  
4. **资源分配**：根据影响力分配奖学金或机会  
5. **研究分析**：理解校园社交动态，支持教育研究  
  
## Notes  
  
这个综合示例涵盖了属性图的核心功能，从基础创建到高级分析  。通过实际案例展示了如何将关系数据转换为图结构，并利用图算法挖掘有价值的信息。DuckPGQ的优势在于可以在现有关系数据上直接进行图分析，无需数据迁移  。  
  
  
    
#### [PolarDB 学习图谱](https://www.aliyun.com/database/openpolardb/activity "8642f60e04ed0c814bf9cb9677976bd4")
  
  
#### [PostgreSQL 解决方案集合](../201706/20170601_02.md "40cff096e9ed7122c512b35d8561d9c8")
  
  
#### [德哥 / digoal's Github - 公益是一辈子的事.](https://github.com/digoal/blog/blob/master/README.md "22709685feb7cab07d30f30387f0a9ae")
  
  
#### [About 德哥](https://github.com/digoal/blog/blob/master/me/readme.md "a37735981e7704886ffd590565582dd0")
  
  
![digoal's wechat](../pic/digoal_weixin.jpg "f7ad92eeba24523fd47a6e1a0e691b59")
  
