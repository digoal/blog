## PostgreSQL 19 preview - 再次提高逻辑复制可靠性  
                                                                      
### 作者                                                                      
digoal                                                                      
                                                                      
### 日期                                                                      
2025-12-15                                                                     
                                                                      
### 标签                                                                      
PostgreSQL , pg_sync_replication_slots , promote , 中断slot状态同步 , 立即promote , 重试机制                              
                                                                      
----                                                                      
                                                                      
## 背景    
人工补充一下:   
  
什么是同步复制槽? 目的就是保证使用物理流复制从库时, 如果发生failover(激活从库成为新主库), 这个同步复制槽的消费者漂移到新激活的主库上时, 不会丢数据.  
  
基于这个前提条件, 以某个同步复制槽为例, 消费者在老的主库上消费的最后的WAL位点, 此前的所有WAL必须已经同步给从库.  
  
`pg_sync_replication_slots()`的作用是, 类似设置了一个栅栏, 在从库执行它时, 这个函数返回true之前, 必须等待此函数调用前就已经在老主库上存在的所有同步复制槽, 这些槽的已消费的WAL(如果有多个同步复制槽, 则取最小的那个wal), 此位置之前的所有WAL都已经同步到当前从库.  
  
但是这个逻辑还是有个小问题, 因为这个操作是异步的, 你在从库看到的永远是主库过去的slot状态, 所以消费者在主库不断消费, 你看到的wal永远比实际情况更早(旧).  
  
因此补丁不是保证在从库激活成新的主库后不丢wal, 而是保证它不删消费者需要的wal. 大不了多消费(消费层面要做好幂等), 但绝对不能少.  
  
不丢WAL是另一个逻辑保证的, 也就是PG 很早的版本就已经存在的同步流复制(quarum based sync replication).  不过这个也有漏洞, 当同步出现堵塞时, 它只是阻止commit返回给客户端, 不阻止本地wal持久化, 所以结果是客户端感觉还没提交(因为一直没有收到返回), 实际上这个事务的wal已经在本地持久化. 在这个情况下, 主库上的消费者是可以消费这个wal的.   
  
这种情况下, 逻辑消费者可能比物理的从库同步了更多的信息. 所以`pg_sync_replication_slots()`在这个场景下也有作用, 它可以将slot标记为未同步.     
   
继续补充, 同步复制槽的功能开启有点复杂:   
参考文档 https://www.postgresql.org/docs/current/logicaldecoding-explanation.html  
  
For the synchronization to work, it is mandatory to have a physical replication slot between the primary and the standby (i.e., primary_slot_name should be configured on the standby), and hot_standby_feedback must be enabled on the standby. It is also necessary to specify a valid dbname in the primary_conninfo. It's highly recommended that the said physical replication slot is named in synchronized_standby_slots list on the primary, to prevent the subscriber from consuming changes faster than the hot standby. Even when correctly configured, some latency is expected when sending changes to logical subscribers due to the waiting on slots named in synchronized_standby_slots. When synchronized_standby_slots is utilized, the primary server will not completely shut down until the corresponding standbys, associated with the physical replication slots specified in synchronized_standby_slots, have confirmed receiving the WAL up to the latest flushed position on the primary server.  
  
- 首先需要找一个物理standby, 把它当成同步复制节点(我说的是逻辑复制层面的同步, 因为它只影响逻辑订阅)  
- 然后要把这个物理standby节点连接主节点用到的物理复制槽配置到主节点的 synchronized_standby_slots 里面  
- 这个物理standby节点要开启 hot_standby_feedback (开启这个的副作用聊过, 意味着这个从节点的长事务可能导致主库的膨胀、CPU/IO标高(vacuum 无用功造成的))   
- 最后, 主节点如果要停库, 它需要等待这个物理standby已完全同步主节点最后的WAL flushed position  
  
当然, 这是PG 18的情况, 用可用性换取切换后逻辑订阅同步复制槽的可靠性. 19也许会有改观. 例如是不是不用配置单一的物理standby来保障逻辑同步复制槽的可靠性, 而是直接和quorum base sync standby结合起来呢?   
  
  
  
**开始AI解读:**   
   
https://github.com/postgres/postgres/commit/0d2d4a0ec3eca64e7f5ce7f7630b56a561b2663c  

这个补丁（Commit `0d2d4a0ec3eca64e7f5ce7f7630b56a561b2663c`）的主要目的是为 PostgreSQL 的管理函数 **`pg_sync_replication_slots()`** 添加**重试逻辑（retry logic）** ，以提高其在同步复制槽时的可靠性。  
  
以下是对该补丁的解读：  
  
### 补丁解决的问题  
  
在引入此补丁之前，`pg_sync_replication_slots()` 函数的行为存在一个问题：  
  
1.  当该函数在备用服务器（standby）上运行时，如果某些复制槽（replication slots）不满足同步要求（例如，主服务器上所需的数据目录行或 WAL 段缺失，或面临被移除的风险），函数会直接完成，但不会同步这些不满足要求的槽，而是将它们遗漏。  
2.  这可能导致部分用于故障转移（failover）的复制槽处于未同步状态。更糟糕的是，备用服务器可能会继续移除主服务器提升后所需的数据，从而使故障转移槽无法使用。  
  
### 补丁实施的更改（解决方案）  
  
该补丁通过引入**循环重试机制**来解决上述问题，确保所有必需的槽都得到同步：  
  
1.  **等待机制：** 函数现在会等待主槽（primary slot）推进到一个位置，确保备用服务器上所需的所有数据（WAL 或目录行）都可用，然后再完成同步。  
2.  **循环重试：** 它将循环重试，直到在函数调用开始时存在于主服务器上的**所有**故障转移槽都被同步。  
3.  **范围限定：** 在函数开始运行后创建的槽将**不会**被包含在此次同步周期内。  
4.  **优雅退出：** 如果在等待过程中备用服务器被提升为新的主服务器，该函数会优雅地退出，并移除在此过程中创建的临时槽。  
  
简而言之，此补丁将手动同步复制槽的函数 `pg_sync_replication_slots()` 变得像自动同步机制一样健壮，能够处理暂时的 WAL 文件不可用等情况，显著提高了在高可用性场景中故障转移槽的可靠性。  
  
### 文件变动（文档部分）  
  
补丁也相应更新了 PostgreSQL 的 SGML 文档，确认了 `pg_sync_replication_slots()` 的行为变化：  
  
* 删除了关于此函数“主要用于测试和调试，并且更容易失败”的警告。  
* 明确指出该函数现在会“循环重试，直到在函数调用开始时存在于主服务器上的所有故障转移槽都被同步”。  
    
#### [PolarDB 学习图谱](https://www.aliyun.com/database/openpolardb/activity "8642f60e04ed0c814bf9cb9677976bd4")
  
  
#### [PostgreSQL 解决方案集合](../201706/20170601_02.md "40cff096e9ed7122c512b35d8561d9c8")
  
  
#### [德哥 / digoal's Github - 公益是一辈子的事.](https://github.com/digoal/blog/blob/master/README.md "22709685feb7cab07d30f30387f0a9ae")
  
  
#### [About 德哥](https://github.com/digoal/blog/blob/master/me/readme.md "a37735981e7704886ffd590565582dd0")
  
  
![digoal's wechat](../pic/digoal_weixin.jpg "f7ad92eeba24523fd47a6e1a0e691b59")
  
