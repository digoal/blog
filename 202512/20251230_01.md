## 大学生数据库实践课 : 实验手册  
  
### 作者  
digoal  
  
### 日期  
2025-12-30  
  
### 标签  
PostgreSQL , DuckDB , 语义搜索 , 向量搜索 , 关键词检索 , 全文检索 , 标量检索 , 混合搜索 , 多模态搜索 , 重排序 , embedding , document split , ORC , 大模型 , 多模态大模型 , Dify , 压力测试 , 索引优化 , 倒排向量索引 , Ivfflat , 图向量索引 , HNSW , DiskANN , 量化 , rabitq , sbq , 二值量化 , bm25 , 相关性 , 相似性 , 召回率 , pgbench , 数据集 , ann-benchmarks , 图搜索 , PGQ , 递归 , 深度优先 , 广度优先 , 最短路径 , N度关系 , LLM , Ollama  
  
----  
  
## 背景  
  
## pgbench 内置压测模型  
1、初始化数据  
  
```bash  
pgbench -i -s 100  
```  
  
2、读写测试  
  
```bash  
pgbench -M prepared -n -r -P 1 -c 10 -j 10 -T 120  
```  
  
3、只读测试  
  
```bash  
pgbench -M prepared -n -r -P 1 -c 10 -j 10 -T 120 -S  
```  
  
## pgbench 自定义压测  
  
参考  
  
[《沉浸式学习PostgreSQL|PolarDB 12: 如何快速构建 海量 逼真 测试数据》](../202309/20230906_02.md)  如何快速构建高斯分布的数据  
  
[《HTAP数据库 PostgreSQL 场景与性能测试之 30 - (OLTP) 秒杀 - 高并发单点更新》](../201711/20171107_31.md)  注意观察 `pg_try_advisory_xact_lock(id)` 条件带来的性能提升.  
  
## ollama  
  
1、部署、模型拉取实验  
  
参考 [《2025-大学生数据库实践课 : AI搜索技术(向量、关键词、标量、图、以及混合搜索)》](../202512/20251202_10.md)  命令部分  
  
2、ollama shell 交互  
  
```bash  
ollama run qwen3:0.6b  
```  
  
3、ollama shell 内配置模型调用参数  
  
```  
/set parameter  
```  
  
4、ollama api 交互  
  
参考  
  
[《大学生数据库实践课: 7.4 ollama API介绍》](../202512/20251210_16.md)  “使用curl调用Ollama API的实操例子” 章节  
  
https://docs.ollama.com/api/introduction  
  
5、ollama api 配置模型调用参数  
  
参考  
  
https://docs.ollama.com/api/introduction  
  
## 云端服务  
  
参考 阿里云百炼 API  
  
https://bailian.console.aliyun.com/  
  
## 文本切分方法和向量化  
  
参考 [《大学生数据库实践课: 9 embedding 文本切分实操》](../202512/20251210_18.md)  “简化版实操” 章节  
  
## dify  
  
参考 [《3分钟速玩Dify(高度可定制的企业级AI应用开源项目)》](../202504/20250404_01.md)  
  
## 向量检索实验  
  
### 1、生成模拟向量数据  
  
创建向量插件 vector 和 测试表 vector_test  
  
也包括了测试全文检索, 标量检索, 混合检索, 量化索引等需要的字段.  
  
```sql  
create extension if not exists vector;  
  
drop table if exists vector_test;  
  
create table vector_test (  
  id serial primary key,  
  category int,  
  price int,  
  label smallint[],  
  ts timestamp,  
  info text,  
  tsvec tsvector,  
  is_center boolean,  
  center_id int,  
  embedding vector(32)  
);  
```  
  
创建一个自定义函数, 生成取值范围是 0-N 的 M个随机数组  
```sql  
create or replace function gen_array(int default 127, int default 7) returns smallint[] as $$  
  select array(select (random()*$1)::smallint from generate_series(1, 3+(random()*$2)::int));  
$$ language sql strict;  
```  
  
创建一个自定义函数, 模拟生成用于全文检索的关键字字典, 可以理解为字典化后的 tokenize 稀疏向量.  
```sql  
create or replace function gen_rand_tsvector(int,int) returns tsvector as $$  
  select array_to_tsvector(array_agg((random()*$1)::int::text)) from generate_series(1,$2);  
$$ language sql strict;  
```  
  
创建一个自定义函数, 模拟真实场景, 输入N个中心点, 每个中心点周围按高斯分布扰动生成M个点, 共N*(M+1)个点.  
  
每个维度的取值范围为 `[-1.0, 1.0]`  
  
```sql  
CREATE OR REPLACE FUNCTION generate_vector_data(  
    center_count INT,          -- 中心点数量 (例如 1000)  
    points_per_center INT,     -- 每个中心点周围生成的点数 (例如 2 → 总计 2000)  
    dims INT,                  -- 向量维度（例如 16）  
    std_dev_mean FLOAT8 DEFAULT 0.1,    -- 类内标准差的均值  
    std_dev_sigma FLOAT8 DEFAULT 0.01   -- 类内标准差的分布标准差（即“聚集性强弱”的波动）  
) RETURNS TEXT AS $$  
DECLARE  
    center_id INT;  
    center_vec FLOAT8[];  
    new_vec FLOAT8[];  
    local_std_dev FLOAT8;      -- 每个中心点自己的类内标准差  
    perturbed_val FLOAT8;  
    i INT;  
    j INT;  
    k INT;  
    u1 FLOAT8;  
    u2 FLOAT8;  
    z0 FLOAT8;  
    z_std FLOAT8;              -- 用于生成 local_std_dev 的正态扰动  
    fuhao int;  
BEGIN  
    -- 1. 生成 center_count 个完全离散随机的中心点  
    FOR i IN 1..center_count LOOP  
        -- 生成 d 维 [0,1) 随机向量作为中心  
        center_vec := ARRAY(SELECT 2*random()-1 FROM generate_series(1, dims));  
  
        -- 为当前中心点生成其“类内标准差”：N(std_dev_mean, std_dev_sigma)，但必须 > 0  
        LOOP  
            u1 := random();  
            u2 := random();  
            -- 避免除零  
            IF u1 = 0 THEN u1 := 1e-10; END IF;  
            z_std := sqrt(-2.0 * ln(u1)) * cos(2.0 * pi() * u2);  
            local_std_dev := std_dev_mean + z_std * std_dev_sigma;  
            EXIT WHEN local_std_dev > 0;  -- 确保标准差为正  
        END LOOP;  
  
        -- 插入中心点  
        INSERT INTO vector_test (category, price, label, ts, info, tsvec, embedding, is_center)  
        VALUES (random()*9, random()*999, gen_array(), clock_timestamp(), md5(random()::text), gen_rand_tsvector(5000000, 64), center_vec::vector, TRUE)  
        RETURNING id INTO center_id;  
  
        -- 2. 围绕该中心点生成 points_per_center 个聚集点  
        FOR j IN 1..points_per_center LOOP  
            new_vec := '{}';  
            FOR k IN 1..dims LOOP  
                -- 生成标准正态扰动  
                u1 := random();  
                u2 := random();  
                IF u1 = 0 THEN u1 := 1e-10; END IF;  
                z0 := sqrt(-2.0 * ln(u1)) * cos(2.0 * pi() * u2);  
  
                select case ceil(random()-0.5) when 0 then -1 else 1 end case into fuhao;  
                -- 扰动 = 中心值 + N(0, local_std_dev)  
                perturbed_val := center_vec[k] + z0 * local_std_dev * fuhao;  
  
                -- 截断到 [-1, 1]  
                perturbed_val := GREATEST(-1.0, LEAST(1.0, perturbed_val));  
  
                new_vec := array_append(new_vec, perturbed_val);  
            END LOOP;  
  
            -- 插入非中心点，并可选记录 center_id（便于后续分析）  
            INSERT INTO vector_test (category, price, label, ts, info, tsvec, embedding, is_center, center_id)  
            VALUES (random()*9, random()*999, gen_array(), clock_timestamp(), md5(random()::text), gen_rand_tsvector(5000000, 64), new_vec::vector, FALSE, center_id);  
        END LOOP;  
    END LOOP;  
  
    RETURN 'Successfully generated ' ||  
           (center_count + center_count * points_per_center)::TEXT ||  
           ' vectors (' || center_count || ' centers + ' ||  
           (center_count * points_per_center) || ' neighbors).';  
END;  
$$ LANGUAGE plpgsql;  
```  
  
定制pgbench脚本, 用来生成测试数据  
```sql  
\! echo "SELECT generate_vector_data(  
    :center_count,  
    :points_per_center,  
    :dims,  
    :std_dev_mean,  
    :std_dev_sigma  
);" > ~/1.sql  
```  
  
  
使用pgbench , 10个进程, 每个负责100个中心点, 共1000个中心点. 每个中心点附近999条记录. 32个维度. 共100万条记录 :  
```sql  
- 插入100万条测试数据  
- category: 0-9  
- price: 0-1000  
- label: 3-10 个 0-127的随机数组成的数组  
- embedding: 32维的向量  
  
  
\! pgbench -M prepared -n -r -f ~/1.sql -D center_count=100 -D points_per_center=999 -D dims=32 -D std_dev_mean=0.1 -D std_dev_sigma=0.01 -c 10 -j 10 -t 1  
```  
  
确认数据是否正常?  
  
查询记录数  
```sql  
select count(*) from vector_test;  
  
  
  count  
---------  
 1000000  
(1 row)  
```  
  
查看表大小  
```sql  
\dt+  
  
  
                                         List of tables  
 Schema |      Name      | Type  |  Owner   | Persistence | Access method |  Size  | Description  
--------+----------------+-------+----------+-------------+---------------+--------+-------------  
 public | vector_test    | table | postgres | permanent   | heap          | 977 MB |  
```  
  
查看数据样本  
```sql  
select * from vector_test limit 10;  
```  
  
### 2、观察向量索引带来的性能提升  
  
1、无索引  
```sql  
\timing  
  
set max_parallel_workers_per_gather = 0;  
set jit=off;  
  
-- 查看执行计划, 是不是使用了 seq scan 全表扫描  
explain select id, category, price, label, ts, info,  
  embedding <-> (select embedding from vector_test where id=1234) as distance  
from vector_test  
  order by embedding <-> (select embedding from vector_test where id=1234) limit 10;  
  
-- 查询看看结果  
select id, category, price, label, ts, info,  
  embedding <-> (select embedding from vector_test where id=1234) as distance  
from vector_test  
  order by embedding <-> (select embedding from vector_test where id=1234) limit 10;  
```  
  
2、观察创建 hnsw 索引的耗时  
  
```sql  
-- 设置创建hnsw索引构图时最大可用内存, 设置并行度, 创建hnsw 图向量索引.  
-- 注意 m=16, ef_construction=64 的含义  
-- 注意 vector_l2_ops 必须和查询时的距离算法匹配, vector_l2_ops 表示计算欧式距离 <-> .  还有  
-- vector_l1_ops , <+>  
-- vector_cosine_ops , <=>  
-- vector_ip_ops , <#>  
set maintenance_work_mem ='3GB';  
set max_parallel_maintenance_workers =8;  
drop index if exists idx_vector_test_hnsw;  
create index idx_vector_test_hnsw on vector_test using hnsw (embedding vector_l2_ops) with (m=16, ef_construction=64);  
  
  
-- 可以在另一个 psql 页面观察创建hnsw索引的完成进度  
SELECT phase, round(100.0 * blocks_done / nullif(blocks_total, 0), 1) AS "%" FROM pg_stat_progress_create_index;  
```  
  
3、观察 hnsw 索引查询耗时  
```sql  
set max_parallel_workers_per_gather = 0;  
set jit=off;  
set enable_seqscan=off;  
set enable_bitmapscan=off;  
set enable_indexscan=on;  
  
-- 查看执行计划, 是不是使用了 index scan 索引扫描  
explain select id, category, price, label, ts, info,  
  embedding <-> (select embedding from vector_test where id=1234) as distance  
from vector_test  
  order by embedding <-> (select embedding from vector_test where id=1234) limit 10;  
  
-- 查询看看结果, 记录耗时  
select id, category, price, label, ts, info,  
  embedding <-> (select embedding from vector_test where id=1234) as distance  
from vector_test  
  order by embedding <-> (select embedding from vector_test where id=1234) limit 10;  
```  
  
### 3、召回率实验  
  
1、理解如何统计召回率.  
  
召回率等于“索引近似搜索”和“全表精确扫描”的交集占比  
  
```sql  
-- 例如下面计算的是: ef_search = 45 时, top-50 recall .  
do $$  
declare  
  v_indexscan int[];  
  v_seqscan int[];  
  v_recall float8;  
  v_topk int := 50;  -- top-50, 返回50条与查询向量 v_embedding 最相似的结果  
  v_embedding vector(32);  
begin  
  select embedding into v_embedding from vector_test where id=1234;  
  set local hnsw.ef_search = 45;  -- 检查当查询参数 hnsw.ef_search = 45 时, 返回 top-50 的 recall 的值是多少?  
  set local enable_seqscan=off;  
  set local enable_indexscan=on;  
  select array(select id from vector_test order by embedding <-> v_embedding limit v_topk) into v_indexscan;  
  set local enable_seqscan=on;  
  set local enable_indexscan=off;  
  select array(select id from vector_test order by embedding <-> v_embedding limit v_topk) into v_seqscan;  
  select count(*)/v_topk::numeric into v_recall from unnest(v_seqscan) as t1  
    join unnest(v_indexscan) as t2 on t1 = t2;  
  raise notice '返回 top-50, recall值为: % %%', 100*v_recall;  
end  
$$ language plpgsql;  
```  
  
2、观察搜索参数如何影响召回率  
  
```sql  
-- 加大搜索参数, 可提高召回率  
-- 例如下面计算的是: ef_search = 200 时, top-50 recall .  
-- 对比前面 hnsw.ef_search = 45 时的 top-50 recall .  
do $$  
declare  
  v_indexscan int[];  
  v_seqscan int[];  
  v_recall float8;  
  v_topk int := 50;  -- top-50, 返回50条与查询向量 v_embedding 最相似的结果  
  v_embedding vector(32) ;  
begin  
  select embedding into v_embedding from vector_test where id=1234;  
  set local hnsw.ef_search = 200;  -- 检查当查询参数 hnsw.ef_search = 200 时, 返回 top-50 的 recall 的值是多少?  
  set local enable_seqscan=off;  
  set local enable_indexscan=on;  
  select array(select id from vector_test order by embedding <-> v_embedding limit v_topk) into v_indexscan;  
  set local enable_seqscan=on;  
  set local enable_indexscan=off;  
  select array(select id from vector_test order by embedding <-> v_embedding limit v_topk) into v_seqscan;  
  select count(*)/v_topk::numeric into v_recall from unnest(v_seqscan) as t1  
    join unnest(v_indexscan) as t2 on t1 = t2;  
  raise notice '返回 top-50, recall值为: % %%', 100*v_recall;  
end  
$$ language plpgsql;  
```  
  
  
思考一下, 既然直接修改 ef_search 就可以提升recall, 为什么还要重建索引这么麻烦来修改 m 和 ef_construction ?  
  
  
3、观察索引参数如何影响召回率  
  
保持m不变, 加大ef_construction, 可提高召回率. 但会使创建索引的时间变长.  
  
```sql  
-- 请自行尝试  
set maintenance_work_mem ='3GB';  
set max_parallel_maintenance_workers =8;  
drop index if exists idx_vector_test_hnsw;  
create index idx_vector_test_hnsw on vector_test using hnsw (embedding vector_l2_ops) with (m=16, ef_construction=1000);  
  
  
-- 例如下面计算的是: ef_search = 45 时, top-50 recall .  
-- 对比前面 m=16, ef_construction=64 , hnsw.ef_search = 45 时的 top-50 recall .  
do $$  
declare  
  v_indexscan int[];  
  v_seqscan int[];  
  v_recall float8;  
  v_topk int := 50;  -- top-50, 返回50条与查询向量 v_embedding 最相似的结果  
  v_embedding vector(32) ;  
begin  
  select embedding into v_embedding from vector_test where id=1234;  
  set local hnsw.ef_search = 45;  -- 检查当查询参数 hnsw.ef_search = 45 时, 返回 top-50 的 recall 的值是多少?  
  set local enable_seqscan=off;  
  set local enable_indexscan=on;  
  select array(select id from vector_test order by embedding <-> v_embedding limit v_topk) into v_indexscan;  
  set local enable_seqscan=on;  
  set local enable_indexscan=off;  
  select array(select id from vector_test order by embedding <-> v_embedding limit v_topk) into v_seqscan;  
  select count(*)/v_topk::numeric into v_recall from unnest(v_seqscan) as t1  
    join unnest(v_indexscan) as t2 on t1 = t2;  
  raise notice '返回 top-50, recall值为: % %%', 100*v_recall;  
end  
$$ language plpgsql;  
```  
  
  
加大m, 可提高召回率. 但会使创建索引的时间变长.  
  
```sql  
-- 请自行尝试  
  
-- 例如下面计算的是: ef_search = 45 时, top-50 recall .  
-- 对比前面 m=16, ef_construction=64 , hnsw.ef_search = 45 时的 top-50 recall .  
set maintenance_work_mem ='3GB';  
set max_parallel_maintenance_workers =8;  
drop index if exists idx_vector_test_hnsw;  
create index idx_vector_test_hnsw on vector_test using hnsw (embedding vector_l2_ops) with (m=32, ef_construction=64);  
  
do $$  
declare  
  v_indexscan int[];  
  v_seqscan int[];  
  v_recall float8;  
  v_topk int := 50;  -- top-50, 返回50条与查询向量 v_embedding 最相似的结果  
  v_embedding vector(32) ;  
begin  
  select embedding into v_embedding from vector_test where id=1234;  
  set local hnsw.ef_search = 45;  -- 检查当查询参数 hnsw.ef_search = 45 时, 返回 top-50 的 recall 的值是多少?  
  set local enable_seqscan=off;  
  set local enable_indexscan=on;  
  select array(select id from vector_test order by embedding <-> v_embedding limit v_topk) into v_indexscan;  
  set local enable_seqscan=on;  
  set local enable_indexscan=off;  
  select array(select id from vector_test order by embedding <-> v_embedding limit v_topk) into v_seqscan;  
  select count(*)/v_topk::numeric into v_recall from unnest(v_seqscan) as t1  
    join unnest(v_indexscan) as t2 on t1 = t2;  
  raise notice '返回 top-50, recall值为: % %%', 100*v_recall;  
end  
$$ language plpgsql;  
```  
  
### 4、观察同等条件下, 索引带来的性能提升  
对比在满足一定 recall 前提下, 有索引和无索引的查询性能  
  
记录全表扫描查询性能  
  
```sql  
set max_parallel_workers_per_gather = 0;  
set jit=off;  
set enable_seqscan=on;  
set enable_bitmapscan=off;  
set enable_indexscan=off;  
set hnsw.ef_search = 20;  
  
-- 查看执行计划, 是不是使用了 seq scan 全表扫描  
explain select id, category, price, label, ts, info,  
  embedding <-> (select embedding from vector_test where id=1234) as distance  
from vector_test  
  order by embedding <-> (select embedding from vector_test where id=1234) limit 10;  
  
-- 查询看看结果和性能  
select id, category, price, label, ts, info,  
  embedding <-> (select embedding from vector_test where id=1234) as distance  
from vector_test  
  order by embedding <-> (select embedding from vector_test where id=1234) limit 10;  
```  
  
记录 hnsw 索引扫描查询性能  
```sql  
set max_parallel_workers_per_gather = 0;  
set jit=off;  
set enable_seqscan=off;  
set enable_bitmapscan=off;  
set enable_indexscan=on;  
  
-- 查看执行计划, 是不是使用了 index scan 索引扫描  
explain select id, category, price, label, ts, info,  
  embedding <-> (select embedding from vector_test where id=1234) as distance  
from vector_test  
  order by embedding <-> (select embedding from vector_test where id=1234) limit 10;  
  
-- 查询看看结果和性能  
select id, category, price, label, ts, info,  
  embedding <-> (select embedding from vector_test where id=1234) as distance  
from vector_test  
  order by embedding <-> (select embedding from vector_test where id=1234) limit 10;  
```  
  
### 5、对比hnsw和ivfflat索引  
对比hnsw和ivfflat索引的创建耗时、同等召回率下的查询性能  
  
1、创建 ivfflat 索引  
```sql  
-- 删除hnsw索引  
drop index if exists idx_vector_test_hnsw;  
-- 创建ivfflat索引. 思考 lists 和 ivfflat.probes 如何设置最佳?  
set maintenance_work_mem ='3GB';  
set max_parallel_maintenance_workers =8;  
create index idx_vector_test_ivfflat on vector_test using ivfflat(embedding vector_l2_ops) with (lists=1000);  
  
-- 可以在另一个 psql 页面观察创建ivfflat索引的完成进度  
SELECT phase, round(100.0 * tuples_done / nullif(tuples_total, 0), 1) AS "%" FROM pg_stat_progress_create_index;  
```  
  
2、ivfflat 索引 top-50 recall  
```  
-- 注意调整 ivfflat.probes 参数, 观察对召回的影响  
  
do $$  
declare  
  v_indexscan int[];  
  v_seqscan int[];  
  v_recall float8;  
  v_topk int := 50;  -- top-50, 返回50条与查询向量 v_embedding 最相似的结果  
  v_embedding vector(32) ;  
begin  
  select embedding into v_embedding from vector_test where id=1234;  
  set local ivfflat.probes = 1;  -- 检查当查询参数 ivfflat.probes = 1 时, 返回 top-50 的 recall 的值是多少?  
  set local enable_seqscan=off;  
  set local enable_indexscan=on;  
  select array(select id from vector_test order by embedding <-> v_embedding limit v_topk) into v_indexscan;  
  set local enable_seqscan=on;  
  set local enable_indexscan=off;  
  select array(select id from vector_test order by embedding <-> v_embedding limit v_topk) into v_seqscan;  
  select count(*)/v_topk::numeric into v_recall from unnest(v_seqscan) as t1  
    join unnest(v_indexscan) as t2 on t1 = t2;  
  raise notice '返回 top-50, recall值为: % %%', 100*v_recall;  
end  
$$ language plpgsql;  
```  
  
3、ivfflat 索引查询性能  
```  
set jit=off;  
set enable_seqscan=off;  
set enable_bitmapscan=off;  
set enable_indexscan=on;  
set ivfflat.probes = 5;  
  
-- 查看执行计划, 是不是使用了 index scan 索引扫描  
explain select id, category, price, label, ts, info,  
  embedding <-> (select embedding from vector_test where id=1234) as distance  
from vector_test  
  order by embedding <-> (select embedding from vector_test where id=1234) limit 10;  
  
-- 查询看看结果和性能  
select id, category, price, label, ts, info,  
  embedding <-> (select embedding from vector_test where id=1234) as distance  
from vector_test  
  order by embedding <-> (select embedding from vector_test where id=1234) limit 10;  
```  
  
### 6、量化索引实验  
  
  
1、了解量化  
```sql  
select binary_quantize('[1,10,100,1000,-1,0,-100,-234]'::vector);  
  
select id, binary_quantize(embedding), embedding from vector_test where center_id=1 limit 10;  
```  
  
2、创建量化索引  
```sql  
-- 删除旧索引  
drop index if exists idx_vector_test_ivfflat;  
-- 创建量化表达式索引  
set maintenance_work_mem ='3GB';  
set max_parallel_maintenance_workers =8;  
create index idx_vector_test_hnsw on vector_test using hnsw ((binary_quantize(embedding)::bit(32)) bit_hamming_ops) with (m=16, ef_construction=64);  
```  
  
3、使用量化索引  
```sql  
-- 注意 使用 <~> 表示 hamming 距离  
set hnsw.ef_search = 20;  
-- 查看执行计划, 是不是使用了 index scan 索引扫描  
explain select id, category, price, label, ts, info,  
  binary_quantize(embedding)::bit(32) <~> (select binary_quantize(embedding)::bit(32) from vector_test where id=1234) as distance  
from vector_test  
  order by binary_quantize(embedding)::bit(32) <~> (select binary_quantize(embedding)::bit(32) from vector_test where id=1234) limit 10;  
  
-- 查询看看结果和性能  
select id, category, price, label, ts, info,  
  binary_quantize(embedding)::bit(32) <~> (select binary_quantize(embedding)::bit(32) from vector_test where id=1234) as distance  
from vector_test  
  order by binary_quantize(embedding)::bit(32) <~> (select binary_quantize(embedding)::bit(32) from vector_test where id=1234) limit 10;  
```  
  
4、量化索引召回率测试  
```sql  
-- 采用 hamming 距离  
-- 计算 ef_search = 45 时, top-50 recall .  
do $$  
declare  
  v_indexscan int[];  
  v_seqscan int[];  
  v_recall float8;  
  v_topk int := 50;  -- top-50, 返回50条与查询向量 v_embedding 最相似的结果  
  v_embedding vector(32);  
begin  
  select embedding into v_embedding from vector_test where id=1234;  
  set local hnsw.ef_search = 45;  -- 检查当查询参数 hnsw.ef_search = 45 时, 返回 top-50 的 recall 的值是多少?  
  set local enable_seqscan=off;  
  set local enable_indexscan=on;  
  select array(select id from vector_test order by binary_quantize(embedding)::bit(32) <~> binary_quantize(v_embedding)::bit(32) limit v_topk) into v_indexscan;  
  set local enable_seqscan=on;  
  set local enable_indexscan=off;  
  select array(select id from vector_test order by embedding <-> v_embedding limit v_topk) into v_seqscan;  
  select count(*)/v_topk::numeric into v_recall from unnest(v_seqscan) as t1  
    join unnest(v_indexscan) as t2 on t1 = t2;  
  raise notice '返回 top-50, recall值为: % %%', 100*v_recall;  
end  
$$ language plpgsql;  
```  
  
5、使用量化索引和二次精排  
```sql  
-- 查看执行计划, 是不是使用了 index scan 索引扫描  
explain  
with a as (  
select id, category, price, label, ts, info, embedding,  
  binary_quantize(embedding)::bit(32) <~> (select binary_quantize(embedding)::bit(32) from vector_test where id=1234) as distance  
from vector_test  
  order by binary_quantize(embedding)::bit(32) <~> (select binary_quantize(embedding)::bit(32) from vector_test where id=1234) limit 500  
)  
select id, category, price, label, ts, info from a order by embedding <-> (select embedding from vector_test where id=1234) limit 10;  
  
  
-- 查询看看结果和性能  
with a as (  
select id, category, price, label, ts, info, embedding,  
  binary_quantize(embedding)::bit(32) <~> (select binary_quantize(embedding)::bit(32) from vector_test where id=1234) as distance  
from vector_test  
  order by binary_quantize(embedding)::bit(32) <~> (select binary_quantize(embedding)::bit(32) from vector_test where id=1234) limit 500  
)  
select id, category, price, label, ts, info from a order by embedding <-> (select embedding from vector_test where id=1234) limit 10;  
```  
  
6、采用二次精排, 提高 recall  
  
```sql  
-- 采用 hamming 距离  
-- 采用二次精排  
-- 计算 ef_search = 500 , 量化召回 500 条后, 精排序 top-50 recall .  
do $$  
declare  
  v_indexscan int[];  
  v_seqscan int[];  
  v_recall float8;  
  v_topk int := 50;  -- top-50, 返回50条与查询向量 v_embedding 最相似的结果  
  v_embedding vector(32);  
begin  
  select embedding into v_embedding from vector_test where id=1234;  
  set local hnsw.ef_search = 500;  -- 检查当查询参数 hnsw.ef_search = 500 时, 返回 top-50 的 recall 的值是多少?  
  set local enable_seqscan=off;  
  set local enable_indexscan=on;  
  select array( with a as (select id,embedding from vector_test order by binary_quantize(embedding)::bit(32) <~> binary_quantize(v_embedding)::bit(32) limit 500) select id from a order by embedding <-> v_embedding limit v_topk) into v_indexscan;  
  set local enable_seqscan=on;  
  set local enable_indexscan=off;  
  select array(select id from vector_test order by embedding <-> v_embedding limit v_topk) into v_seqscan;  
  select count(*)/v_topk::numeric into v_recall from unnest(v_seqscan) as t1  
    join unnest(v_indexscan) as t2 on t1 = t2;  
  raise notice '返回 top-50, recall值为: % %%', 100*v_recall;  
end  
$$ language plpgsql;  
```  
  
### 7、体验目前综合能力最强向量索引 vectorchord  
vectorchord 做到了索引构建速度快、召回率高和查询性能好的兼得.  
  
对比 vchordrq 和 hnsw 索引的创建耗时、同等召回率下的查询性能  
  
  
1、配置参数  
  
```sql  
\! echo "shared_preload_libraries='vchord,pg_tokenizer,vchord_bm25'" >> /var/lib/postgresql/18/docker/postgresql.auto.conf  
```  
  
2、重启 docker 容器  
  
```bash  
-- 先退出到 powershell / cmd / shell 命令行  
-- 重启后进入 psql 命令行  
docker stop pg  
docker start pg  
docker exec -ti pg bash  
psql  
```  
  
3、创建 vchord 向量插件  
```sql  
create extension if not exists vchord;  
```  
  
4、构建 vchordrq 向量索引  
```sql  
-- 删除 hnsw 量化向量索引  
drop index if exists idx_vector_test_hnsw;  
  
-- 创建 vchordrq 索引  
set maintenance_work_mem ='3GB';  
set max_parallel_maintenance_workers =8;  
create index idx_vector_test_vchord on vector_test using vchordrq(embedding vector_l2_ops) with (  
options = $$  
residual_quantization = true  
[build.internal]  
lists = [1000]  
build_threads = 8  
spherical_centroids = true  
kmeans_algorithm.hierarchical = {}  
[build]  
pin=2  
$$  
);  
```  
  
  
检查召回率 top-50 recall  
```sql  
do $$  
declare  
  v_indexscan int[];  
  v_seqscan int[];  
  v_recall float8;  
  v_topk int := 50;  -- top-50, 返回50条与查询向量 v_embedding 最相似的结果  
  v_embedding vector(32) ;  
begin  
  select embedding into v_embedding from vector_test where id=1234;  
  set local vchordrq.probes = 1;  -- 检查当查询参数 vchordrq.probes = 1 时, 返回 top-50 的 recall 的值是多少?  
  set local enable_seqscan=off;  
  set local enable_indexscan=on;  
  select array(select id from vector_test order by embedding <-> v_embedding limit v_topk) into v_indexscan;  
  set local enable_seqscan=on;  
  set local enable_indexscan=off;  
  select array(select id from vector_test order by embedding <-> v_embedding limit v_topk) into v_seqscan;  
  select count(*)/v_topk::numeric into v_recall from unnest(v_seqscan) as t1  
    join unnest(v_indexscan) as t2 on t1 = t2;  
  raise notice '返回 top-50, recall值为: % %%', 100*v_recall;  
end  
$$ language plpgsql;  
```  
  
观察 vchordrq 索引查询性能  
```sql  
set jit=off;  
set enable_seqscan=off;  
set enable_bitmapscan=off;  
set enable_indexscan=on;  
set vchordrq.probes = 1;  
  
-- 查看执行计划, 是不是使用了 index scan 索引扫描  
explain select id, category, price, label, ts, info,  
  embedding <-> (select embedding from vector_test where id=1234) as distance  
from vector_test  
  order by embedding <-> (select embedding from vector_test where id=1234) limit 10;  
  
-- 查询看看结果和性能  
select id, category, price, label, ts, info,  
  embedding <-> (select embedding from vector_test where id=1234) as distance  
from vector_test  
  order by embedding <-> (select embedding from vector_test where id=1234) limit 10;  
```  
  
  
## 全文检索实验  
  
1、查询数据样本  
  
```sql  
select tsvec from vector_test limit 10;  
```  
  
2、从样本提取几个值  
  
```  
'1264451' '138541'  
```  
  
3、包含任意关键词 或 所有关键词的查询, 全表扫描  
  
观察全表扫描的执行计划和查询性能  
```sql  
-- 包含以下任意关键词  
explain select id, tsvec from vector_test where tsvec @@ to_tsquery('1264451 | 138541');  
select id, tsvec from vector_test where tsvec @@ to_tsquery('1264451 | 138541');  
  
-- 包含以下所有关键词  
explain select id, tsvec from vector_test where tsvec @@ to_tsquery('1264451 & 138541');  
select id, tsvec from vector_test where tsvec @@ to_tsquery('1264451 & 138541');  
```  
  
4、包含任意关键词 或 所有关键词的查询, 索引扫描  
  
创建 gin 倒排索引  
  
```sql  
set maintenance_work_mem ='3GB';  
set max_parallel_maintenance_workers =8;  
create index idx_vector_test_tsvec on vector_test using gin (tsvec);  
```  
  
观察索引扫描的执行计划和查询性能  
  
```sql  
-- 包含以下任意关键词  
explain select id, tsvec from vector_test where tsvec @@ to_tsquery('1264451 | 138541');  
select id, tsvec from vector_test where tsvec @@ to_tsquery('1264451 | 138541');  
  
-- 包含以下所有关键词  
explain select id, tsvec from vector_test where tsvec @@ to_tsquery('1264451 & 138541');  
select id, tsvec from vector_test where tsvec @@ to_tsquery('1264451 & 138541');  
```  
  
对比全表扫描和索引扫描的耗时  
  
```sql  
-- 全表扫描  
set enable_seqscan=on;  
set max_parallel_workers_per_gather =0;  
set enable_bitmapscan=off;  
  
-- 包含以下任意关键词  
explain select id from vector_test where tsvec @@ to_tsquery('1264451 | 138541');  
select id from vector_test where tsvec @@ to_tsquery('1264451 | 138541');  
  
-- 包含以下所有关键词  
explain select id from vector_test where tsvec @@ to_tsquery('1264451 & 138541');  
select id from vector_test where tsvec @@ to_tsquery('1264451 & 138541');  
  
  
-- 索引扫描  
set enable_seqscan=off;  
set max_parallel_workers_per_gather =0;  
set enable_bitmapscan=on;  
-- 包含以下任意关键词  
explain select id from vector_test where tsvec @@ to_tsquery('1264451 | 138541');  
select id from vector_test where tsvec @@ to_tsquery('1264451 | 138541');  
  
-- 包含以下所有关键词  
explain select id from vector_test where tsvec @@ to_tsquery('1264451 & 138541');  
select id from vector_test where tsvec @@ to_tsquery('1264451 & 138541');  
```  
  
## 混合搜索实验  
  
混合搜索SQL  
```sql  
set vchordrq.probes=20;  
set enable_seqscan=off;  
set enable_bitmapscan=off;  
set enable_indexscan=on;  
  
select id from vector_test where category=1 and price<5 order by embedding <-> (select embedding from vector_test where id=1234) limit 10;  
```  
  
### 1、多索引, 数据库自动根据代价选择某个条件的索引  
  
观察当前的SQL用了什么索引?  
```sql  
-- 创建标量索引  
set maintenance_work_mem ='3GB';  
set max_parallel_maintenance_workers =8;  
create index idx_vector_test_category_price on vector_test (category, price);  
  
set vchordrq.probes=20;  
set enable_seqscan=off;  
set enable_bitmapscan=off;  
set enable_indexscan=on;  
explain (analyze,verbose,timing,costs,buffers) select id from vector_test where category=1 and price<5 order by embedding <-> (select embedding from vector_test where id=1234) limit 10;  
select id from vector_test where category=1 and price<5 order by embedding <-> (select embedding from vector_test where id=1234) limit 10;  
```  
  
如果把`price<5`条件去掉呢?  用了哪个索引?  
  
```sql  
set vchordrq.probes=20;  
set enable_seqscan=off;  
set enable_bitmapscan=off;  
set enable_indexscan=on;  
explain (analyze,verbose,timing,costs,buffers) select id from vector_test where category=1 order by embedding <-> (select embedding from vector_test where id=1234) limit 10;  
select id from vector_test where category=1 order by embedding <-> (select embedding from vector_test where id=1234) limit 10;  
```  
  
  
### 2、对比多索引和分区索引的性能区别  
什么情况下, 多索引不能解决问题?  
  
使用任何单一的索引时, 命中满足其他字段条件的记录都很少, 需要扫描很多的索引页.  
  
使用单一非向量索引时, 返回的结果集太大, 需要进行向量排序的记录数过多.  
  
多索引性能不佳的原因: 选择单一索引要更多的cpu运算和IO, 高并发时qps不佳.  
  
1、使用hnsw索引进行对照测试  
```sql  
-- 删除 hnsw 量化向量索引  
drop index if exists idx_vector_test_vchord;  
  
-- 创建 hnsw 索引  
set maintenance_work_mem ='3GB';  
set max_parallel_maintenance_workers =8;  
create index idx_vector_test_hnsw on vector_test using hnsw(embedding vector_l2_ops) with (m=16, ef_construction=64);  
```  
  
查看执行计划, 确认使用了向量索引?  
```  
explain (analyze,verbose,timing,costs,buffers) select id from vector_test where category=1 order by embedding <-> (select embedding from vector_test where id=1234) limit 10;  
```  
  
收集一份 qps 数据, 表示 选择单一索引要更多的cpu运算和IO, 高并发时qps不佳.  
  
```  
\! echo "  
set vchordrq.probes=20;  
set enable_seqscan=off;  
set enable_bitmapscan=off;  
set enable_indexscan=on;  
select id from vector_test where category=1 order by embedding <-> (select embedding from vector_test where id=1234) limit 10;  
" > ~/2.sql  
  
\! pgbench -M prepared -n -r -P 1 -f ~/2.sql -c 10 -j 10 -T 120  
```  
  
2、使用 partial index 模拟“支持分区的向量索引”, 提升混合搜索性能  
  
```sql  
-- 删除 hnsw 量化向量索引  
drop index if exists idx_vector_test_hnsw;  
  
-- 创建 hnsw 索引  
set maintenance_work_mem ='3GB';  
set max_parallel_maintenance_workers =8;  
create index idx_vector_test_hnsw on vector_test using hnsw(embedding vector_l2_ops) with (m=16, ef_construction=64)  
where category=1;   -- 这里加了一个条件, 创建partial index, 与SQL的where条件匹配  
```  
  
查看执行计划, 确认使用了向量索引?  
```  
explain (analyze,verbose,timing,costs,buffers) select id from vector_test where category=1 order by embedding <-> (select embedding from vector_test where id=1234) limit 10;  
```  
  
观察 “支持分区的向量索引” 带来的性能提升  
```  
\! pgbench -M prepared -n -r -P 1 -f ~/2.sql -c 10 -j 10 -T 120  
```  
  
### 3、向量+标签混合搜索  
向量+标签混合搜索SQL  
```sql  
select id from vector_test where label && array[1]::smallint[] order by embedding <-> (select embedding from vector_test where id=1234) limit 10;  
```  
  
1、仅使用向量索引的性能  
  
```sql  
-- 删除 hnsw 量化向量索引  
drop index if exists idx_vector_test_hnsw;  
  
-- 创建 hnsw 索引  
set maintenance_work_mem ='3GB';  
set max_parallel_maintenance_workers =8;  
create index idx_vector_test_hnsw on vector_test using hnsw(embedding vector_l2_ops) with (m=16, ef_construction=64);  
```  
  
开始压测  
```  
\! echo "  
set hnsw.ef_search=20;  
select id from vector_test where label && array[1]::smallint[] order by embedding <-> (select embedding from vector_test where id=1234) limit 10;  
" > ~/3.sql  
```  
  
记录性能  
```  
\! pgbench -M prepared -n -r -P 1 -f ~/3.sql -c 10 -j 10 -T 120  
```  
  
2、使用向量+标签混合索引的性能.  
  
创建vectorscale 插件, 创建带标签的diskann图索引.  
  
相当于两张逻辑图, 图中支持label或公共入口点, 带label时可快速进行裁剪.  
  
```sql  
-- 创建vectorscale diskann 向量索引插件  
create extension if not exists vectorscale ;  
  
-- 删除 hnsw 量化向量索引  
drop index if exists idx_vector_test_hnsw ;  
  
-- 创建 diskann 索引  
set maintenance_work_mem ='3GB';  
set max_parallel_maintenance_workers =8;  
create index idx_vector_test_diskann on vector_test using diskann(embedding vector_l2_ops, label) with (  
num_neighbors=20,  -- 每个节点的最大邻居数  
search_list_size=40,  -- 构图时的最大候选列表大小  
max_alpha=1.2,  -- 图连接的紧密程度, 设大有可能引入较远地方的点, 使得图的搜索性能更好. 但也不能太大可能导致性能变差, 类似lora, 优化过度了.  
storage_layout='memory_optimized',  -- 使用量化  
num_bits_per_dimension = 8  -- 每个维度量化为几个bit ?  
);  
  
-- 可以在另一个 psql 页面观察创建hnsw索引的完成进度  
SELECT phase, round(100.0 * blocks_done / nullif(blocks_total, 0), 1) AS "%" FROM pg_stat_progress_create_index;  
```  
  
检查是否使用了diskann索引  
```sql  
set diskann.query_search_list_size = 1000;  
set diskann.query_rescore = 500;  -- 如果索引使用了量化技术, 建议回表进行重排序 , 获得更好的 recall  
explain (analyze,verbose,timing,costs,buffers) select id from vector_test where label && array[1]::smallint[] order by embedding <-> (select embedding from vector_test where id=1234) limit 10;  
```  
  
检查召回率  
```sql  
do $$  
declare  
  v_indexscan int[];  
  v_seqscan int[];  
  v_recall float8;  
  v_topk int := 50;  -- top-50, 返回50条与查询向量 v_embedding 最相似的结果  
  v_embedding vector(32) ;  
begin  
  select embedding into v_embedding from vector_test where id=1234;  
  set local diskann.query_search_list_size = 1000;  -- 检查当查询参数 diskann.query_search_list_size = 1000 时, 返回 top-50 的 recall 的值是多少?  
  set local diskann.query_rescore = 500;    -- 前500条索引扫描的结果回表使用 embedding <-> embedding 精排
  set local enable_seqscan=off;  
  set local enable_indexscan=on;  
  select array(select id from vector_test where label && array[1]::smallint[] order by embedding <-> (select embedding from vector_test where id=1234) limit v_topk) into v_indexscan;  
  set local enable_seqscan=on;  
  set local enable_indexscan=off;  
  select array(select id from vector_test where label && array[1]::smallint[] order by embedding <-> (select embedding from vector_test where id=1234) limit v_topk) into v_seqscan;  
  select count(*)/v_topk::numeric into v_recall from unnest(v_seqscan) as t1  
    join unnest(v_indexscan) as t2 on t1 = t2;  
  raise notice '返回 top-50, recall值为: % %%', 100*v_recall;  
end  
$$ language plpgsql;  
```  
  
保证召回率低情况下, 对比 diskann 与没有混合索引时的性能差别  
  
```  
\! echo "  
set diskann.query_search_list_size =1000;  
set diskann.query_rescore = 500;  
select id from vector_test where label && array[1]::smallint[] order by embedding <-> (select embedding from vector_test where id=1234) limit 10;  
" > ~/4.sql  
```  
  
记录性能  
```  
\! pgbench -M prepared -n -r -P 1 -f ~/4.sql -c 10 -j 10 -T 120  
```  
  
### 4、王炸: RRF 例子  
改写SQL, 把各种条件单独进行查询, 然后用RRF算法融合排序, 使得每个索引都能用上, 最高效.  

0、将向量索引恢复到最常用的 hnsw 索引. 

```sql
drop index if exists idx_vector_test_diskann;

set maintenance_work_mem ='3GB';  
set max_parallel_maintenance_workers =8;  
create index idx_vector_test_hnsw on vector_test using hnsw(embedding vector_l2_ops) with (m=16, ef_construction=64);
```

1、分解SQL 

标量条件 `category = 1 and price < 100`

全文检索条件 `tsvec @@ to_tsquery('1264451 | 138541')`

向量条件 `order by embedding <-> (select embedding from vector_test where id=1234)`
  
2、RRF SQL  

```sql
-- 使用RRF算法融合 向量查询 和标量查询的2个结果. 每种排序取出前 20条, 最终取融合后的前10条.      

select embedding from vector_test where id=1234;    

WITH vector_results AS (  
    SELECT id,   
           ROW_NUMBER() OVER (ORDER BY embedding <-> '[0.5668827,-0.2442255,1,0.7500094,-0.31195357,0.030093279,-0.12537633,0.68836486,-0.018421616,-0.37933782,0.9605927,-0.3399773,-0.8192224,-0.6839713,-0.6513173,0.42495644,-0.3043482,-0.020086138,0.6450944,1,0.50533813,0.61879873,0.33264527,0.1594014,1,0.5975187,0.79589015,-0.88029814,-0.65116,-0.38115847,-0.64158386,-0.0052799657]'::vector(32)) as vector_rank  
    FROM vector_test  
    ORDER BY embedding <-> '[0.5668827,-0.2442255,1,0.7500094,-0.31195357,0.030093279,-0.12537633,0.68836486,-0.018421616,-0.37933782,0.9605927,-0.3399773,-0.8192224,-0.6839713,-0.6513173,0.42495644,-0.3043482,-0.020086138,0.6450944,1,0.50533813,0.61879873,0.33264527,0.1594014,1,0.5975187,0.79589015,-0.88029814,-0.65116,-0.38115847,-0.64158386,-0.0052799657]'::vector(32) 
    LIMIT 20  
),  
scale_results AS (  
    SELECT id, 
           ROW_NUMBER() OVER (ORDER BY price) as scale_rank  
    FROM vector_test
    WHERE category = 5 AND price < 100  
    ORDER BY price 
    LIMIT 20  
),  
tsvec_results as (
    SELECT id, 
           ROW_NUMBER() OVER (ORDER BY ts_rank_cd(tsvec, to_tsquery('1264451 | 138541')) desc) as tsvec_rank  
    FROM vector_test
    WHERE tsvec @@ to_tsquery('1264451 | 138541')
    ORDER BY tsvec_rank 
    LIMIT 20  
),
rrf_scores AS (  
    SELECT   
        COALESCE(v.id, t.id) as id,  
        COALESCE(v.vector_rank, 100) as vector_rank,  
        COALESCE(t.scale_rank, 100) as scale_rank,  
        COALESCE(ts.tsvec_rank, 100) as tsvec_rank,  
        -- RRF算法：k=60，向量权重 0.5 , scale 权重0.25 , 全文检索 权重0.25
        (0.5 * 1.0/(60 + COALESCE(v.vector_rank, 100)) +   
         0.25 * 1.0/(60 + COALESCE(t.scale_rank, 100)) +
         0.25 * 1.0/(60 + COALESCE(ts.tsvec_rank, 100))) as rrf_score  
    FROM vector_results v  
    FULL OUTER JOIN scale_results t ON v.id = t.id 
    full outer join tsvec_results ts on v.id = ts.id 
)  
SELECT p.id, p.category, p.price, r.rrf_score,  
       r.vector_rank, r.scale_rank, r.tsvec_rank 
FROM rrf_scores r  
JOIN vector_test p ON r.id = p.id  
ORDER BY r.rrf_score DESC  
LIMIT 10;
```

3、观察 RRF SQL 执行计划, 确保每个条件都用了最佳索引  
  
4、观察单条 RRF 性能  

5、压力测试 RRF 性能  
  
6、回顾混合搜索的几种技术  

参考 [《混合搜索的三大技术流派, 差异在哪? 哪个更有前途?》](../202510/20251027_09.md)  
  
## PGQ 实验  
  
揭示金融犯罪  
  
社交网络  
  
航空数据  
  
## 课程竞赛  
  
参考  
  
[《大学生数据库实践课 : 课后大作业》](../202512/20251217_02.md)  竞赛章节  
  
  
#### [PolarDB 学习图谱](https://www.aliyun.com/database/openpolardb/activity "8642f60e04ed0c814bf9cb9677976bd4")
  
  
#### [PostgreSQL 解决方案集合](../201706/20170601_02.md "40cff096e9ed7122c512b35d8561d9c8")
  
  
#### [德哥 / digoal's Github - 公益是一辈子的事.](https://github.com/digoal/blog/blob/master/README.md "22709685feb7cab07d30f30387f0a9ae")
  
  
#### [About 德哥](https://github.com/digoal/blog/blob/master/me/readme.md "a37735981e7704886ffd590565582dd0")
  
  
![digoal's wechat](../pic/digoal_weixin.jpg "f7ad92eeba24523fd47a6e1a0e691b59")
  
