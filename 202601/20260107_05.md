## PostgreSQL 19 preview - OID升级到64位  
          
### 作者          
digoal          
          
### 日期          
2026-01-07          
          
### 标签          
PostgreSQL , OID , 64bit            
          
----          
          
## 背景      
https://git.postgresql.org/gitweb/?p=postgresql.git;a=commit;h=b139bd3b6ef000ab5d00dd47128e366a726da5f9      
  
这个补丁是为 PostgreSQL 引入了一个 **“加强版”的 64 位身份证** 。  
  
在 PostgreSQL 内部，`OID`（对象标识符）就像是每行数据、每个表或函数的“身份证号”。但传统的 `OID` 是 32 位的，最多只能支持约 42 亿个值。随着大数据时代的到来，这个数字已经不够用了。  
  
### 1. 为什么要搞个 `oid8`？  
  
* **突破 40 亿上限**：传统的 32 位 `OID` 在超大规模数据库中容易“溢出”（不够发了）。`oid8` 是 **64 位** 的，能提供的数字范围极其庞大，大到几乎永远用不完。  
* **专门给“大文件”准备的**：注释里特别提到了 **TOAST**（PostgreSQL 处理超大字段的机制）。未来，当你的单条数据非常大时，就需要 64 位的 ID 来管理这些切片。  
* **代码更好维护**：如果直接用现成的 `int8`（长整型），程序员在搜索代码时很难分清哪个是“普通数字”，哪个是“对象 ID”。有了 `oid8`，搜一下就能精准定位到所有使用 64 位 ID 的地方。  
  
### 2. 这个补丁做了什么？  
  
这不是一个简单的改名，而是建立了一套完整的“配套设施”：  
  
* **运算支持**：给 `oid8` 配备了加减乘除、比较大小（btree/hash 索引）的功能。  
* **自动转换**：让你能在 `oid8`、普通整数和旧的 `OID` 之间互相转换（Cast）。  
* **内核改动**：在 C 语言层面定义了 `Oid8` 结构体，并更新了数据库的系统表版本（Catalog version）。  
  
  
### 3. 为什么不直接改现有的 OID？  
  
这是一个非常老练的架构决策。如果直接把所有 `OID` 从 32 位升级到 64 位，会导致：  
  
* **空间浪费**：很多小表根本不需要 64 位，直接升级会多占一倍空间。  
* **不兼容**：会破坏大量现有的插件和核心代码。  
* **循序渐进**：先引入 `oid8`，让需要 64 位的地方（比如 TOAST）先用起来，其他地方保持原样。  
  
### 总结  
  
这就是在给 PostgreSQL 的底层引擎**加固地基**。  
  
这就好比一个城市原来只有 7 位数的电话号码（32位），随着人口增加（数据量变大），号码不够用了。政府没有强制所有人一夜之间换号，而是先推出了 11 位的新号段（`oid8`），并率先在大型企业和核心部门（TOAST）试运行。  
  
**这通常意味着 PostgreSQL 正在为支持“超大规模数据处理”做深层的架构铺垫。你是在做 PB 级数据的存储规划，还是在研究 PG 18（或更高版本）的新特性？**  
  
