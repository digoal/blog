## Qwen coder AI 编程终极技巧  
                  
### 作者                  
digoal                  
                  
### 日期                  
2026-01-14                 
                  
### 标签                  
pgvector , PostgreSQL , 向量插件 , tinyintvec , Qwen Coder , Deepwiki , 开发者手册 , mcp server , mcp client , mcp tools                   
                  
----                  
                  
## 背景    
**用AI编程, 早上起来发现一堆屎山代码, 怎么办?**   
  
举个例子, 我在用 Qwen Coder 给 pgvector 增加一个 8bit 的向量类型, AI 写的代码一堆 bug , 例如    
- 会导致数据库崩溃  
- 索引返回的结果和全表扫描的结果不一致  
- 回归测试的SQL不严谨  
- 遇到回归测试中符合预期的 ERROR 时, 反复尝试修复, 陷入死循环  
- 缺少 support 函数, 纠错陷入死胡同  
  
这些问题可能是 AI 缺乏对pgvector 项目整体的理解导致, 用 Deepwiki 即可解决.   
  
## AI 编程终极技巧: 给它一本开发者参考手册(deepwiki)   
  
假设你已经知道[《如何使用 Qwen coder》](../202601/20260111_01.md)    
  
我的目标是用 qwen coder 给 pgvector 增加一个 8bit 的向量类型.  
  
1、克隆代码  
```  
git clone -b tinyint_vector https://github.com/digoal/pgvector   
git clone -b tinyint https://github.com/pgvector/pgvector pgvector_tinyint   
```  
  
2、给qwen coder添加deepwiki工具  
```  
# qwen mcp add --scope user --transport http deepwiki https://mcp.deepwiki.com/mcp  
MCP server "deepwiki" added to user settings. (http)  
```  
  
3、测试一下deepwiki工具是否正常  
```  
# qwen  
  
██╗       ██████╗ ██╗    ██╗███████╗███╗   ██╗  
╚██╗     ██╔═══██╗██║    ██║██╔════╝████╗  ██║  
 ╚██╗    ██║   ██║██║ █╗ ██║█████╗  ██╔██╗ ██║  
 ██╔╝    ██║▄▄ ██║██║███╗██║██╔══╝  ██║╚██╗██║  
██╔╝     ╚██████╔╝╚███╔███╔╝███████╗██║ ╚████║  
╚═╝       ╚══▀▀═╝  ╚══╝╚══╝ ╚══════╝╚═╝  ╚═══╝  
  
Tips for getting started:  
1. Ask questions, edit files, or run commands.  
2. Be specific for the best results.  
3. /help for more information.  
  
> /mcp list  
  
Configured MCP servers:  
  
🟢 deepwiki - Ready (3 tools)  
  Tools:  
  - ask_question  
  - read_wiki_contents  
  - read_wiki_structure  
  
> 请使用 deepwiki mcp 工具，帮我查一下 `karpathy/minGPT` 这个项目的 README 和核心逻辑说明，并总结一下它的训练流程。  
  
如果它开始正常调用 deepwiki mcp 工具, 说明正常.    
```  
  
下面就是我的一堆提示词了  
  
````  
> 我正在使用 `pgvector/pgvector` 开发, deepwiki 有该项目的开发文档, 请先调用 deepwiki mcp 工具来了解它, 也可以用 deepwiki 来按需生成代码, 检查代码.   
同时参考 @pgvector_tinyint/src/tinyint.c @pgvector_tinyint/src/tinyint.h @pgvector/src/halfvec.c @pgvector/src/halfvec.h @pgvector/src/halfutils.c @pgvector/src/halfutils.h @pgvector/sql/vector.sql   
在 @pgvector/ 代码库的 tinyint_vector 分支中实现一个 tinyintvec 类型.   
要求如下:   
使用 8 bit 存储向量的每个维度值, 取值区间 -128 到 127 ;   
实现 hnsw 和 ivfflat 索引, 支持 tinyintvec_l2_ops, tinyintvec_l1_ops, tinyintvec_ip_ops, tinyintvec_cosine_ops, 以及对应的操作符 ; (给 tinyintvec 字段创建索引时, 要跳过 NULL 向量值, 不能报错.)   
注意 tinyintvec_cosine_ops 因为要 normal 化, 记得遇到NULL值时要处理除0问题.   
修改对应的 @pgvector/Makefile , @pgvector/sql/vector.sql ;  
记得在 @pgvector/sql/vector.sql 要创建 tinyintvec 对应的 ivfflat 和 hnsw 的 support 函数  
回归测试采用 @tinyintvec.sql   
注意, 如果回归测试过程中遇到数据库崩溃重启的问题, 说明你新增的代码有问题, 一定要解决问题直到回归测试全部正常.   
注意, 回归测试中符合预期的 ERROR 不需要处理, 确认 pgvector/test/sql/tinyintvec.sql 输出都符合预期(该使用索引的必须使用索引, 索引的结果必须和全表扫描的结果一致)后, 将其结果写入 pgvector/test/expected/tinyintvec.out   
数据库已安装好, pg_config 也已经在 PATH 变量中功能, 直接使用 USE_PGXS=1 make clean && USE_PGXS=1 make distclean && USE_PGXS=1 make && USE_PGXS=1 make installcheck 就可以进行测试 .  
````  
  
commit  
  
````  
我正在使用 `pgvector/pgvector` 开发, deepwiki 有该项目的开发文档, 请先调用 deepwiki mcp 工具来了解它, 也可以用 deepwiki 来按需生成代码, 检查代码.   
在 @pgvector/ 代码库的 tinyint_vector 分支中实现 tinyintvec 类型的量化函数:   
参考 binary_quantize 实现2个缩放量化函数 tinyint_quantize , 分别将 vector/halfvec 类型的值量化到 -128 到 127 区间, 采用缩放方式, 这个量化函数假设 vector/halfvec 原始值的取值区间为 [-1.1] , 超出范围取-128或127的边界值 .   
````  
  
commit  
  
````  
我正在使用 `pgvector/pgvector` 开发, deepwiki 有该项目的开发文档, 请先调用 deepwiki mcp 工具来了解它, 也可以用 deepwiki 来按需生成代码, 检查代码.   
@pgvector/src/tinyintvec.c @pgvector/src/tinyintvec.h   
使用 SIMD 优化 build index, search, 量化等过程中的 tinyintvec 向量相关的运算.   
````  
  
commit  
  
````  
我正在使用 `pgvector/pgvector` 开发, deepwiki 有该项目的开发文档, 请先调用 deepwiki mcp 工具来了解它, 也可以用 deepwiki 来按需生成代码, 检查代码.   
@pgvector/sql/vector.sql  
创建一张表, 创建 vector 插件时会自动创建这个表, 如果这个表已存在, 则创建插件时不进行重复创建.   
`create table tinyintvec_quantbase (id serial primray key, quant float8[]);`  
````  
  
````  
我正在使用 `pgvector/pgvector` 开发, deepwiki 有该项目的开发文档, 请先调用 deepwiki mcp 工具来了解它, 也可以用 deepwiki 来按需生成代码, 检查代码.   
@pgvector/src/tinyintvec.c  
新增一个SQL函数 tinyintvec_compute_quantization_centroids , 输入为“schema name, table name, column name, 向量类型, 维度数”. 输出类型为`float8[]`, 这个float8数组的每256个元素表示这个表在每个维度上的聚集点的原始值(例如原始值的区间可能是任意值, 而不是量化后的-128到127).  
如何统计聚集点? 扫描这张表指定字段的数据, 每个维度都采用kmeans算法计算出升序的256个聚集点的值. 例如输入为“public,tbl_test,embedding,vector,128”, 那么计算出的`float8[]`将有`128*256`个元素.  
用c函数的代码实现该SQL函数.  
并在 @pgvector/sql/vector.sql 中添加该SQL函数.  
````  
  
commit  
  
````  
我正在使用 `pgvector/pgvector` 开发, deepwiki 有该项目的开发文档, 请先调用 deepwiki mcp 工具来了解它, 也可以用 deepwiki 来按需生成代码, 检查代码.   
@pgvector/src/tinyintvec.c  
新增一个SQL函数 quantize_vector_with_centroids , 输入为“int、vector”值. 输出类型为`tinyintvec`, 使用输入的int从tinyintvec_quantbase表查询得到quant值(如果在创建索引的语句中调用, 仅查询一次), 用这个quant来量化vector值.  
量化方法: 提取vector每个维度的值, 将它映射到在quant值对应的256个元素中的位置, 也就是离升序的256个聚集点的值哪个位置的值最近(注意优化算法)就映射到哪个位置, 最终它就转换为了[-128,127]区间的值, 达到将vector量化为tinyintvec的目的.  
用c函数的代码实现该SQL函数.  
并在 @pgvector/sql/vector.sql 中添加该SQL函数.    
````  
  
commit  
  
````  
我正在使用 `pgvector/pgvector` 开发, deepwiki 有该项目的开发文档, 请先调用 deepwiki mcp 工具来了解它, 也可以用 deepwiki 来按需生成代码, 检查代码.   
@pgvector/src/tinyintvec.c  
新增一个SQL函数 quantize_vector_with_centroids , 输入为“int、halfvec”值. 输出类型为`tinyintvec`, 使用输入的int从tinyintvec_quantbase表查询得到quant值(如果在创建索引的语句中调用, 仅查询一次), 用这个quant来量化halfvec值.  
量化方法: 提取halfvec每个维度的值, 将它映射到在quant值对应的256个元素中的位置, 也就是离升序的256个聚集点的值哪个位置的值最近(注意优化算法)就映射到哪个位置, 最终它就转换为了[-128,127]区间的值, 达到将halfvec量化为tinyintvec的目的.  
用c函数的代码实现该SQL函数.  
并在 @pgvector/sql/vector.sql 中添加该SQL函数.    
````  
  
  
