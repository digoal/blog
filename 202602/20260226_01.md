## 分享一个好的开源项目 pg_ash : PG 性能洞察(performance insight)插件   
      
### 作者      
digoal      
      
### 日期      
2026-02-26      
      
### 标签      
performance insight , pg_ash    
      
----      
      
## 背景      
今天分享一个PG开源插件 pg_ash, 这个插件能干啥?  
  
定时采样pg_stat_activity和pg_stat_statments的内容, 分析过去任意时间段的等待事件、TOP SQL等. 好处是纯SQL接口, 适合所有场景(RDS和自建都支持).   
  
类似功能实现可参考:   
- [《PostgreSQL 活跃会话历史记录插件 - pgsentinel 类似performance insight \ Oracle ASH Active Session History》](../202003/20200324_25.md)   
- [《PostgreSQL 13 preview - wait event sample - 等待事件统计(插件,hook) - ASH - performance insight》](../202001/20200101_01.md)    
- [《PostgreSQL Oracle 兼容性之 - performance insight - AWS performance insight 理念与实现解读 - 珍藏级》](../201901/20190125_02.md)    
  
下面介绍一下 pg_ash , 详见 https://github.com/NikolayS/pg_ash/blob/main/README.md   
  
-----  
  
作为一个在运维一线摸爬滚打多年的资深 DBA，看到 `pg_ash` 这个项目时，我的第一反应是： **“终于有人把这件事做对了。”**  
  
在传统的 Oracle 领域，**ASH (Active Session History)** 是排查性能问题的“定海神针”。但在 PostgreSQL 社区，我们要么得装笨重的 C 扩展（如 `pg_wait_sampling`），要么得花高价买商业监控软件。  
  
`pg_ash` 的出现，直接把 ASH 的核心能力带到了“平民级”——**免编译、免重启、云数据库（RDS/Supabase等）全兼容**。下面我为你深入浅出地剖析一下这个插件。  
   
## 核心灵魂：为什么它是“反插件”的插件？  
  
传统的 Postgres 扩展通常是 C 语言写的，安装它们需要：  
  
1. 修改 `shared_preload_libraries`。  
2. **重启数据库实例**（这对生产环境是极大的挑战）。  
3. 依赖操作系统权限去编译或安装二进制包。  
  
**`pg_ash` 另辟蹊径：** 它被称为 **“Anti-extension”** （反插件）。它完全由 **纯 SQL 和 PL/pgSQL** 编写。  
  
* **安装就像运行一个脚本：** 只要你有 `pg_cron`（几乎所有主流云厂商如 AWS RDS, Google Cloud SQL 都自带了），跑一遍 SQL 文件就收工。  
* **零侵入：** 它不碰内核，不改配置，想用就 `start`，不想用就 `uninstall`，优雅得像个诗人。  
  
   
  
## 它是怎么工作的？（极简版）  
  
想象你有一个照相机（`pg_cron`），它每秒钟对着 Postgres 的“当前活动状态表”（`pg_stat_activity`）拍一张快照。  
  
1. **抽样 (Sampling)：** 每一秒，它抓取当前谁在干活，谁在等待。  
2. **压缩存储 (Encoding)：** 如果原样保存，硬盘很快就会爆。`pg_ash` 非常聪明地把复杂的会话信息编码成了一个**整数数组 (`integer[]`)**。  
* *DBA 视角：* 这种设计让每条记录只有约 **100 字节**。即使每秒采样一次，一整天也才消耗几十 MB。  
  
  
3. **循环清空 (Rotation)：** 它采用了类似日志滚动的设计，只保留最近 2-3 天的数据，通过 `TRUNCATE` 物理删除旧数据。  
* *DBA 视角：* 这意味着 **零碎片（Bloat）** ，不需要为了清理历史数据去跑麻烦的 `VACUUM`。  
  
   
  
## 杀手锏功能：事后烟（Post-mortem）  
  
作为 DBA，你最怕听到的一句话是：“半小时前数据库突然卡了 1 分钟，现在好了，你查查原因。”  
  
如果没有 `pg_ash`，你只能对着现在的监控图表发呆，因为 `pg_stat_activity` 只显示“现在”的情况。  
有了 `pg_ash`，你可以像回放录像带一样：  
  
```sql  
-- 查半小时前那 10 分钟，到底是哪个 SQL 在阻塞？  
select * from ash.top_waits_at('2026-02-26 09:00', '2026-02-26 09:10');  
```  
  
它甚至能给你画出一个**字符版的彩色时间轴图**（`timeline_chart`），让你一眼看出：是 IO 突然飙升，还是出现了大面积的锁冲突。  
  
   
## 资深 DBA 的使用建议  
  
虽然 `pg_ash` 很强，但在生产环境部署时，我有几点“避坑”建议：  
  
1. **关于 `CPU*` 标志：** 你在报告里会看到 `CPU*`。这不一定代表 CPU 真的忙，它也可能表示 Postgres 内核里某些还没被标记出来的“未知等待”。看到它时，要结合系统监控一起看。  
2. **WAL 写入开销：** 1 秒一次的采样虽然存储空间小，但会产生一定的 WAL（日志）量（约 2.4 GB/天）。如果你的数据库本来写入压力就极大，或者带宽很贵，可以考虑改为 **5 秒采样一次** ：`select ash.start('5 seconds');`。  
3. **云环境的 pg_cron：** 在 RDS 或 Supabase 上使用前，确保已经启用了 `pg_cron` 扩展。  
4. **配合 pg_stat_statements：** 强烈建议开启 `pg_stat_statements`。`pg_ash` 能够自动关联它，从而让你直接看到具体的 SQL 文本，而不是冷冰冰的 `query_id`。  
  
   
## 总结  
  
`pg_ash` 是目前 **成本最低、收益最高** 的 Postgres 性能诊断方案。它弥补了 Postgres 在实时会话历史分析上的多年短板，尤其是对于无法接触到底层的**云数据库用户**，这简直是救命良药。  
  
  
  
#### [PolarDB 学习图谱](https://www.aliyun.com/database/openpolardb/activity "8642f60e04ed0c814bf9cb9677976bd4")
  
  
#### [PostgreSQL 解决方案集合](../201706/20170601_02.md "40cff096e9ed7122c512b35d8561d9c8")
  
  
#### [德哥 / digoal's Github - 公益是一辈子的事.](https://github.com/digoal/blog/blob/master/README.md "22709685feb7cab07d30f30387f0a9ae")
  
  
#### [About 德哥](https://github.com/digoal/blog/blob/master/me/readme.md "a37735981e7704886ffd590565582dd0")
  
  
![digoal's wechat](../pic/digoal_weixin.jpg "f7ad92eeba24523fd47a6e1a0e691b59")
  
