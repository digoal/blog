<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL8.4 Free Space Map Principle from Source Code</h2>
	<h5 id="">2010-05-11 23:55:55&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/1638770402010411115555401/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><p style="TEXT-INDENT: 2em;"   >在说FSM之前，先回顾一个PostgreSQL的Limit   <table border="0"   >  <thead>  <tr>  <th>Limit</th>  <th>Value</th></tr></thead>  <tbody>  <tr>  <td>Maximum Database Size</td>  <td>Unlimited</td></tr>  <tr>  <td>Maximum Table Size</td>  <td>32 TB</td></tr>  <tr>  <td>Maximum Row Size</td>  <td>1.6 TB</td></tr>  <tr>  <td>Maximum Field Size</td>  <td>1 GB</td></tr>  <tr>  <td>Maximum Rows per Table</td>  <td>Unlimited</td></tr>  <tr>  <td>Maximum Columns per Table</td>  <td>250 C 1600 depending on column types</td></tr>  <tr>  <td>Maximum Indexes per Table</td>  <td>Unlimited</td></tr></table></p>  <p style="TEXT-INDENT: 2em;"   >表最大可到32T=2^32*8K &nbsp;(8K 代表一个PAGE),换句话说,一个表最多有2^32个数据块. 记牢这个数字,后面会出现。</p>  <p style="TEXT-INDENT: 2em;"   >最近刚好看了一下PostgreSQL8.4.3的源代码对free space map的介绍，把我的理解写到下面：仅供参考.有兴趣的朋友可以与我线下交流。</p>  <p style="TEXT-INDENT: 2em;"   >Free Space Map</p>  <p style="TEXT-INDENT: 2em;"   >FSM的目标是快速定位有足够空间用于存储一行的PAGE，或用于判断relation的存储是否需要扩展PAGE了。自从8.4一后,FSM被存储在对象相关的”fork”出的文件里面。而在以前的版本，FSM是系统启动时分配的静态内存区域。</p>  <p style="TEXT-INDENT: 2em;"   >为了加快扫描速度，保持FSM越小越好。从而，FSM并不存储PAGE的精确剩余空间。每个PAGE消耗1个字节用与记录剩余空间，因此FSM记录的粒度为256,或者说PAGE被切割成2^8=256分片被跟踪。另外，由于PAGE的头部需要消耗部分存储，所以剩余空间的值必然小于BLCKSZ,最大MAP值为255。</p>  <p style="TEXT-INDENT: 2em;"   >为了达到快速搜索的目的，FSM PAGES并非简单的排列，而是存储为数型结构，PAGES如此，PAGE内部也是如此。</p>  <p style="TEXT-INDENT: 2em;"   >FSM page structure</p>  <p style="TEXT-INDENT: 2em;"   >在FSM的内部，使用二元数结构存储，每个页节点存储一个HEAP PAGE的剩余空间（或来自lower level FSM page跟踪到的HEAP PAGES的剩余空间），非页节点存储下级节点的大值。</p>  <p style="TEXT-INDENT: 2em;"   >图例</p>  <p style="TEXT-INDENT: 2em;"   ><a rel="nofollow" href="http://dba.sky-mobi.com/wp-content/uploads/2010/05/fsm-bin.jpg"   ></a></p>  <p style="TEXT-INDENT: 2em;"   ><a target="_blank" href="http://img539.ph.126.net/wZxlLYMNEQvn0vVXa2NbZQ==/2630946607315582594.jpg"   ><img title="PostgreSQL8.4 Free Space Map Principle from Source Code - 德哥(DiGoal,Just Do It!) - Not Only DBA"   alt="PostgreSQL8.4 Free Space Map Principle from Source Code - 德哥(DiGoal,Just Do It!) - Not Only DBA"   src="http://img539.ph.126.net/wZxlLYMNEQvn0vVXa2NbZQ==/2630946607315582594.jpg"   ></a></p>  <p style="TEXT-INDENT: 2em;"   >FSM PAGE的两种基本操作 (搜索与更新)：</p>  <p style="TEXT-INDENT: 2em;"   >搜索一个页面，需要有X（X代表数字）的剩余空间,从树的顶端开始搜索n&gt;=X，知道找到一个节点为止，如果有多个节点满足条件,可以随意取一个节点。</p>  <p style="TEXT-INDENT: 2em;"   >更新一个页面的剩余空间到X，首先UPDATE leaf node，然后用冒泡算法一直往上更新（比较两个LEAF节点的值，取大值）。直到满足不能再更新的条件为止。</p>  <p style="TEXT-INDENT: 2em;"   >二元数结构的好处：</p>  <p style="TEXT-INDENT: 2em;"   >发现不满足X的剩余空间的节点，只需要查看根节点的值。</p>  <p style="TEXT-INDENT: 2em;"   >这种结构下可以实施优化满足条件的算法，如：并发条件下，当有多个节点满足剩余空间的条件时，可以使用prefetch策略，负载均衡策略等。提高性能</p>  <p style="TEXT-INDENT: 2em;"   >上层程序访问FSM时，使用fsm_set_avail()&nbsp;and fsm_search_avail() 函数，这些函数的接口隐藏了FSM的内部结构，把FSM当成有特定数量的SLOT用于存储FSI的黑盒来处理，所有上层程序必须了解整个MAP的树结构。</p>  <p style="TEXT-INDENT: 2em;"   >在FSM页面的内部，使用ARRAY来存储二元数结构，但是由于PAGE都需要在头上耗费一定的空间，所以二元数结构在这种情形下并不是一个很好的结构。为什么这么说呢，因为PAGE刚好是2的次方，二元树结构需要占用的空间也是2的次方，在消耗了部分头部的情况下，二元数结构在一个PAGE里面就存储不完了，会丢失最右边的一些LEAF。</p>  <p style="TEXT-INDENT: 2em;"   >如图</p>  <p style="TEXT-INDENT: 2em;"   ><a rel="nofollow" href="http://dba.sky-mobi.com/wp-content/uploads/2010/05/fsm-bin1.jpg"   ></a></p>  <p style="TEXT-INDENT: 2em;"   ><a target="_blank" href="http://img775.ph.126.net/Y3ovhqDD42p1YwHpSZmCRw==/2948450381045190185.jpg"   ><img title="PostgreSQL8.4 Free Space Map Principle from Source Code - 德哥(DiGoal,Just Do It!) - Not Only DBA"   alt="PostgreSQL8.4 Free Space Map Principle from Source Code - 德哥(DiGoal,Just Do It!) - Not Only DBA"   src="http://img775.ph.126.net/Y3ovhqDD42p1YwHpSZmCRw==/2948450381045190185.jpg"   ></a></p>  <p style="TEXT-INDENT: 2em;"   >B右边的LEAF NODE信息都丢失了。</p>  <p style="TEXT-INDENT: 2em;"   >数字在这里代表的是ARRAY存储中的位置。</p>  <p style="TEXT-INDENT: 2em;"   >next slot pointer for FSM</p>  <p style="TEXT-INDENT: 2em;"   >fp_next_slot,决定一个PAGE中剩余空间的下一个搜索从哪里开始。这样做的目的是避免热块的产生，当有多个数据库进程请求插入同一个表时，有了fp_next_slot，数据可以插入到不同的PAGE中.同时，考虑到磁盘离散扫描将大大消耗磁盘的IO，所以在并发搜索PAGE的情况下fp_next_slot需要尽量返回靠的很近的PAGE，以满足操作系统级的&nbsp;prefetching and batched&nbsp;writes.</p>  <p style="TEXT-INDENT: 2em;"   >Higher-level structure</p>  <p style="TEXT-INDENT: 2em;"   >前面说到FSM PAGE的LEAF节点可以存储PAGE的剩余空间 ， 也可以存储来自底层FSM PAGE的根节点的值（换句话说是底层这个FSM PAGE存储的PAGE的剩余空间），同样是树结构存储。</p>  <p style="TEXT-INDENT: 2em;"   >说了这么久，终于找到根源了，FSM PAGE的根，被存储在BLOCK 0的位置。</p>  <p style="TEXT-INDENT: 2em;"   >看图，假设一个FSM PAGE可以存储4个PAGE的信息（真实情况下应该存储（(BLCKSZ C headers) / 2, or ~4000 with default BLCKS）个PAGE的信息）</p>  <p style="TEXT-INDENT: 2em;"   ><a rel="nofollow" href="http://dba.sky-mobi.com/wp-content/uploads/2010/05/fsm-bin2.jpg"   ></a></p>  <p style="TEXT-INDENT: 2em;"   ><a target="_blank" href="http://img535.ph.126.net/5aFBF4COcldYhGJSPCau6Q==/94857067152570261.jpg"   ><img title="PostgreSQL8.4 Free Space Map Principle from Source Code - 德哥(DiGoal,Just Do It!) - Not Only DBA"   alt="PostgreSQL8.4 Free Space Map Principle from Source Code - 德哥(DiGoal,Just Do It!) - Not Only DBA"   src="http://img535.ph.126.net/5aFBF4COcldYhGJSPCau6Q==/94857067152570261.jpg"   ></a></p>  <p style="TEXT-INDENT: 2em;"   >数字代表的是改级别下的FSM PAGE NUMBER，在通过SEARCH算法找到了FSM的LEAF NODE后，接下来就需要定位到表的PAGE了，表的PAGE实际上是通过FSM LEAF NODE的位置号算出来的，公式如下</p>  <p style="TEXT-INDENT: 2em;"   >y = n + (n / F + 1) + (n / F^2 + 1) + … + 1</p>  <p style="TEXT-INDENT: 2em;"   >where F is the fanout (4 in the above example). The first term n is the number&nbsp;of preceding leaf pages, the second term is the number of pages at level 1,&nbsp;and so forth.</p>  <p style="TEXT-INDENT: 2em;"   >为了使算法足够简单，树结构的级别应该是一个固定值，考虑到前面说的一个表最大有32T,2^32个PAGE,那么在默认BLCKSZ=4000 bytes的情况下，三级树已经可以满足。(&nbsp;4000^3 &gt; 2^32 )</p>  <p style="TEXT-INDENT: 2em;"   ></p>  <p style="TEXT-INDENT: 2em;"   >寻址：</p>  <p style="TEXT-INDENT: 2em;"   >上层程序使用逻辑寻址，包含1.级别，2.逻辑PAGE号，3.slot（如果可用）</p>  <p style="TEXT-INDENT: 2em;"   >最底层的FSM PAGE级别为0，中间的级别为1，根节点的级别为2。从上面的图上看出，FSM PAGE的逻辑号为标注的数字，从0开始计算。</p>  <p style="TEXT-INDENT: 2em;"   >锁：</p>  <p style="TEXT-INDENT: 2em;"   >从上至下搜索FSM PAGE时，同一时刻只有一个PAGE被锁，锁子PAGE前必须先释放父PAGE的锁，如果子PAGE同时正在被修改，并且没有其他子PAGE能够满足请求的剩余空间，这个时候为了避免死循环，正在申请空间的这个进程将等待子PAGE的父PAGE更新剩余空间后继续。</p>  <p style="TEXT-INDENT: 2em;"   >搜索PAGE时使用的是shared buffer locks，更新PAGE时使用的是&nbsp;exclusive buffer lock。尽管如此，下一个slot search pointer的值在shared buffer locks模式下也将被更新。fp_next_slot只是一个计数器，在CORRUPTED后可以被重置。所以尽管冒点风险使用fp_next_slot还是优于使用独占锁模式。</p>  <p style="TEXT-INDENT: 2em;"   >恢复：</p>  <p style="TEXT-INDENT: 2em;"   >FSM不记录WAL，而是使用自修复机制来恢复异常情况。</p>  <p style="TEXT-INDENT: 2em;"   >首先，无论何时设置一个FSM PAGE节点的值，在冒泡算法执行完后，都需要去比较一下ROOT节点的值，小了的话就马上修复。防止这个FSM PAGE根数据太小。</p>  <p style="TEXT-INDENT: 2em;"   >其次，如果检查到页面CORRUPT了，马上使用冒泡算法修正FSM PAGE节点的值。</p>  <p style="TEXT-INDENT: 2em;"   >VACUUM操作更新所有的最底层的FSM PAGE NODE值，修正过期的FREE SPACE值。FreeSpaceMapVacuum在VACUUM过后被调用，FSM PAGE将被从下至上扫描一遍。修正一些FSM PAGE(upper and lower)之间的分歧数据.</p>  <p style="TEXT-INDENT: 2em;"   ></p></div>
	</div>
</div>
</body>
</html>