<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL Selectivity Tablespace PITR</h2>
	<h5 id="">2012-04-26 13:34:48&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/16387704020123261422581/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;">今天在群里面一位老兄在问PostgreSQL能不能做基于数据库实例的PITR.<div>这位老兄可能是Oracle的用户, 因为ORACLE是支持基于表空间的RMAN恢复的.</div><div>至于为什么要这么做, 显然例如我要恢复的数据库只在某个表空间里面, 而其他表空间的数据我是不关心的. 基于表空间的恢复在恢复过程中占用更小的物理存储, 并且能加快恢复速度. 所以还是很有市场需求的.<br><div>理论上来讲, PG是不支持这么做的. 但是可以通过仅恢复要恢复的数据库实例涉及的表空间们来模拟基于数据库实例的恢复.&nbsp;</div><div>要成功的实施PostgreSQL的基于表空间的数据库PITR, 必须满足几个条件.</div><div>1. 有完整的基础数据文件备份和归档文件备份.</div><div>2. 恢复时pg_root, 也就是源数据是必选的(即initdb时指定的$PGDATA).</div><div>3. 如果要恢复的表空间不是pg_default表空间, 那么这个表空间的基础备份需要作为恢复材料放到指定位置. 而其他不需要的表空间不需要拷贝到指定位置.</div><div><br></div><div>下面我通过例子来讲解一下,</div><div>1. 我的测试库已有的表空间如下,</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >postgres-# \db</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;List of tablespaces</font></div><div><font size="2"  >&nbsp; &nbsp; Name &nbsp; &nbsp;| &nbsp;Owner &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Location &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"  >------------+----------+---------------------------------------------</font></div><div><font size="2"  >&nbsp;digoal &nbsp; &nbsp; | postgres | /pgdata/digoal/1921/data02/pg_tbs/digoal</font></div><div><font size="2"  >&nbsp;digoal_01 &nbsp;| postgres | /pgdata/digoal/1921/data03/pg_tbs/digoal_01</font></div><div><font size="2"  >&nbsp;digoal_02 &nbsp;| postgres | /pgdata/digoal/1921/data04/pg_tbs/digoal_02</font></div><div><font size="2"  >&nbsp;digoal_03 &nbsp;| postgres | /pgdata/digoal/1921/data05/pg_tbs/digoal_03</font></div><div><font size="2"  >&nbsp;digoal_04 &nbsp;| postgres | /pgdata/digoal/1921/data06/pg_tbs/digoal_04</font></div><div><font size="2"  >&nbsp;pg_default | postgres |&nbsp;</font></div><div><font size="2"  >&nbsp;pg_global &nbsp;| postgres |&nbsp;</font></div><div><font size="2"  >(7 rows)</font></div><p></p></pre></div><div><br></div><div>2. 新建两个数据库test1和test2 , 分布使用digoal_01和digoal_02作为默认表空间. 我的目的是只恢复test1库, 而不关心test2库的数据.</div><div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >postgres=# create database test1 tablespace digoal_01;</font></div><div><font size="2"  >CREATE DATABASE</font></div><div><font size="2"  >postgres=# create database test2 tablespace digoal_02;</font></div><div><font size="2"  >CREATE DATABASE</font></div><p></p></pre></div><div>-- 连接到test1库</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >postgres=# \c test1&nbsp;</font></div><div><font size="2"  >You are now connected to database "test1" as user "postgres".</font></div><p></p></pre></div><div>-- 建立测试表</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >test1=# create table test (id int);</font></div><div><font size="2"  >CREATE TABLE</font></div><p></p></pre></div><div>-- 插入一些测试数据</div><div><br></div><div><span style="line-height: 22px;"  >-- 连接到test2库</span> </div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >test1=# \c test2&nbsp;</font></div><div><font size="2"  >You are now connected to database "test2" as user "postgres".</font></div><p></p></pre></div><div><span style="line-height: 22px;"  >-- 建立测试表</span> </div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >test2=# create table test (id int);</font></div><div><font size="2"  >CREATE TABLE</font></div><p></p></pre></div><div>-- 插入测试数据</div></div><div><br></div><div>-- 开始备份</div><div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >test2=# select pg_start_backup('test');</font></div><div><font size="2"  >&nbsp;pg_start_backup&nbsp;</font></div><div><font size="2"  >-----------------</font></div><div><font size="2"  >&nbsp;1C/B8000020</font></div><div><font size="2"  >(1 row)</font></div><p></p></pre></div><div><br></div><div><div>-- 创建备份目录</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >postgres@db-172-16-3-150-&gt; cd /pgdata/digoal/1921/data01</font></div><div><font size="2"  >postgres@db-172-16-3-150-&gt; mkdir -p pg_bak/pg_root</font></div><p></p></pre></div><div>-- 进入$PGDATA, 准备备份</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >postgres@db-172-16-3-150-&gt; cd $PGDATA</font></div><div><font size="2"  >postgres@db-172-16-3-150-&gt; ll</font></div><div><font size="2"  >total 100K</font></div><div><font size="2"  >-rw------- 1 postgres postgres &nbsp;176 Apr 26 11:03 backup_label</font></div><div><font size="2"  >-rw------- 1 postgres postgres &nbsp;188 Mar 13 09:59 backup_label.old</font></div><div><font size="2"  >drwx------ 5 postgres postgres 4.0K Apr 25 15:16 base</font></div><div><font size="2"  >drwx------ 2 postgres postgres 4.0K Apr 26 11:00 global</font></div><div><font size="2"  >drwx------ 2 postgres postgres 4.0K Mar 13 13:13 pg_clog</font></div><div><font size="2"  >-rw------- 1 postgres postgres 4.5K Mar 13 09:59 pg_hba.conf</font></div><div><font size="2"  >-rw------- 1 postgres postgres 1.6K Mar 13 09:59 pg_ident.conf</font></div><div><font size="2"  >drwx------ 4 postgres postgres 4.0K Mar 13 09:59 pg_multixact</font></div><div><font size="2"  >drwx------ 2 postgres postgres 4.0K Apr 26 10:28 pg_notify</font></div><div><font size="2"  >drwx------ 2 postgres postgres 4.0K Mar 13 09:59 pg_serial</font></div><div><font size="2"  >drwx------ 2 postgres postgres 4.0K Apr 26 10:28 pg_stat_tmp</font></div><div><font size="2"  >drwx------ 2 postgres postgres 4.0K Mar 19 11:32 pg_subtrans</font></div><div><font size="2"  >drwx------ 2 postgres postgres 4.0K Apr 26 10:40 pg_tblspc</font></div><div><font size="2"  >drwx------ 2 postgres postgres 4.0K Mar 13 09:59 pg_twophase</font></div><div><font size="2"  >-rw------- 1 postgres postgres &nbsp; &nbsp;4 Mar 13 09:59 PG_VERSION</font></div><div><font size="2"  >lrwxrwxrwx 1 postgres postgres &nbsp; 34 Mar 13 10:02 pg_xlog -&gt; /pgdata/digoal/1921/data01/pg_xlog</font></div><div><font size="2"  >-rw------- 1 postgres postgres &nbsp;19K Apr 26 10:58 postgresql.conf</font></div><div><font size="2"  >-rw------- 1 postgres postgres &nbsp; 24 Apr 26 10:28 postmaster.opts</font></div><div><font size="2"  >-rw------- 1 postgres postgres &nbsp; 87 Apr 26 10:28 postmaster.pid</font></div><div><font size="2"  >-rw-r--r-- 1 postgres postgres 4.8K Mar 13 08:12 recovery.done</font></div><p></p></pre></div><div>-- 备份pg_xlog和pg_tblspc以外的所有文件</div><div><pre class="prettyprint"  ><p><font size="2"  >postgres@db-172-16-3-150-&gt; cp -r backup_label backup_label.old base global pg_clog pg_hba.conf pg_ident.conf pg_multixact pg_notify pg_serial pg_stat_tmp pg_subtrans pg_twophase PG_VERSION postgresql.conf postmaster.opts recovery.done /pgdata/digoal/1921/data01/pg_bak/pg_root/</font></p></pre></div><div>-- 记录下pg_tblspc的软链接信息</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >postgres@db-172-16-3-150-&gt; cd pg_tblspc/</font></div><div><font size="2"  >postgres@db-172-16-3-150-&gt; ll</font></div><div><font size="2"  >total 0</font></div><div><font size="2"  >lrwxrwxrwx 1 postgres postgres 40 Apr 26 10:40 16385 -&gt; /pgdata/digoal/1921/data02/pg_tbs/digoal</font></div><div><font size="2"  >lrwxrwxrwx 1 postgres postgres 43 Mar 13 09:59 16682 -&gt; /pgdata/digoal/1921/data03/pg_tbs/digoal_01</font></div><div><font size="2"  >lrwxrwxrwx 1 postgres postgres 43 Mar 13 09:59 16684 -&gt; /pgdata/digoal/1921/data04/pg_tbs/digoal_02</font></div><div><font size="2"  >lrwxrwxrwx 1 postgres postgres 43 Mar 13 09:59 16685 -&gt; /pgdata/digoal/1921/data05/pg_tbs/digoal_03</font></div><div><font size="2"  >lrwxrwxrwx 1 postgres postgres 43 Mar 13 09:59 16686 -&gt; /pgdata/digoal/1921/data06/pg_tbs/digoal_04</font></div><p></p></pre></div></div></div><div><br></div><div>-- 备份test1库的默认表空间, 其他表空间我就不备份了, 因为我不打算还原它们.</div><div><pre class="prettyprint"  ><p><font size="2"  >postgres@db-172-16-3-150-&gt; cp -r &nbsp;/pgdata/digoal/1921/data03/pg_tbs/digoal_01 /pgdata/digoal/1921/data01/pg_bak/</font></p></pre></div><div><br></div><div>-- 关闭备份标签.</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >postgres=# select * from pg_stop_backup();</font></div><div><font size="2"  >NOTICE: &nbsp;pg_stop_backup complete, all required WAL segments have been archived</font></div><div><font size="2"  >&nbsp;pg_stop_backup&nbsp;</font></div><div><font size="2"  >----------------</font></div><div><font size="2"  >&nbsp;1C/B80001F8</font></div><div><font size="2"  >(1 row)</font></div><p></p></pre></div><div><br></div><div>-- 再次在test1和test2库插入测试数据, 等会恢复后我们看看基础备份以后产生的数据会不会正常恢复.</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >postgres=# \c test1</font></div><div><font size="2"  >You are now connected to database "test1" as user "postgres".</font></div><div><font size="2"  >test1=# insert into test select generate_series(1,1000000);</font></div><div><font size="2"  >INSERT 0 1000000</font></div><div><font size="2"  >test1=# insert into test select generate_series(1,1000000);</font></div><div><font size="2"  >INSERT 0 1000000</font></div><div><font size="2"  >test1=# insert into test select generate_series(1,1000000);</font></div><div><font size="2"  >INSERT 0 1000000</font></div><div><font size="2"  >test1=# select count(*) from test;</font></div><div><font size="2"  >&nbsp; count &nbsp;&nbsp;</font></div><div><font size="2"  >----------</font></div><div><font size="2"  >&nbsp;20000000</font></div><div><font size="2"  >(1 row)</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >test1=# \c test2</font></div><div><div style="line-height: 22px;"  ><font size="2"  >test2=# insert into test select generate_series(1,1000000);</font></div><div style="line-height: 22px;"  ><font size="2"  >INSERT 0 1000000</font></div><div style="line-height: 22px;"  ><font size="2"  >test2=# insert into test select generate_series(1,1000000);</font></div><div style="line-height: 22px;"  ><font size="2"  >INSERT 0 1000000</font></div><div style="line-height: 22px;"  ><font size="2"  >test2=# insert into test select generate_series(1,1000000);</font></div><div style="line-height: 22px;"  ><font size="2"  >INSERT 0 1000000</font></div></div><div style="line-height: 22px;"  ><font size="2"  >...........................................</font></div><div style="line-height: 22px;"  ><font size="2"  >...........................................</font></div><div><font size="2"  >test2=# select count(*) from test;</font></div><div><font size="2"  >&nbsp; count &nbsp;&nbsp;</font></div><div><font size="2"  >----------</font></div><div><font size="2"  >&nbsp;20000000</font></div><div><font size="2"  >(1 row)</font></div><div><font size="2"  >test2=# checkpoint;</font></div><div><font size="2"  >CHECKPOINT</font></div><p></p></pre></div><div><br></div><div>-- 停止数据库</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >postgres@db-172-16-3-150-&gt; pg_ctl stop -m fast</font></div><div><font size="2"  >waiting for server to shut down...... done</font></div><div><font size="2"  >server stopped</font></div><p></p></pre></div><div><br></div><div>-- 以下就是关键步骤了, 基于表空间的PITR.</div><div>-- 把老的pg_root目录改个名字</div><div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >postgres@db-172-16-3-150-&gt; cd $PGDATA/..</font></div><div><font size="2"  >postgres@db-172-16-3-150-&gt; ll</font></div><div><font size="2"  >total 24K</font></div><div><font size="2"  >drwx------ &nbsp;2 postgres postgres &nbsp;16K Mar 13 09:56 lost+found</font></div><div><font size="2"  >drwx------ 12 postgres postgres 4.0K Apr 26 11:18 pg_root</font></div><div><font size="2"  >drwxrwxr-x &nbsp;3 postgres postgres 4.0K Mar 13 09:58 pg_tbs</font></div><div><font size="2"  >postgres@db-172-16-3-150-&gt; mv pg_root pg_root_old</font></div><p></p></pre></div><div>-- 还原前面的pg_root基础备份</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >postgres@db-172-16-3-150-&gt; cp -r /pgdata/digoal/1921/data01/pg_bak/pg_root ./</font></div><div><font size="2"  >postgres@db-172-16-3-150-&gt; ll</font></div><div><font size="2"  >total 28K</font></div><div><font size="2"  >drwx------ &nbsp;2 postgres postgres &nbsp;16K Mar 13 09:56 lost+found</font></div><div><font size="2"  >drwxrwxr-x 11 postgres postgres 4.0K Apr 26 11:21 pg_root</font></div><div><font size="2"  >drwx------ 12 postgres postgres 4.0K Apr 26 11:18 pg_root_old</font></div><div><font size="2"  >drwxrwxr-x &nbsp;3 postgres postgres 4.0K Mar 13 09:58 pg_tbs</font></div><p></p></pre></div><div>-- 修改权限为700</div><div><pre class="prettyprint"  ><p><font size="2"  >postgres@db-172-16-3-150-&gt; chmod -R 700 pg_root</font></p></pre></div><div>-- 新建pg_xlog和pg_tblspc并修改权限为700</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >postgres@db-172-16-3-150-&gt; cd pg_root</font></div><div><font size="2"  >mkdir pg_xlog</font></div><div><font size="2"  >chmod 700 pg_xlog</font></div><div><font size="2"  >mkdir pg_tblspc</font></div><div><font size="2"  >chmod 700 *</font></div><p></p></pre></div><div>-- 把要恢复的表空间的软链接先做好, 其他软链接不做</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >cd pg_tblspc</font></div><div><font size="2"  >ln -s /pgdata/digoal/1921/data03/pg_tbs/digoal_01 16682</font></div><p></p></pre></div><div><br></div><div>-- 以下选用第3点方法.</div><div>-- 注意, 别指望以下能帮你节省掉其他不需要的表空间的恢复过程中产生的数据(即基础备份以来对这些表空间更改过或新增的BLOCK).</div><div>因为会报错, 我后面会贴出错误报告.</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >ln -s /dev/null 16385</font></div><div><font size="2"  >ln -s /dev/null 16684</font></div><div><font size="2"  >ln -s /dev/null 16685</font></div><div><font size="2"  >ln -s /dev/null 16686</font></div><p></p></pre></div><div>比较靠谱的方法是 :&nbsp;</div><div>1. 找到类似黑洞的文件系统, 建的文件在里面都是虚假的.</div><div>2. 弄个程序把过程中产生的大文件至空.</div><div>3. 如果其他表空间在此期间没有产生太多的数据就让他去吧</div><div>4. 修改PG源码, 让它支持基于表空间或数据库实例级别的PITR.&nbsp;</div><div>基于数据库实例级别的PITR注意事项, 为了避免产生不一致数据, 这种恢复可能丢失跨库事务的一致性.</div><div>基于表空间的恢复注意事项, 可能丢失同一数据库的事务一致性, 因为同一个数据库中可以有多个表空间. 所以基于表空间的PITR, 应该把要恢复的表空间以及该表空间所在库的其他表空间也进行PITR.</div><div>我这里为了测试方便选择了第3点.</div><div><br></div><div>-- 接下来把需要恢复的表空间的目录改名,</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >postgres@db-172-16-3-150-&gt; cd /pgdata/digoal/1921/data03/pg_tbs</font></div><div><font size="2"  >postgres@db-172-16-3-150-&gt; mv digoal_01 digoal_01_old</font></div><div></div><p></p></pre></div><div><span style="line-height: 22px;"  >-- 把需要恢复的digoal_01表空间的备份文件拷贝到它所在的目录, 并修改权限700</span></div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >postgres@db-172-16-3-150-&gt; cp -r /pgdata/digoal/1921/data01/pg_bak/digoal_01 ./</font></div><div><font size="2"  >postgres@db-172-16-3-150-&gt; chmod -R 700 digoal_01</font></div><p></p></pre></div><div><br></div><div>-- 新建recovery.conf文件, 告诉PostgreSQL要恢复了.</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >postgres@db-172-16-3-150-&gt; cd $PGDATA</font></div><div><font size="2"  >postgres@db-172-16-3-150-&gt; vi recovery.conf</font></div><div><font size="2"  >restore_command = 'cp /pgdata/digoal/1921/data01/pg_arch/%f %p' &nbsp; &nbsp; &nbsp; &nbsp; # e.g. 'cp /mnt/server/archivedir/%f %p'</font></div><div><font size="2"  >recovery_target_timeline = 'latest'</font></div><div><font size="2"  >postgres@db-172-16-3-150-&gt; chmod 700 recovery.conf&nbsp;</font></div><p></p></pre></div><div><br></div><div>-- 启动数据库进行恢复</div><div><pre class="prettyprint"  ><p><font size="2"  >pg_ctl start -D $PGDATA</font></p></pre></div><div><br></div><div>-- 恢复后可以看到pg_tblspc中会新建一个目录16684, 其实就是digoal_02的表空间目录.</div><div><pre class="prettyprint"  ><p><font size="2"  >&nbsp;<span style="line-height: 22px;"  >lrwxrwxrwx 1 postgres postgres 43 Mar 13 09:59 16684 -&gt; /pgdata/digoal/1921/data04/pg_tbs/digoal_02</span></font></p></pre></div><div>-- 因为恢复过程中的WAL中包含了digoal_02这个表空间的XLOG日志(还记得我前面在test2库中插入的操作吗?), 恢复时会主动创建这些文件.&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><div><font size="2"  >postgres@db-172-16-3-150-&gt; cd $PGDATA/pg_tblspc</font></div><div><font size="2"  >postgres@db-172-16-3-150-&gt; ll</font></div><div><font size="2"  >total 4.0K</font></div><div><font size="2"  >lrwxrwxrwx 1 postgres postgres &nbsp; 43 Apr 26 12:41 16682 -&gt; /pgdata/digoal/1921/data03/pg_tbs/digoal_01</font></div><div><font size="2"  >drwx------ 3 postgres postgres 4.0K Apr 26 12:42 16684</font></div><div><font size="2"  >postgres@db-172-16-3-150-&gt; du -sh *</font></div><div><font size="2"  >0 &nbsp; &nbsp; &nbsp; 16682</font></div><div><font size="2"  >692M &nbsp; &nbsp;16684</font></div></div><div></div><p></p></pre></div></div><div>-- 恢复结束后就可以连到test1库了, 检查数据是否正确.&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >postgres=# \c test1&nbsp;</font></div><div><font size="2"  >You are now connected to database "test1" as user "postgres".</font></div><div><font size="2"  >test1=# select count(*) from test;</font></div><div><font size="2"  >&nbsp; count &nbsp;&nbsp;</font></div><div><font size="2"  >----------</font></div><div><font size="2"  >&nbsp;20000000</font></div><div><font size="2"  >(1 row)</font></div><p></p></pre></div><div>从验证结果来看, PG的基于表空间的PITR是可行的.</div><div><br></div><div>【小结】</div><div>恢复过程中过滤掉不需要的表空间变更信息, 就不会产生那一堆的其他表空间的变更数据了, PostgreSQL内核中加入基于数据库或表空间的恢复不会太遥远.&nbsp;</div><div><br></div><div>【附】</div><div><div style="line-height: 22px;"  >-- 使用/dev/null做黑洞的失败记录</div><div><pre class="prettyprint"  ><p></p><div style="line-height: 22px;"  ><font size="2"  >postgres@db-172-16-3-150-&gt; pg_ctl start</font></div><div style="line-height: 22px;"  ><font size="2"  >LOG: &nbsp;could not open temporary-files directory "pg_tblspc/16685/PG_9.1_201105231/pgsql_tmp": Not a directory</font></div><div style="line-height: 22px;"  ><font size="2"  >LOG: &nbsp;could not open tablespace directory "pg_tblspc/16685/PG_9.1_201105231": Not a directory</font></div><div style="line-height: 22px;"  ><font size="2"  >LOG: &nbsp;could not open temporary-files directory "pg_tblspc/16686/PG_9.1_201105231/pgsql_tmp": Not a directory</font></div><div style="line-height: 22px;"  ><font size="2"  >LOG: &nbsp;could not open tablespace directory "pg_tblspc/16686/PG_9.1_201105231": Not a directory</font></div><div style="line-height: 22px;"  ><font size="2"  >LOG: &nbsp;could not open temporary-files directory "pg_tblspc/16684/PG_9.1_201105231/pgsql_tmp": Not a directory</font></div><div style="line-height: 22px;"  ><font size="2"  >LOG: &nbsp;could not open tablespace directory "pg_tblspc/16684/PG_9.1_201105231": Not a directory</font></div><div style="line-height: 22px;"  ><font size="2"  >LOG: &nbsp;could not open temporary-files directory "pg_tblspc/16385/PG_9.1_201105231/pgsql_tmp": Not a directory</font></div><div style="line-height: 22px;"  ><font size="2"  >LOG: &nbsp;could not open tablespace directory "pg_tblspc/16385/PG_9.1_201105231": Not a directory</font></div><p></p></pre></div><div style="line-height: 22px;"  ><br style="line-height: 22px;"  ></div><div style="line-height: 22px;"  >-- 到最后会恢复失败,csv日志如下 :&nbsp;</div><div style="line-height: 22px;"  ><pre class="prettyprint"  ><p></p><div><div style="line-height: 22px;"  ><font size="2"  ><span style="line-height: 22px;"  >postgres@db-172-16-3-150-&gt; cd /var/applog/pg_log/digoal/1921/</span> </font></div><div style="line-height: 22px;"  ><font size="2"  >2012-04-26 12:28:52.916 CST,,,24354,,4f98cef9.5f22,20,,2012-04-26 12:28:41 CST,1/0,0,FATAL,42809,"could not stat directory ""pg_tblspc/16684/PG_9.1_201105231/3944339"": Not a directory",,,,,"xlog redo insert: rel 16684/3944339/3944343; tid 22123/203",,,,""</font></div><div style="line-height: 22px;"  ><font size="2"  >2012-04-26 12:28:52.921 CST,,,24346,,4f98cef2.5f1a,2,,2012-04-26 12:28:34 CST,,0,LOG,00000,"startup process (PID 24354) exited with exit code 1",,,,,,,,,""</font></div><div style="line-height: 22px;"  ><font size="2"  >2012-04-26 12:28:52.921 CST,,,24346,,4f98cef2.5f1a,3,,2012-04-26 12:28:34 CST,,0,LOG,00000,"terminating any other active server processes",,,,,,,,,""</font></div></div><div></div><p></p></pre></div></div><div><wbr></div></div></div>
	</div>
	<h3>评论</h3>
	<div class="" id="" style="padding:0 20px;">
			<div id="">
				<h5 id="">ATILive - 2014-02-18 20:52:03</h5>
				<div>请问有没有windows平台的PITR实例呢 我在windows平台恢复时候遇到了点问题 &nbsp;服务起不起来了</div>
			</div>
			<div style="padding-left:40px;">
				<h5 id="">德哥@Digoal 回复 ATILive - 2014-02-18 20:52:03</h5>
				<div style="width:600px;">抱歉,没有win的. 原理一样, 您可以自己尝试一下.</div>
			</div>
			<div style="padding-left:40px;">
				<h5 id="">ATILive 回复 德哥@Digoal - 2014-02-18 20:52:03</h5>
				<div style="width:600px;">我现在已经解决了之前服务无法起来的问题，对data等文件夹修改权限后，已经解决问题，但接着又遇到了新问题，连接后提示"pg_tbspc/16094 invalid argument"的提示，pgadmin上看上去，表空间(0)...<div>我按照手册文档做的PITR，我想问题应该出在pg_tbspc这个文档的恢复前准备上，文档中有一段是这么描述的：</div><div>“4、从你的备份转储中恢复数据库文件。要小心用正确的所有者（数据库系统用户，而不是 root！）和权限恢复它们。 如果你使用了表空间，你可能需要核实在 pg_tblspc/ 里的符号连接都得到正确恢复。”</div><div>我对这样抽象的描述不知道怎么操作，怎么"核实在&nbsp;pg_tblspc/&nbsp;里的符号连接都得到正确恢复"是我非常关心的，但文档里并没有提供任何例子或操作指南。我现在被卡在这里了，any suggestion？</div></div>
			</div>
			<div style="padding-left:40px;">
				<h5 id="">德哥@Digoal 回复 ATILive - 2014-02-18 20:52:03</h5>
				<div style="width:600px;">需要700权限.&nbsp;</div>
			</div>
			<div style="padding-left:40px;">
				<h5 id="">ATILive 回复 德哥@Digoal - 2014-02-18 20:52:03</h5>
				<div style="width:600px;">谢谢回复，只是我的windows没法用chmod <div>而且有个细节的问题是，一旦将data在热备过程中拷贝到其他目录后，data文件下的pg_tbspc文档下的OID文件夹将会变空，即使重新拷贝回原来的地方，依然为空，且服务器无法启动，报错为<span style=""  >"pg_tbspc/16094“不是一个有效目录，很费解（纵使自己建立个超链接文档至之前的表空间物理文件位置，系统依然不认）。。。头痛</span></div></div>
			</div>
			<div style="padding-left:40px;">
				<h5 id="">ATILive 回复 德哥@Digoal - 2014-02-18 20:52:03</h5>
				<div style="width:600px;">我使用administrator账号安装的pg，顺便说下，没有在本地用户和组中考到类似postgres的用户被建立。</div>
			</div>
			<div style="padding-left:40px;">
				<h5 id="">德哥@Digoal 回复 ATILive - 2014-02-18 20:52:03</h5>
				<div style="width:600px;">因为这是个软链接. 当然你可以放弃使用软链接. 直接放也是可行的.</div>
			</div>
			<div style="padding-left:40px;">
				<h5 id="">ATILive 回复 德哥@Digoal - 2014-02-18 20:52:03</h5>
				<div style="width:600px;">谢谢~ 我在研究研究<br><br></div>
			</div>
			<div id="">
				<h5 id="">douya0808 - 2013-10-21 10:41:18</h5>
				<div>还有就是德哥你的其中一步还需要记录之前的oid，但是我的想法是为什么不在恢复的时候将备份的表空间当做新的表空间呢？就是将以前通过表空间oid的方式将表空间ln -s回pg_tblspc的方式，变成新建表空间再把备份的表空间放回来的方式呢?<img src="http://b.bst.126.net/common/portrait/face/preview/face2.gif"  ></div>
			</div>
			<div style="padding-left:40px;">
				<h5 id="">德哥@Digoal 回复 douya0808 - 2013-10-21 10:41:18</h5>
				<div style="width:600px;">表空间的oid在系统metadata里面是有存储的, 也就是global数据, 不好直接替换的.<div><div>例如pg_tablespace.oid, pg_class中的reltablespace.</div></div></div>
			</div>
			<div id="">
				<h5 id="">douya0808 - 2013-10-21 9:55:14</h5>
				<div>你好德哥，我的基础备份里是不放数据的啊，数据都是按照年份存放的，如2013年的数据都存放在一个叫2013的表空间中，但是为什么每次的备份和恢复却需要将基础路径的data也备份呢<div><br></div><div>我试过只恢复表空间，然后建立ln -s，但是发现不可行，十分的困惑呀<img src="http://b.bst.126.net/common/portrait/face/preview/face2.gif"  ></div></div>
			</div>
			<div style="padding-left:40px;">
				<h5 id="">德哥@Digoal 回复 douya0808 - 2013-10-21 9:55:14</h5>
				<div style="width:600px;">HI, 主要是global相关的数据, 是必须恢复的, 否则数据库开不起来.</div>
			</div>
			<div id="">
				<h5 id="">douya0808 - 2013-10-20 18:13:09</h5>
				<div>太好了！！！！！正好有用！！！！！<br><br></div>
			</div>
	</div>
</div>
</body>
</html>