<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">socket programming example</h2>
	<h5 id="">2012-09-06 15:06:44&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/16387704020128622026131/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div><div>1. 头文件</div><div>vi server.h&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >// 头文件</font></div><div><font size="2"  >// 注册信号处理函数</font></div><div><font size="2"  >int catch_signal(int sig, void (*handler) (int));</font></div><div><font size="2"  >// 从socket读数据到char *buf</font></div><div><font size="2"  >int read_in(int socket, char *buf, int len);</font></div><div><font size="2"  >// 错误函数, 当exit_val=0只输出错误信息, 不退出程序. 其他值输出错误信息并退出程序</font></div><div><font size="2"  >void error(char * msg, int exit_val);</font></div><div><font size="2"  >// 创建监听socket</font></div><div><font size="2"  >int open_listener_socket();</font></div><div><font size="2"  >// 绑定socket到端口port</font></div><div><font size="2"  >void bind_to_port(int socket, int port);</font></div><div><font size="2"  >// 监听socket, 允许队列数queue.</font></div><div><font size="2"  >void listen_to_socket(int socket, int queue);</font></div><div><font size="2"  >// 开始等待客户端连接.</font></div><div><font size="2"  >int accept_socket(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</font></div><div><font size="2"  >// 向socket发送信息</font></div><div><font size="2"  >int say(int socket, char *s);</font></div><div><font size="2"  >// 信号处理函数</font></div><div><font size="2"  >void handle_shutdown(int sig);</font></div><p></p></pre></div><div><br></div><div>2. c文件</div><div>vi server.c</div><div><pre class="prettyprint"  ><div><font size="2"  >#include &lt;stdio.h&gt;</font></div><div><font size="2"  >#include &lt;string.h&gt;</font></div><div><font size="2"  >#include &lt;errno.h&gt;</font></div><div><font size="2"  >#include &lt;stdlib.h&gt;</font></div><div><font size="2"  >#include &lt;sys/socket.h&gt;</font></div><div><font size="2"  >#include &lt;arpa/inet.h&gt;</font></div><div><font size="2"  >#include &lt;unistd.h&gt;</font></div><div><font size="2"  >#include &lt;signal.h&gt;</font></div><div><font size="2"  >#include "server.h"</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >int catch_signal(int sig, void (*handler) (int)) {</font></div><div><font size="2"  >&nbsp; struct sigaction action;</font></div><div><font size="2"  >&nbsp; action.sa_handler = handler;</font></div><div><font size="2"  >&nbsp; sigemptyset(&amp;action.sa_mask);</font></div><div><font size="2"  >&nbsp; // sigemptyset() return 0 on success and -1 on error.</font></div><div><font size="2"  >&nbsp; action.sa_flags = 0;</font></div><div><font size="2"  >&nbsp; return sigaction(sig, &amp;action, NULL);</font></div><div><font size="2"  >&nbsp; // sigaction() returns 0 on success and -1 on error.</font></div><div><font size="2"  >}</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >// recv()注意:</font></div><div><font size="2"  >// 1. The characters are not terminated with a \0 character.</font></div><div><font size="2"  >// 2. When someone types text in telnet, the string always ends \r\n.</font></div><div><font size="2"  >// 3. The recv() will return the number of characters, or C1 if there's an error, or&nbsp;</font></div><div><font size="2"  >// &nbsp; &nbsp;0 if the client has closed the connection.</font></div><div><font size="2"  >// 4. You're not guaranteed to receive all the characters in a single call to recv().</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >// This reads all the characters until it reaches '\n'.</font></div><div><font size="2"  >int read_in(int socket, char *buf, int len) {</font></div><div><font size="2"  >&nbsp; char *s = buf;</font></div><div><font size="2"  >&nbsp; int slen = len;</font></div><div><font size="2"  >&nbsp; int c = recv(socket, s, slen, 0);</font></div><div><font size="2"  >&nbsp; // Keep reading until there are no more characters or you reach '\n'.</font></div><div><font size="2"  >&nbsp; while ( (c &gt; 0) &amp;&amp; (s[c-1] != '\n') ) {</font></div><div><font size="2"  >&nbsp; &nbsp; s += c; slen -= c;</font></div><div><font size="2"  >&nbsp; &nbsp; c = recv(socket, s, slen, 0);</font></div><div><font size="2"  >&nbsp; }</font></div><div><font size="2"  >&nbsp; if (c &lt; 0)</font></div><div><font size="2"  >&nbsp; &nbsp; // In case there's an error</font></div><div><font size="2"  >&nbsp; &nbsp; return c;</font></div><div><font size="2"  >&nbsp; else if (c == 0)</font></div><div><font size="2"  >&nbsp; &nbsp; // Nothing read; send back an empty string</font></div><div><font size="2"  >&nbsp; &nbsp; buf[0] = '\0';</font></div><div><font size="2"  >&nbsp; else</font></div><div><font size="2"  >&nbsp; &nbsp; // Replace the last character(here is '\n') with a '\0'.</font></div><div><font size="2"  >&nbsp; &nbsp; s[c-1] = '\0';</font></div><div><font size="2"  >&nbsp; return len-slen;</font></div><div><font size="2"  >}</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >void error(char * msg, int exit_val) {</font></div><div><font size="2"  >&nbsp; fprintf(stderr, "%s: %s\n", msg, strerror(errno));</font></div><div><font size="2"  >&nbsp; // if exit_val == 0, not exit the program.</font></div><div><font size="2"  >&nbsp; if (exit_val)</font></div><div><font size="2"  >&nbsp; &nbsp; exit(exit_val);</font></div><div><font size="2"  >}</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >int open_listener_socket() {</font></div><div><font size="2"  >&nbsp; // Create an Internet streaming socket.</font></div><div><font size="2"  >&nbsp; int s = socket(PF_INET, SOCK_STREAM, 0);</font></div><div><font size="2"  >&nbsp; if (s == -1)</font></div><div><font size="2"  >&nbsp; &nbsp; error("Can't open socket", 1);</font></div><div><font size="2"  >&nbsp; return s;</font></div><div><font size="2"  >}</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >void bind_to_port(int socket, int port) {</font></div><div><font size="2"  >&nbsp; struct sockaddr_in name;</font></div><div><font size="2"  >&nbsp; name.sin_family = PF_INET;</font></div><div><font size="2"  >&nbsp; name.sin_port = (in_port_t) htons(port);</font></div><div><font size="2"  >&nbsp; name.sin_addr.s_addr = htonl(INADDR_ANY);</font></div><div><font size="2"  >&nbsp; // Yes, reuse the socket (so you can restart the server without problems).</font></div><div><font size="2"  >&nbsp; int reuse = 1;</font></div><div><font size="2"  >&nbsp; if (setsockopt(socket, SOL_SOCKET, SO_REUSEADDR, (char *) &amp;reuse, sizeof(int)) == -1)</font></div><div><font size="2"  >&nbsp; &nbsp; error("Can't set the reuse option on the socket", 1);</font></div><div><font size="2"  >&nbsp; int c = bind(socket, (struct sockaddr *) &amp;name, sizeof(name));</font></div><div><font size="2"  >&nbsp; if(c == -1)</font></div><div><font size="2"  >&nbsp; &nbsp; error("Can't bind to socket", 1);</font></div><div><font size="2"  >}</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >void listen_to_socket(int socket, int queue) {</font></div><div><font size="2"  >&nbsp; int l = listen(socket, queue);</font></div><div><font size="2"  >&nbsp; if(l == -1)</font></div><div><font size="2"  >&nbsp; &nbsp; error("Can't listen", 1);</font></div><div><font size="2"  >}</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >// wait client connect to this server. return the secondary socketfd.</font></div><div><font size="2"  >int accept_socket(int sockfd, struct sockaddr *addr, socklen_t *addrlen) {</font></div><div><font size="2"  >&nbsp; int connect_d = accept(sockfd, addr, addrlen);</font></div><div><font size="2"  >&nbsp; if (connect_d == -1)</font></div><div><font size="2"  >&nbsp; &nbsp; error("Can't open secondary socket", 1);</font></div><div><font size="2"  >&nbsp; return connect_d;</font></div><div><font size="2"  >}</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >// Send a string to a client.</font></div><div><font size="2"  >int say(int socket, char *s) {</font></div><div><font size="2"  >&nbsp; int result = send(socket, s, strlen(s), 0);</font></div><div><font size="2"  >&nbsp; if(result == -1)</font></div><div><font size="2"  >&nbsp; &nbsp; // when error don't exit.</font></div><div><font size="2"  >&nbsp; &nbsp; error("Error talking to the client", 0);</font></div><div><font size="2"  >&nbsp; return result;</font></div><div><font size="2"  >}</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >// This will store the main listener socket for the server.</font></div><div><font size="2"  >int listener_d;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >// If someone hits Ctrl-C when the server is running,&nbsp;</font></div><div><font size="2"  >// this function will close the socket before the program ends.</font></div><div><font size="2"  >void handle_shutdown(int sig) {</font></div><div><font size="2"  >&nbsp; if(listener_d)</font></div><div><font size="2"  >&nbsp; &nbsp; close(listener_d);</font></div><div><font size="2"  >&nbsp; fprintf(stderr, "Signal:%i, Bye!\n", sig);</font></div><div><font size="2"  >&nbsp; exit(0);</font></div><div><font size="2"  >}</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >int main(int argc, char *argv[]) {</font></div><div><font size="2"  >&nbsp; int port;</font></div><div><font size="2"  >&nbsp; int queue;</font></div><div><font size="2"  >&nbsp; char opt;</font></div><div><font size="2"  >&nbsp; // get option argument</font></div><div><font size="2"  >&nbsp; while ((opt = getopt(argc, argv, "hp:q:")) != EOF) {</font></div><div><font size="2"  >&nbsp; &nbsp; switch(opt) {</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; case 'h':</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; fprintf(stdout, "%s -p $port_num -q $queue_num\n", argv[0]);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; exit(1);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; case 'p':</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; port = atoi(optarg);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; break;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; case 'q':</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; queue = atoi(optarg);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; break;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; default:</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; fprintf(stderr, "Unknown option: %s\n", optarg);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; return 1;</font></div><div><font size="2"  >&nbsp; &nbsp; }</font></div><div><font size="2"  >&nbsp; }</font></div><div><font size="2"  >&nbsp; // if argument count is not 5, exit main function.</font></div><div><font size="2"  >&nbsp; if(argc != 5) {</font></div><div><font size="2"  >&nbsp; &nbsp; fprintf(stdout, "%s -p $port_num -q $queue_num\n", argv[0]);</font></div><div><font size="2"  >&nbsp; &nbsp; return 1;</font></div><div><font size="2"  >&nbsp; }</font></div><div><font size="2"  >&nbsp; // 注册SIGINT 到信号处理函数handle_shutdown.</font></div><div><font size="2"  >&nbsp; if(catch_signal(SIGINT, handle_shutdown) == -1)</font></div><div><font size="2"  >&nbsp; &nbsp; error("Can't set the interrupt handler", 1);</font></div><div><font size="2"  >&nbsp; // 打开一个data stream socket.</font></div><div><font size="2"  >&nbsp; listener_d = open_listener_socket();</font></div><div><font size="2"  >&nbsp; // 绑定到端口port</font></div><div><font size="2"  >&nbsp; bind_to_port(listener_d, port);</font></div><div><font size="2"  >&nbsp; // 监听, 并指定queue长度</font></div><div><font size="2"  >&nbsp; listen_to_socket(listener_d, queue);</font></div><div><font size="2"  >&nbsp; // 准备接收客户端连接</font></div><div><font size="2"  >&nbsp; struct sockaddr_storage client_addr;</font></div><div><font size="2"  >&nbsp; unsigned int address_size = sizeof(client_addr);</font></div><div><font size="2"  >&nbsp; puts("Waiting for connection");</font></div><div><font size="2"  >&nbsp; char buf[255];</font></div><div><font size="2"  >&nbsp; // accept_socket等待客户端连接.</font></div><div><font size="2"  >&nbsp; while(1) {</font></div><div><font size="2"  >&nbsp; &nbsp; // accept将创建the secondary socketfd.</font></div><div><font size="2"  >&nbsp; &nbsp; int connect_d = accept_socket(listener_d, (struct sockaddr *) &amp;client_addr, &amp;address_size);</font></div><div><font size="2"  >&nbsp; &nbsp; // 子进程处理客户端请求</font></div><div><font size="2"  >&nbsp; &nbsp; if ( !fork() ) {</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; close(listener_d);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; if (say(connect_d, "Internet Knock-Knock Protocol Server\r\nVersion 1.0\r\nKnock! Knock!\r\n&gt; ") != -1) {</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; read_in(connect_d, buf, sizeof(buf));</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; if (strncasecmp("Who's there?", buf, 12))</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; say(connect_d, "You should say 'Who's there?'!");</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; else {</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; if (say(connect_d, "Oscar\r\n&gt; ") != -1) {</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; read_in(connect_d, buf, sizeof(buf));</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (strncasecmp("Oscar who?", buf, 10))</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; say(connect_d, "You should say 'Oscar who?'!\r\n");</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; say(connect_d, "Oscar silly question, you get a silly answer\r\n");</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; // 子进程处理完请求后关闭the secondary socketfd. 并退出.</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; close(connect_d);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; exit(0);</font></div><div><font size="2"  >&nbsp; &nbsp; }</font></div><div><font size="2"  >&nbsp; &nbsp; // 主进程不与客户端继续交互, 所以直接关闭the secondary socketfd. 继续while循环, 等待客户端连接.</font></div><div><font size="2"  >&nbsp; &nbsp; close(connect_d);</font></div><div><font size="2"  >&nbsp; }</font></div><div><font size="2"  >&nbsp; return 0;</font></div><div><font size="2"  >}</font></div><p></p></pre></div><div>2. 编译, 执行.</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >[root@db-172-16-3-150 zzz]# gcc -O3 -Wall -Wextra -Werror -I. -g ./server.c -o server</font></div><div><font size="2"  >[root@db-172-16-3-150 zzz]# ./server -h</font></div><div><font size="2"  >./server -p $port_num -q $queue_num</font></div><div><div><font size="2"  >[root@db-172-16-3-150 zzz]# ./server -p 30000 -q 10 &nbsp;// 因为本例用子进程处理客户端请求, 主进程及时的close(connect_d), 所以这个queue不需要太大. 0就可以了.</font></div><div><font size="2"  >Waiting for connection</font></div></div><p></p></pre></div><div><br></div><div>其他会话1 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >[root@db-172-16-3-150 zzz]# telnet 172.16.3.150 30000</font></div><div><font size="2"  >Trying 172.16.3.150...</font></div><div><font size="2"  >Connected to db-172-16-3-150.sky-mobi.com (172.16.3.150).</font></div><div><font size="2"  >Escape character is '^]'.</font></div><div><font size="2"  >Internet Knock-Knock Protocol Server</font></div><div><font size="2"  >Version 1.0</font></div><div><font size="2"  >Knock! Knock!</font></div><div><font size="2"  >&gt; hello</font></div><div><font size="2"  >You should say 'Who's there?'!Connection closed by foreign host.</font></div><p></p></pre></div><div><br></div><div>其他会话2 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >[root@db-172-16-3-150 zzz]# telnet 172.16.3.150 30000</font></div><div><font size="2"  >Trying 172.16.3.150...</font></div><div><font size="2"  >Connected to db-172-16-3-150.sky-mobi.com (172.16.3.150).</font></div><div><font size="2"  >Escape character is '^]'.</font></div><div><font size="2"  >Internet Knock-Knock Protocol Server</font></div><div><font size="2"  >Version 1.0</font></div><div><font size="2"  >Knock! Knock!</font></div><div><font size="2"  >&gt; Who's there?</font></div><div><font size="2"  >Oscar</font></div><div><font size="2"  >&gt; Oscar who?</font></div><div><font size="2"  >Oscar silly question, you get a silly answer</font></div><div><font size="2"  >Connection closed by foreign host.</font></div><p></p></pre></div><div><br></div><div>【注意】</div></div><div><pre class="prettyprint"  ><p></p><div><div><font size="2"  >1. NAME</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;listen - listen for connections on a socket</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >SYNOPSIS</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;#include &lt;sys/socket.h&gt;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;int listen(int sockfd, int backlog);</font></div></div><div><font size="2"  >NOTES</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;The &nbsp;behaviour &nbsp;of &nbsp;the &nbsp;backlog &nbsp;parameter &nbsp;on TCP sockets changed with Linux 2.2. &nbsp;Now it specifies the queue</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;length for completely established sockets waiting to be accepted, instead of the number of &nbsp;incomplete &nbsp;connec-</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;tion &nbsp;requests. The maximum length of the queue for incomplete sockets can be set using the tcp_max_syn_backlog</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;sysctl. &nbsp;When syncookies are enabled there is no logical maximum length and this &nbsp;sysctl &nbsp;setting &nbsp;is &nbsp;ignored.</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;See tcp(7) for more information.</font></div><p></p></pre></div><div><font size="2"  ><br></font></div><wbr></div>
	</div>
</div>
</body>
</html>