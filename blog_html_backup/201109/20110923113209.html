<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL 9.1 Allow standby recovery to switch to a new timeline automatically</h2>
	<h5 id="">2011-09-23 11:32:09&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201182395310376/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><span style="white-space:pre;"  > </span>首先引用 PostgreSQL 9.1 Release Notes 里面的一段话 :&nbsp;<wbr><div><span style="font-family: verdana, sans-serif; line-height: 18px;"  ><font size="2"  ><p style="line-height: 1.5em; margin: 0.2em 0em 1.2em;"  ></p><pre class="prettyprint"  ><p></p><p style="line-height: 1.5em; margin: 0.2em 0em 1.2em;"  >Allow standby recovery to switch to a new timeline automatically (Heikki Linnakangas)</p><p style="line-height: 1.5em; margin: 0.2em 0em 1.2em;"  >Now standby servers scan the archive directory for new timelines periodically .&nbsp;</p><p></p></pre></font></span></div><div><span style="white-space:pre;"  > </span>解释一下什么是时间线文件 : 文件名如 000000xx.history&nbsp;</div><div>这个文件在standby 数据库被 promote 时产生，放在被promote的standby数据库的pg_xlog目录 。</div><div>这个文件产生的同时，被promote的数据库的timeline随之改变。可以在被promote的数据库的服务器上执行pg_controldata查看到Latest checkpoint's TimeLineID : 这条记录的改变 。</div><div><br></div><div><span style="white-space:pre;"  > </span>假设以上的切换是在primary节点干净的关闭(-m fast或-m smart)数据库的情况下做的，并且关库过程中standby节点和primary节点保持畅通，那么正常情况下standby节点将接收到primary节点关库后的最后一次checkpoint信息。也就是说，standby在promote后，原来的主节点可以作为新的主节点的standby库的基础备份，但是需要设置recovery.conf的recovery_target_timeline = 'latest' , 并且需要000xxxx.history这个文件作为恢复文件。其实就是本文开篇时提到的这个动作 “&nbsp;<span style="font-family: verdana, sans-serif; font-size: 12px; line-height: 18px;"  >scan the archive directory for new timelines periodically . "</span></div><div><br></div><div>PostgreSQL 9.0 已经存在这个过程，可以参考我以前写的BLOG ：&nbsp;</div><div><a href="http://blog.163.com/digoal@126/blog/static/163877040201141154024306/"  >http://blog.163.com/digoal@126/blog/static/163877040201141154024306/</a></div><div><br></div><div>下面来测试一下9.1 :&nbsp;</div><div>首先是创建一个primary-standby环境。</div><div>&nbsp;primary库操作 :&nbsp;</div><div>1. 新建Primary 数据库，略 .&nbsp;</div><div><br></div><div>2. 修改Primary 数据库相关参数 .&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >vi $PGDATA/postgresql.conf</font></div><div><font size="2"  >wal_level = hot_standby</font></div><div><font size="2"  >archive_mode = on</font></div><div><font size="2"  >archive_command = '/bin/date'</font></div><div><font size="2"  >max_wal_senders = 32</font></div><div><font size="2"  >wal_sender_delay = 10ms</font></div><div><font size="2"  >wal_keep_segments = 500</font></div><div><font size="2"  >replication_timeout = 60s</font></div><div><font size="2"  ># 以下部分可以先配置好,省的待会切换为standby的时候再配置</font></div><div><font size="2"  >hot_standby = on</font></div><div><font size="2"  >wal_receiver_status_interval = 10s</font></div><div><font size="2"  >hot_standby_feedback = on</font></div><p></p></pre></div><div><br></div><div>3. 新增replica 用户.</div><div><pre class="prettyprint"  ><p><font size="2"  >postgres=# create role replica nosuperuser nocreatedb nocreaterole noinherit login replication encrypted password 'Replica_123';</font></p></pre></div><div><br></div><div>4. 修改pg_hba.conf</div><div>增加一条</div><div><pre class="prettyprint"  ><p><font size="2"  >host replication replica 0.0.0.0/0 md5</font></p></pre></div><div><br></div><div>5. 新建~/.pgpass文件,省的待会切换为standby的时候再配置.为对方的IP。</div><div>vi /home/postgres/.pgpass</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >172.16.3.xx:1921:replication:replica:Replica_123</font></div><div><font size="2"  >chmod 400&nbsp;/home/postgres/.pgpass</font></div><p></p></pre></div><div><br></div><div>&nbsp;standby库操作 :&nbsp;</div><div>1. 安装PostgreSQL软件</div><div>编译条件与原库一样。</div><div><br></div><div>2. 编译与主库一样PG插件,</div><div>如果主库新增了插件，那么备库需要新增一样的插件。</div><div>譬如说我的主库新增了pgfincore和oracle_fdw的插件，那么在备库也要新增这两个插件，否则使用到这些插件的时候会报错。甚至数据库会起不来。</div><div><br></div><div>3. 新建相关目录(主数据目录,表空间目录,pg_xlog目录,或者赋予对应的父目录权限,日志目录)。</div><div>如果不使用pg_basebackup来建立standby的话，这些操作会更加明朗一下。</div><div><br></div><div>4. 新增.pgpass ,&nbsp;为对方的IP。</div><div><div style="line-height: 22px;"  >vi /home/postgres/.pgpass</div><div style="line-height: 22px;"  ><pre class="prettyprint"  ><p></p><div style="line-height: 22px;"  ><font size="2"  >172.16.3.xx:1921:replication:replica:Replica_123</font></div><div style="line-height: 22px;"  ><font size="2"  >chmod 400&nbsp;/home/postgres/.pgpass</font></div><p></p></pre></div></div><div style="line-height: 22px;"  ><br></div><div>5.&nbsp;使用pg_basebackup这个9.1新增的命令来创建standby基备。在此之前, 重启一下主库使之配置生效.</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >postgres@172_168_3_xx-&gt; pg_basebackup -D $PGDATA -F p -x -l basebackup -P -v -h 172.16.3.xxx -p 1921 -U replica&nbsp;</font></div><div><font size="2"  >WARNING: &nbsp;skipping special file "./.s.PGSQL.1921"</font></div><div><font size="2"  >xlog start point: 1/28000020</font></div><div><font size="2"  >WARNING: &nbsp;skipping special file "./.s.PGSQL.1921"pgdata/pg_root/global/12)</font></div><div><font size="2"  >2209131/2209131 kB (100%), 2/2 tablespaces &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"  >xlog end point: 1/280001F8</font></div><div><font size="2"  >pg_basebackup: base backup completed</font></div><p></p></pre></div><div><br></div><div>6. 拷贝/opt/pgsql/share/recovery.conf.example到$PGDATA下面</div><div>修改</div><div><div>postgres@172_168_3_xx-&gt; cat recovery.done |grep -v "^#"</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >recovery_target_timeline = 'latest'</font></div><div><font size="2"  >standby_mode = on</font></div><div><font size="2"  >primary_conninfo = 'host=172.16.3.xx port=1921 user=replica' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # e.g. 'host=localhost port=5432'</font></div><div><font size="2"  >trigger_file = '/home/pgdata/pg_root/postgresql.trigger.1921'</font></div><p></p></pre></div></div><div><br></div><div>7. 启动standby数据库</div><div><pre class="prettyprint"  ><p><font size="2"  >pg_ctl start -D $PGDATA</font></p></pre></div><div><br></div><div>至此环境搭建完毕。</div><div><br></div><div>接下来测试的是角色切换，譬如说我们要对主库添加内存或者维护主机的服务器或者存储。需要把主库停掉。但是在维护完后还要起来。</div><div>维护可能需要几个小时，业务肯定受不了。那么需要激活备库先顶一段时间。</div><div><br></div><div>接下来就是整个切换过程。</div><div>一、 检查操作：</div><div>检查主库和备库的复制正常进行中。</div><div><br></div><div>二、 主库操作：</div><div>停止主库 , 千万不要用-m immediate,这个不会产生关机checkpoint,也不会发送checkpoint给standby。会造出过程不可逆。</div><div><pre class="prettyprint"  ><p><font size="2"  >pg_ctl stop -m fast -D $PGDATA</font></p></pre></div><div>停库日志解析 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >2011-09-23 12:55:13.002 CST,,,6764,,4e7c0cca.1a6c,3,,2011-09-23 12:36:26 CST,,0,LOG,00000,"received fast shutdown request",,,,,,,,,""</font></div><div><font size="2"  >2011-09-23 12:55:13.002 CST,,,6764,,4e7c0cca.1a6c,4,,2011-09-23 12:36:26 CST,,0,LOG,00000,"aborting any active transactions",,,,,,,,,""</font></div><div><font size="2"  >2011-09-23 12:55:13.002 CST,,,6804,,4e7c0d2a.1a94,2,,2011-09-23 12:38:02 CST,1/0,0,LOG,00000,"autovacuum launcher shutting down",,,,,,,,,""</font></div><div><font size="2"  >2011-09-23 12:55:13.004 CST,,,6767,,4e7c0cca.1a6f,3,,2011-09-23 12:36:26 CST,,0,LOG,00000,"shutting down",,,,,,,,,""</font></div><div><font size="2"  >2011-09-23 12:55:13.052 CST,,,6767,,4e7c0cca.1a6f,4,,2011-09-23 12:36:26 CST,,0,LOG,00000,"checkpoint starting: shutdown immediate",,,,,,,,,""</font></div><div><font size="2"  >2011-09-23 12:55:14.344 CST,,,6767,,4e7c0cca.1a6f,5,,2011-09-23 12:36:26 CST,,0,LOG,00000,"checkpoint complete: wrote 0 buffers (0.0%); 0 transaction log file(s) added, 0 removed, 0 recycled; write=0.007 s, sync=0.000 s, total=1.316 s; sync files=0, longest=0.000 s, average=0.000 s",,,,,,,,,""</font></div><div><font size="2"  >2011-09-23 12:55:14.344 CST,,,6767,,4e7c0cca.1a6f,6,,2011-09-23 12:36:26 CST,,0,LOG,00000,"database system is shut down",,,,,,,,,""</font></div><p></p></pre></div><div>停库结束后，主库还有几个进程，一个是主进程，一个是记录日志的进程，一个是SENDER进程。所以这种关闭是会把所有的信息发送给STANDBY库的。</div><div>进程如下 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >/opt/pgsql/bin/postgres</font></div><div><font size="2"  >postgres: logger process &nbsp;&nbsp;</font></div><div><font size="2"  >postgres: wal sender process replica 172.16.3.xxx(29599) streaming 1/46BE0000</font></div><p></p></pre></div><div>数据发完，这些进程会自动关闭。</div><div><br></div><div>备库日志 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >2011-09-23 12:55:12.912 CST,,,22646,,4e7c0d86.5876,12,,2011-09-23 12:39:34 CST,1/0,0,LOG,00000,"redo starts at 1/40000078",,,,,,,,,""</font></div><div><font size="2"  >2011-09-23 12:56:09.309 CST,,,22723,,4e7c0e85.58c3,2,,2011-09-23 12:43:49 CST,,0,FATAL,XX000,"could not receive data from WAL stream: server closed the connection unexpectedly</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; This probably means the server terminated abnormally</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; before or while processing the request.</font></div><div><font size="2"  >",,,,,,,,,""</font></div><p></p></pre></div><div>在主库关闭过程中，备库上可以看到类似以上的日志，表明主库正在发关闭过程的XLOG信息给备库。主库关闭后，备库连不到主库，因此有后面那段报错，这是正常的。此时就可以对备库进行激活操作了，这样的主备角色切换不会丢失任何数据。</div><div><br></div><div>四、 备库操作：</div><div>确认主库正常关库后，激活备库.</div><div><pre class="prettyprint"  ><p><font size="2"  >pg_ctl promote -D $PGDATA</font></p></pre></div><div>备库激活成主库后，把应用改为连接新的主库。</div><div>接到promote信号后，数据库日志如下 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >2011-09-23 12:37:59.218 CST,,,6766,,4e7c0cca.1a6e,6,,2011-09-23 12:36:26 CST,1/0,0,LOG,00000,"received promote request",,,,,,,,,""</font></div><div><font size="2"  >2011-09-23 12:37:59.218 CST,,,6766,,4e7c0cca.1a6e,7,,2011-09-23 12:36:26 CST,1/0,0,LOG,00000,"redo done at 1/3C00C3B0",,,,,,,,,""</font></div><div><font size="2"  >2011-09-23 12:37:59.218 CST,,,6766,,4e7c0cca.1a6e,8,,2011-09-23 12:36:26 CST,1/0,0,LOG,00000,"last completed transaction was at log time 2011-09-23 12:17:04.838732+08",,,,,,,,,""</font></div><div><font size="2"  >2011-09-23 12:37:59.218 CST,,,6766,,4e7c0cca.1a6e,9,,2011-09-23 12:36:26 CST,1/0,0,LOG,00000,"selected new timeline ID: 5",,,,,,,,,""</font></div><div><font size="2"  >2011-09-23 12:38:00.508 CST,,,6766,,4e7c0cca.1a6e,10,,2011-09-23 12:36:26 CST,1/0,0,LOG,00000,"archive recovery complete",,,,,,,,,""</font></div><div><font size="2"  >2011-09-23 12:38:00.539 CST,,,6767,,4e7c0cca.1a6f,1,,2011-09-23 12:36:26 CST,,0,LOG,00000,"checkpoint starting: end-of-recovery immediate wait",,,,,,,,,""</font></div><div><font size="2"  >2011-09-23 12:38:01.939 CST,,,6767,,4e7c0cca.1a6f,2,,2011-09-23 12:36:26 CST,,0,LOG,00000,"checkpoint complete: wrote 9 buffers (0.0%); 0 transaction log file(s) added, 0 removed, 0 recycled; write=0.009 s, sync=0.099 s, total=1.430 s; sync files=8, longest=0.057 s, average=0.012 s",,,,,,,,,""</font></div><div><font size="2"  >2011-09-23 12:38:02.030 CST,,,6804,,4e7c0d2a.1a94,1,,2011-09-23 12:38:02 CST,,0,LOG,00000,"autovacuum launcher started",,,,,,,,,""</font></div><div><font size="2"  >2011-09-23 12:38:02.032 CST,,,6764,,4e7c0cca.1a6c,2,,2011-09-23 12:36:26 CST,,0,LOG,00000,"database system is ready to accept connections",,,,,,,,,""</font></div><p></p></pre></div><div>激活前后进程差异解析 :&nbsp;</div><div>激活前,recovery状态.进程如下 :&nbsp;</div><div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >/opt/pgsql/bin/postgres</font></div><div><font size="2"  >postgres: logger process &nbsp;&nbsp;</font></div><div><font size="2"  >postgres: startup process &nbsp; waiting for 000000040000000100000010</font></div><div><font size="2"  >postgres: writer process &nbsp;&nbsp;</font></div><div><font size="2"  >postgres: stats collector process &nbsp;&nbsp;</font></div><div><font size="2"  >postgres: wal receiver process &nbsp; streaming 1/40000078</font></div><p></p></pre></div><div>激活后,open状态.进程如下 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >/opt/pgsql/bin/postgres</font></div><div><font size="2"  >postgres: logger process &nbsp;&nbsp;</font></div><div><font size="2"  >postgres: writer process &nbsp;&nbsp;</font></div><div><font size="2"  >postgres: stats collector process &nbsp;&nbsp;</font></div><div><font size="2"  >postgres: wal writer process &nbsp;&nbsp;</font></div><div><font size="2"  >postgres: autovacuum launcher process &nbsp;&nbsp;</font></div><div><font size="2"  >postgres: archiver process &nbsp; last was 00000005.history</font></div><div><font size="2"  >postgres: wal sender process replica 172.16.3.xxx(26059) streaming 1/40000078</font></div><p></p></pre></div></div><div>激活后多了&nbsp;wal writer process ,&nbsp;autovacuum launcher process ,&nbsp;archiver process ,&nbsp;wal sender process .&nbsp;</div><div>少了&nbsp;startup process ,&nbsp;wal receiver process .&nbsp;</div><div><br></div><div>五、 维护原来的主库。</div><div><br></div><div>六、 维护好后，把原来的主库作为standby 启动。</div><div>1. 拷贝/opt/pgsql/share/recovery.conf.example到$PGDATA下面</div><div><div style="line-height: 22px;"  >修改</div><div><div style="line-height: 22px;"  ><pre class="prettyprint"  ><p></p><div style="line-height: 22px;"  ><font size="2"  >postgres@172_168_3_xx-&gt; cat recovery.done |grep -v "^#"</font></div><div style="line-height: 22px;"  ><font size="2"  >recovery_target_timeline = 'latest'</font></div><div style="line-height: 22px;"  ><font size="2"  >standby_mode = on</font></div><div style="line-height: 22px;"  ><font size="2"  >primary_conninfo = 'host=172.16.3.xx port=1921 user=replica' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # e.g. 'host=localhost port=5432'</font></div><div style="line-height: 22px;"  ><font size="2"  >trigger_file = '/home/pgdata/pg_root/postgresql.trigger.1921'</font></div><p></p></pre></div><div style="line-height: 22px;"  ><br></div><div style="line-height: 22px;"  >2. 启动数据库</div><div style="line-height: 22px;"  ><pre class="prettyprint"  ><p><font size="2"  >pg_ctl start -D $PGDATA</font></p></pre></div><div style="line-height: 22px;"  ><br></div><div style="line-height: 22px;"  >3. 此时，这个老主库会报错，</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >2011-09-23 10:38:21.965 CST,,,4054,,4e7bf11d.fd6,1,,2011-09-23 10:38:21 CST,,0,FATAL,XX000,"timeline 2 of the primary does not match</font></div><div><font size="2"  >&nbsp;recovery target timeline 1",,,,,,,,,""</font></div><p></p></pre></div><div>这个就是在找时间线文件。这里的时间线文件内容如下 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >postgres@172_168_3_xxx-&gt; cat 00000002.history&nbsp;</font></div><div><font size="2"  >1 &nbsp; &nbsp; &nbsp; 00000001000000010000000B &nbsp; &nbsp; &nbsp; &nbsp;no recovery target specified</font></div><p></p></pre></div><div>这个报错可在源码文件src/backend/replication/libpqwalreceiver/libpqwalreceiver.c中找到。</div><div>对应部分 :&nbsp;</div><div><div><pre class="prettyprint"  ><p></p><div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Confirm that the current timeline of the primary is the same as the</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* recovery target timeline.</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; standby_tli = GetRecoveryTargetTLI();</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; PQclear(res);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; if (primary_tli != standby_tli)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (errmsg("timeline %u of the primary does not match recovery target timeline %u",</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; primary_tli, standby_tli)));</font></div></div><div></div><p></p></pre></div></div><div>4. 我们到新主库的pg_xlog找到这个文件，然后再老的主库pg_xlog目录新建这个文件写入同样的内容就解决了。或者直接scp过去。</div><div style="line-height: 22px;"  ><br></div><div style="line-height: 22px;"  >5. 检查复制，确保复制正常。</div><div style="line-height: 22px;"  ><br></div><div style="line-height: 22px;"  >6. 主库和备库接近一致后，再来一次主库和备库角色切换的操作。</div><div style="line-height: 22px;"  >&nbsp; &nbsp; 6.1 关闭新主库。</div><div style="line-height: 22px;"  >&nbsp; &nbsp; 6.2 激活老主库。</div><div style="line-height: 22px;"  ><div style="line-height: 22px;"  >激活完后，新增了一个时间线文件内容如下，每次时间线变更的记录都将累计下来 :&nbsp;</div><div style="line-height: 22px;"  ><div style="line-height: 22px;"  ><pre class="prettyprint"  ><p></p><div style="line-height: 22px;"  ><font size="2"  >postgres@172_168_3_xxx-&gt; cat 00000003.history&nbsp;</font></div><div style="line-height: 22px;"  ><font size="2"  >1 &nbsp; &nbsp; &nbsp; 00000001000000010000000B &nbsp; &nbsp; &nbsp; &nbsp;no recovery target specified</font></div><div style="line-height: 22px;"  ><font size="2"  ><br style="line-height: 22px;"  ></font></div><div style="line-height: 22px;"  ><font size="2"  >2 &nbsp; &nbsp; &nbsp; 00000002000000010000000D &nbsp; &nbsp; &nbsp; &nbsp;no recovery target specified</font></div><p></p></pre></div><div><font size="2"  >&nbsp; &nbsp; 6.3 然后配置新主库变回STANDBY。</font></div></div></div><div style="line-height: 22px;"  ><br></div></div></div><div style="line-height: 22px;"  >当然，这个时间线文件也可以放在archive directory。</div><div style="line-height: 22px;"  >然后通过以下的recovery.conf里面配置的命令来寻找。</div><div><pre class="prettyprint"  ><p><font size="2"  >restore_command = '' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # e.g. 'cp /mnt/server/archivedir/%f %p'</font></p></pre></div></div>
	</div>
	<h3>评论</h3>
	<div class="" id="" style="padding:0 20px;">
			<div id="">
				<h5 id="">Sophia - 2011-11-22 15:00:32</h5>
				<div><span   style=""  >我又试了几天,反反覆覆重新来过好几次,发现有时资料不会间断,有时候却会出现失序!!(在我复制XXXXXX.history到备机后)<br></span><span   style=""  >请问一下,跟有无设定archive_mode = on与archive_command = ''有关吗?<br></span><span   style=""  >因为不设定他们的话,主备机也建立的起来,所以我有时候会偷懒@@</span></div>
			</div>
			<div style="padding-left:40px;">
				<h5 id="">德哥@Digoal 回复 Sophia - 2011-11-22 15:00:32</h5>
				<div style="width:600px;">没关系,你可能没有按照正常关库来切.</div>
			</div>
			<div style="padding-left:40px;">
				<h5 id="">Sophia 回复 德哥@Digoal - 2011-11-22 15:00:32</h5>
				<div style="width:600px;">所以一定要-m &nbsp;fast ?!!<br><br></div>
			</div>
			<div style="padding-left:40px;">
				<h5 id="">德哥@Digoal 回复 Sophia - 2011-11-22 15:00:32</h5>
				<div style="width:600px;">必须要让STANDBY接收到shutdown checkpoint.<div>对CHECKPOINT不了解的话去看看相关的源代码.</div></div>
			</div>
			<div style="padding-left:40px;">
				<h5 id="">huominglong 回复 德哥@Digoal - 2011-11-22 15:00:32</h5>
				<div style="width:600px;">德哥 有个问题问下 如果master 和 standby非正常断开 standby未接收到shutdown checkpoint 而且standby切换到了master 原来的master变为standby还能和现在的主同步数据吗？</div>
			</div>
			<div style="padding-left:40px;">
				<h5 id="">德哥@Digoal 回复 huominglong - 2011-11-22 15:00:32</h5>
				<div style="width:600px;">可以, 只要2台数据库的Latest checkpoint&#39;s REDO location一致. 并且原来的主库不要启动, 直接从备库恢复即可.</div>
			</div>
			<div id="">
				<h5 id="">Sophia - 2011-11-21 13:07:45</h5>
				<div>恩恩~ xx回答^^<br><br></div>
			</div>
			<div id="">
				<h5 id="">Sophia - 2011-11-18 15:05:29</h5>
				<div><span   style=""  >若是我成功将原本的备库变为主库,而原来的主库设为备库了!!那请问一下..假设在原来的主库修好的途中..从备库变为主库得DB</span><span   style=""  >有新增资料..我要怎么用到后来修好成为备库的机器上? 让他们中间的资料像没有中断?</span></div>
			</div>
			<div style="padding-left:40px;">
				<h5 id="">德哥@Digoal 回复 Sophia - 2011-11-18 15:05:29</h5>
				<div style="width:600px;">HI,<div>只要新主库的WAL日志还在就可以了。</div></div>
			</div>
	</div>
</div>
</body>
</html>